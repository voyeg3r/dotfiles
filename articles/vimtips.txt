*vimtips.txt*  from  http://www.devious.dk/rss/vimtips.txt

For all info on vim see http://vim.sourceforge.net/
Thanks for using vim online.

VimTip 1: the super star
http://vim.sourceforge.net/tip_view.php?tip_id=

When a discussion started about learning vim on the vim list Juergen Salk mentioned the "*" key as something that he wished he had know earlier. When I read the mail I had to go help on what the heck the "*" did. I also wish I had known earlier...

Using the "*" key while in normal mode searches for the word under the cursor.

If that doesn't save you a lot of typing, I don't know what will.

VimTip 2: easy edit of files in the same directory
http://vim.sourceforge.net/tip_view.php?tip_id=

It was often frustrating when I would open a file deep in the code tree and then realize I wanted to open another file in that same directory. Douglas Potts taught me a nice way to do this. Add the following snipit to your vimrc:

"   Edit another file in the same directory as the current file
"   uses expression to extract path from current file's path
"  (thanks Douglas Potts)
if has("unix")
    map ,e :e <C-R>=expand("%:p:h") . "/" <CR>
else
    map ,e :e <C-R>=expand("%:p:h") . "\" <CR>
endif

Then when you type ,e in normal mode you can use tab to complete to the file. You can also expand this to allow for spitting, etc. Very very nice.

VimTip 3: use vim to quickly compile java files
http://vim.sourceforge.net/tip_view.php?tip_id=

For a number of years I used vim on an SGI box. When I left my job at SGI I went to a company that developed on PCs. For 2 years I used IDEs. I was unhappy. I was frustrated. I couldn't figure out why. (Beyond my machine crashing twice a day.) Finally I upgraded to windows 2000 (kind of stable!) and started using vim as an IDE. All was good. Here is how you use vim to compile your java:

1. While I'm sure this works with javac, javac is slow slow slow. So download the Jikes complier first. (Jikes is from ibm, search on google for jikes and you will find it..available on most platforms.)

2. Add the following to your vimrc:

set makeprg=jikes -nowarn -Xstdout +E %
set errorformat=%f:%l:%c:%*\d:%*\d:%*\s%m

3. When you are editing a java file type :make and it will compile the current file and jump you to the first error in the file (if any). Read ":help quickfix" for how to move between errors.

To setup your classpath environment either launch gvim from a shell that has your classpath/path setup or use the "let" command to configure it in your vimrc.

VimTip 4: Any word completion
http://vim.sourceforge.net/tip_view.php?tip_id=

Either when programming or writing, I tend to have some identifiers or words that I use all the time. By sheer accident, I noticed the 'ctrl-n' command, that will attempt to complete the word under the cursor. Hit it once, and it will try to complete it with the first match in the current file. If there is no match, it will (at least in the case of C code) search through all files included from the current one. Repeated invocations will cycle through all found matches.

VimTip 5: Quickly searching for a word
http://vim.sourceforge.net/tip_view.php?tip_id=

To search for a word under the cursor in the current file you
can use either the "*" or "#" keys.

The "*" key will search for the word from the current cursor
position to the end of the file. The "#" key will search for the
word from the current cursor position to the top of the file.

Note that the above two keys will search for the whole word and not
the partial word.  This is equivalent to using the <word> pattern
in the search commands (/ and ?).

To search for partial matches, you can use the "g*" and "g#" key
sequence.

You can also use the mouse to search for a word.  This will only
work in the GUI version of VIM (gvim) or a console version
of VIM in an xterm which accepts a mouse. Also, the 'mousemodel'
should be set to 'extend'.  Add the following line to your .vimrc:

set mousemodel=extend

To search for a word under the cursor from the current cursor
position to the end of the file, press the shift key and click
on the word using the left mouse button.  To search in the opposite
direction, press the shift key and click on the word using the
the right mouse button.

To get more help on these, use

:help *
:help #
:help g*
:help g#
:help <S-LeftMouse>
:help <S-RightMouse>

VimTip 6: Using the % key
http://vim.sourceforge.net/tip_view.php?tip_id=

The % key can be used

1. To jump to a matching opening or closing parenthesis, square
   bracket or a curly brace i.e. ([{}])
2. To jump to start or end of a C-style comment /* */.
3. To jump to a matching #if, #ifdef, #else, #elif, #endif C
   preprocessor conditionals.

To get more information about this, do

             :help %

The % key can be extended to support other matching pairs by
modifying the "matchpairs" option.  Read the help on

             :help matchpairs

VimTip 7: Jumping to the start and end of a code block
http://vim.sourceforge.net/tip_view.php?tip_id=

To jump to the beginning of a C code block (while, switch, if etc),
use the [{ command.

To jump to the end of a C code block (while, switch, if etc),
use the ]} command.

The above two commands will work from anywhere inside the code
block.

To jump to the beginning of a parenthesis use the [( command.

To jump to the end of a parenthesis use the ]) command.

To get more help on these commands, do

:help [{
:help ]}
:help [(
:help ])

VimTip 8: Jumping to the declaration of a local/global variable
http://vim.sourceforge.net/tip_view.php?tip_id=

'gd' command:
To jump to the declaration of a local variable in a C program,
position the cursor on the name of the variable and use the
gd command.

'gD' command:
To jump to the declaration of a global variable in a C program,
position the cursor on the name of the variable and use the
gD command.

VimTip 9: Displaying a variable/macro definition
http://vim.sourceforge.net/tip_view.php?tip_id=

To display the definition of a variable, place the cursor on the
variable and use the [i command.  To display a macro definition,
place the cursor on the macro name and use the [d command.
Note that these commands will work most of the time (not all the
time).  To get more help on these commands, use

:help [i
:help [d

VimTip 10: Jumping to previosuly visited locations in a file
http://vim.sourceforge.net/tip_view.php?tip_id=

Vim remembers all the locations visited by you in a file in a session.
You can jump to the older locations by pressing the Ctrl-O key.  You
can jump to the newer locations by pressing the Ctrl-I or the <Tab>
key.

To get more help on these keys, use

:help CTRL-O
:help CTRL-I
:help jump-motions

VimTip 11: Completing words quicky in insert mode
http://vim.sourceforge.net/tip_view.php?tip_id=

In Insert mode, press the Ctrl-p or Ctrl-n key to complete part of
a word that has been typed.

This is useful while typing C programs to complete long variable and
function names.  This also helps in avoiding typing mistakes.

Note that using the 'complete' option, you can complete keywords
defined in one of the include files, tag file, etc.

To get more help on this, use

:help i_Ctrl-N
:help i_Ctrl-P
:help ins-completion
:help complete

VimTip 12: Converting tabs to spaces
http://vim.sourceforge.net/tip_view.php?tip_id=

To insert space characters whenever the tab key is pressed, set the
'expandtab' option:

        set expandtab

With this option set, if you want to enter a real tab character use
Ctrl-V<Tab> key sequence.

To control the number of space characters that will be inserted when
the tab key is pressed, set the 'tabstop' option.  For example, to
insert 4 spaces for a tab, use:

        set tabstop=4

After the 'expandtab' option is set, all the new tab characters entered
will be changed to spaces.  This will not affect the existing tab
characters.  To change all the existing tab characters to match the
current tab settings, use

        :retab

To change the number of space characters inserted for indentation, use
the 'shiftwidth' option:

        set shiftwidth=4

For example, to get the following coding style,
        - No tabs in the source file
        - All tab characters are 4 space characters

use the following set of options:

        set tabstop=4
        set shiftwidth=4
        set expandtab

Add the above settings to your .vimrc file.

To get more help on these options, use
:help tabstop
:help shiftwidth
:help expandtab

VimTip 13: Incremental search
http://vim.sourceforge.net/tip_view.php?tip_id=

To move the cursor to the matched string, while typing the search
string, set the following option in the .vimrc file:

        set incsearch

You can complete the search by pressing the Enter key.  To cancel
the search, press the escape key.

VimTip 14: Highlighting all the search pattern matches
http://vim.sourceforge.net/tip_view.php?tip_id=

To highlight all the search pattern matches in a file set the
following option:

        :set hlsearch

After this option is set, if you search for a pattern, all the
matches in the file will be highlighted in yellow.

To disable the highlighting temporarily, use the command

        :nohlsearch

This command will remove the highlighting for the current search.
The highlighting will come back for the next search.

To disable the highlighting completely, set the following option:

        :set nohlsearch

By default, the hlsearch option is turned off.

To get more help on this option, use

:help 'hlsearch'
:help :nohlsearch

VimTip 15: Displaying status line always
http://vim.sourceforge.net/tip_view.php?tip_id=

To display the status line always, set the following option in
your .vimrc file:

        set laststatus=2

The advantage of having the status line displayed always is, you
can see the current mode, file name, file status, ruler, etc.

To get more help on this, use

:help laststatus

VimTip 16: Avoiding the "Hit ENTER to continue" prompts
http://vim.sourceforge.net/tip_view.php?tip_id=

To avoid the "Hit ENTER to continue" prompt, use the 'shortmess'
option.  Add the following line to your .vimrc file:

    set shortmess=a

Also, you can increase the height of the command line to 2

    set cmdheight=2

The default command height is 1.

To get more help on these options, use

:help hit-enter
:help shortmess
:help cmdheight

VimTip 17: Erasing previosuly entered characters in insert mode
http://vim.sourceforge.net/tip_view.php?tip_id=

In insert mode, to erase previously entered characters, set the
following option:

        set backspace=2

By default, this option is empty.  If this option is empty, in
insert mode, you can not erase characters entered before this
insert mode started.  This is the standard Vi behavior.

To get more help on this, use

:help 'backspace'

VimTip 18: Cleanup your HTML
http://vim.sourceforge.net/tip_view.php?tip_id=

From Johannes Zellner on the vim list:

You can use vim's makeprg and equalprg to clean up HTML. First download html tidy from http://www.w3.org/People/Raggett/tidy/. Then use the following commands.

vim6?
exe 'setlocal equalprg=tidy -quiet -f '.&errorfile
setlocal makeprg=tidy -quiet -e %

vim5?
exe 'set equalprg=tidy -quiet -f '.&errorfile
set makeprg=tidy -quiet -e %

At this point you can use make to clean up the full file or you can use = to clean up sections.

:help =
:help equalprg
:help makeprg

VimTip 19: line numbers...
http://vim.sourceforge.net/tip_view.php?tip_id=

I have started doing all my code reviews on a laptop because of the number command.

:set number will put line numbers along the left side of a window

:help number

VimTip 20: Are *.swp and *~ files littering your working directory?
http://vim.sourceforge.net/tip_view.php?tip_id=

Have you ever been frustrated at swap files and backups cluttering
up your working directory?

Untidy:
  ons.txt
  ons.txt~
  README
  README~
  tester.py
  tester.py~

Here are a couple of options that can help:

  set   backupdir=./.backup,.,/tmp
  set   directory=.,./.backup,/tmp

This way, if you want your backups to be neatly grouped, just
create a directory called '.backup' in your working directory.
Vim will stash backups there. The 'directory' option controls
where swap files go. If your working directory is not writable,
Vim will put the swap file in one of the specified places.

VimTip 21: easy pasting to windows apps
http://vim.sourceforge.net/tip_view.php?tip_id=

In Vim, the unnamed register is the " register, and the Windows
Clipboard is the * register. This means that if you yank something,
you have to yank it to the * register if you want to paste it into
a Windows app. If this is too much trouble, set the 'clipboard'
option to 'unnamed'. Then you always yank to *.

So pasting to windows apps doesn't require prefixing "* :

  set   clipboard=unnamed

VimTip 22: handle common typos for :commands
http://vim.sourceforge.net/tip_view.php?tip_id=

I frequently hold the shift key for too long when typing, for instance :wq, and end up with :Wq.  Vim then whines "Not an editor command: Wq"

In my .vimrc, I have taught vim my common typos:
command! Q  quit
command! W  write
command! Wq wq
" this one won't work, because :X is already a built-in command
command! X  xit

VimTip 23: Vim xterm title
http://vim.sourceforge.net/tip_view.php?tip_id=

Check out your .vimrc. If 'set notitle' is an entry, comment it out with a quotation mark ("). Now your xterm should inherit the title from Vim.            e.g. 'Vim - ~/.vimrc'. This can be quite nice when programming and editing lots of files at the same time.
by [jonasbn@wanadoo.dk]

VimTip 24: changing the default syntax highlighting
http://vim.sourceforge.net/tip_view.php?tip_id=

     Here are some pointers to the vim documentation.  Notice that the mechanism is different in vim 6.0 and vim 5.x.

1. I want *.foo files to be highlighted like HTML files.

:help new-filetype  http://www.vim.org/html/autocmd.html#new-filetype

2. I want to define a syntax file for *.bar files.  Read the above and also

:help mysyntaxfile  http://www.vim.org/html/syntax.html#mysyntaxfile

3. I want to make a few changes to the existing syntax highlighting.  Depending on the x in 5.x, either read the above and page down a few screens, or you may be able to skip right to

:help mysyntaxfile-add  http://www.vim.org/html/syntax.html#mysyntaxfile-add

4. I want to change some of the colors from their defaults.  Again, read

:help mysyntaxfile  http://www.vim.org/html/syntax.html#mysyntaxfile

VimTip 25: color highlighting on telnet (esp w/ SecureCRT)
http://vim.sourceforge.net/tip_view.php?tip_id=

The following settings in .vimrc will enable color highlighting when using SecureCRT and may work on other telnet packages. The terminal type should be selected as ANSI and color enabled.

if !has("gui_running")
set t_Co=8
set t_Sf=^[[3%p1%dm
set t_Sb=^[[4%p1%dm
endif

The ^[ is entered as "<ctrl-v><esc>"

VimTip 26: Getting rid of ^M - mixing dos and unix
http://vim.sourceforge.net/tip_view.php?tip_id=

If you work in a mixed environment you will often open files that have ^M's in them. An example would be this:

------------------------------------------------------------------
import java.util.Hashtable; ^M
import java.util.Properties; ^Mimport java.io.IOException;
import org.xml.sax.AttributeList; ^M
import org.xml.sax.HandlerBase; ^Mimport org.xml.sax.SAXException;

/**^M
  * XMLHandler: This class parses the elements contained^M
  * within a XML message and builds a Hashtable^M

[snip]
------------------------------------------------------------------

Notice that some programs are not consistent in the way they insert the line breaks so you end up with some lines that have both a carrage return and a ^M and some lines that have a ^M and no carrage return (and so blend into one). There are two steps to clean this up.

1. replace all extraneous ^M:

:%s/^M$//g

BE SURE YOU MAKE the ^M USING "CTRL-V CTRL-M" NOT BY TYPING "CARROT M"! This expression will replace all the ^M's that have carriage returns after them with nothing. (The dollar ties the search to the end of a line)

2. replace all ^M's that need to have carriage returns:

:%s/^M//g

Once again: BE SURE YOU MAKE the ^M USING "CTRL-V CTRL-M" NOT BY TYPING "CARROT M"! This expression will replace all the ^M's that didn't have carriage returns after them with a carriage return.

Voila! Clean file. Map this to something if you do it frequently.

:help ffs - for more info on file formats

thanks to jonathan merz, douglas potts, and benji fisher

VimTip 27: Convert hex to dec
http://vim.sourceforge.net/tip_view.php?tip_id=

when you check the output of objdump, you'll confused by the $0xFFFFFFc operand, this function translate the hexcamal to decimal.
function! Hex2Dec()
    let lstr = getline(".")
    let hexstr = matchstr(lstr, '0x[a-f0-9]+')
    while hexstr != ""
        let hexstr = hexstr + 0
        exe 's#0x[a-f0-9]+#'.hexstr."#"
        let lstr = substitute(lstr, '0x[a-f0-9]+', hexstr, "")
        let hexstr = matchstr(lstr, '0x[a-f0-9]+')
    endwhile
endfunction
usage:
5,8call Hex2Dec()

VimTip 28: add a line-number to every line without cat or awk alike utilities.
http://vim.sourceforge.net/tip_view.php?tip_id=

With Unix-like environment, you can use cat or awk to generate a line number easily, because vim has a friendly interface with shell, so everything work in vim as well as it does in shell.
:%!call -n
or
:%!awk '{print NR,$0}'

But, if you use vim in MS-DOS, of win9x, win2000, you loss these tookit.
here is a very simple way to archive this only by vim:
fu! LineIt()
  exe ":s/^/".line(".")."/"
endf

Well, a sequence composed with alphabet is as easy as above:
  exe "s/^/".nr2char(line("."))."/"

VimTip 29: reverse all the line with only 7 keystroke in vim
http://vim.sourceforge.net/tip_view.php?tip_id=

:g/^/m0
well,
1. : bring you to command-line mode(also known as ex-mode) from normal-mode(also known as command mode).
2. g means you'll take an action through the whole file, generally perform a search, `v' also perform a search but it match the line not match the canonical expression.
3. / begins the regular express
4. ^ is a special character respect the start of a line.
5. the second / ends the regular express and indicate that the remains is action to do.
6. m means move, `t` and `co' for copy, `d' for delete
7. 0 is the destination line.

you can use
:g/regexp/t$
to filter all lines and pick the match line together and copy them to the end of the buffer or
:g/regexp/y A
to put them into a register(not eax, ebx...)

VimTip 30: Increasing or decreasing numbers
http://vim.sourceforge.net/tip_view.php?tip_id=

To increase a number under or nearest to the right of the cursor, go to Normal mode and type:
    Ctrl-A

To decrease, type:
    Ctrl-X

Using this in a macro simplifies generating number sequences a lot.

VimTip 31: Find and Replace
http://vim.sourceforge.net/tip_view.php?tip_id=

To find and replace one or more occurences of a given text pattern with a
new text string, use the s[ubstitute] command.

There are a variety of options, but these are what you most probably want:

:%s/foo/bar/g           find each occurance of 'foo' and replace it with 'bar' without asking for confirmation

:%s/foo/bar/gc          find each occurance of 'foo' and replace it with 'bar' asking for confirmation first

:%s/<foo>/bar/gc      find (match exact word only) and replace each occurance of 'foo' with 'bar'

:%s/foo/bar/gci         find (case insensitive) and replace each occurance of 'foo' with 'bar'

:%s/foo/bar/gcI         find (case sensitive) and replace each occurance of 'foo' with 'bar'

NB: Without the 'g' flag, replacement occurs only for the first occurrence in each line.

For a full description and some more interesting examples of the substitute command refer to

:help substitute

See also:

:help cmdline-ranges
:help pattern
:help gdefault

VimTip 32: Write your own vim function(scripts)
http://vim.sourceforge.net/tip_view.php?tip_id=

compare to C and shell(bash), herein is some vim specifics about vim-script:
1. A function name must be capitalized.
   hex2dec is invalid
   Hex2dec is valid
   while in c and shell(bash), both lowercase and uppercase is allowed.
2. how to reference the parameters
   fu! Hex2dec(var1, var2)
    let str=a:var1
    let str2=a:var2
   you must prefix the parameter name with "a:", and a:var1 itself is read-only
   in c, you reference the parameter directly and the parameter is writable.
3. how to implement variable parameter
   fu! Hex2dec(fixpara, ...)
     a:0 is the real number of the variable parameter when you invoke the function, with :Hex2dec("asdf", 4,5,6), a:0=3, and a:1=4 a:2=5 a:3=6
   you can combine "a:" and the number to get the value
   while i<a:0
     exe "let num=a:".i
     let i=i+1
   endwhile
   in c, the function get the real number by checking the additional parameter such as printf family, or by checking the special value such as NULL
4. where is the vim-library
  yes, vim has its own function-library, just like *.a in c
  :help functions
5. can I use += or ++ operator?
  Nop, += and ++ (and -=, -- and so on)operator gone away in vim.
6. How can I assign a value to a variables and fetch its value?
   let var_Name=value
   let var1=var2
   like it does in c, except you must use let keyword
7. Can I use any ex-mode command in a function?
  As I know, yes, just use it directly, as if every line you type appears in the familar :
8. Can I call a function recurse?
  Yes, but use it carefully to avoid infinte call.
9. Can I call another function in a function?
  Course, like C does.
10. Must I compile the function?
   No, you needn't and you can't, just :so script_name, after this you can call the function freely.
11. Is it has integer and char or float data type?
   No, like perl, vim script justify the variable type depend upon the context
   :let a=1
   :let a=a."asdf"
   :echo a
   you'll get `1asdf'
   :let a=1
   :let a=a+2
   :echo a
   you'll get 3
   But it differs from perl.
12. Must I append a `;' in every statement?
   No, never do that.
   ; is required in C, and optional in shell for each statement in a alone line.
   But is forbidden in vim.
   if you want combine servals statement in one single line, use `|'.
   Take your mind that every statement appears in function should be valid in ex-mode(except for some special statement).

VimTip 33: toggle off the line-number when enter on-line help
http://vim.sourceforge.net/tip_view.php?tip_id=

I like the line-number for myself editing. But I hate it in on-line help page because it force the screen wrapped.
:au filetype help :se nonu

VimTip 34: control the position of the new window
http://vim.sourceforge.net/tip_view.php?tip_id=

:se splitbelow
make the new window appears below the current window.
:se splitright
make the new window appears in right.(only 6.0 version can do a vsplit)

VimTip 35: For programmer: translate // style comment to /*  */and vice vesa
http://vim.sourceforge.net/tip_view.php?tip_id=

the `|' concatenate servals ex-command in one line.
It's the key to translate // style comments to /* */ style
:g#^s{-}//#s##/*# | s#$#*/#

the `|' keep the current line matchs ^s{-}// to perform s#$#*/

/* ... */ ---> //style
:g#/*(.{-})*/#//1#

/* ....
   ....
   .....
*/
=====>
//......
//......
//......
style:
? Anyone implement it?

VimTip 36: Using Gnu-info help in vim
http://vim.sourceforge.net/tip_view.php?tip_id=

K in normal bring you the man page about the keyword under current cursor.
:nnoremap <F1> :exe ":!info ".expand("<cword>")
Now press F1 while the cursor is hold by a keyword such as printf will bring you to Gnu-info help page
:h <F1>
:h nnoremap

VimTip 37: The basic operation about vim-boolean optionals
http://vim.sourceforge.net/tip_view.php?tip_id=

:set number
switch the number on
:set nonumber
switch it off
:set invnumber
or
:set number!
switch it inverse against the current setting
:set number&
get the default value vim assums.

replace number with any legal vim-boolean optionals, they all works well.
for vim-non-boolean optionals
:set optional&
also works properly.

VimTip 38: Cursor one line at a time when :set wrap
http://vim.sourceforge.net/tip_view.php?tip_id=

If your tierd of the cursor jumping past 5 lines when :set wrap then add these mappings to you vimrc file.

nnoremap j gj
nnoremap k gk
vnoremap j gj
vnoremap k gk
nnoremap <Down> gj
nnoremap <Up> gk
vnoremap <Down> gj
vnoremap <Up> gk
inoremap <Down> <C-o>gj
inoremap <Up> <C-o>gk

What they do is remap the cursor keys to use there `g' equvilant. See :help gj

VimTip 39: Undo and Redo
http://vim.sourceforge.net/tip_view.php?tip_id=

To undo recent changes, use the u[ndo] command:

u              undo last change (can be repeated to undo preceding commands)
U              return the line to its original state (undo all changes in current line)
CTRL-R         Redo changes which were undone (undo the undo's).

For a full description of the undo/redo commands refer to

:help undo

VimTip 40: Insert a file
http://vim.sourceforge.net/tip_view.php?tip_id=

To insert the contents of a file (or the output of a system command)
into the current buffer, use the r[ead] command:

Examples:

:r foo.txt        inserts the file foo.txt below the cursor

:0r foo.txt       inserts the file foo.txt above the first line

:r !ls            inserts a listing of your directory below the cursor

:$r !pwd          inserts the current working directory below the last line

For more information about the r[ead] command refer to:

:help read

See also:

:help cmdline-ranges
:help !cmd

VimTip 41: Command-history facilities for Oracle/sqlplus user
http://vim.sourceforge.net/tip_view.php?tip_id=

	First of all, thanks Benji fisher,  Stefan Roemer...
and others in vim@vim.org which spend much time to
answer questions, sometimes foolish question asked by
someone like me. Without their I can't get the final
solution for my sqlplus work descripted follows.
	As Oracle user known, sqlplus has a very bad
command-line edition environment. It has no
command-history, don't support most of getline
facilities. which MySQL and shell does it well.
Even Microsoft recogonize this point. In Windows2000,
doskey is installed by default.
	Below is my vim-solution to sqlplus, which
record the command-history when you use
edit(sqlplus builtin command) to open the editor
specified by EDITOR environment variable. It saves
the SQL statement into a standalone file such as
.sqlplus.history
	Every time you open the file
afiedt.buf(sqlplus's default command-buffer file),
you get two splited windows, the buffer above is
afiedt.buf, the buffer below is .sqlplus.history,
you can see every SQL statement in the windows.
If you want to use SQL statement in line 5 to replace
 the current command-buffer, just press 5K, then
	:xa
	to back to you sqlplus. and use / to repeat the command
 saved in command-buffer file called afiedt.buf by default.
	It can't process multi-line SQL statement convinencely.
 Todo this, just use you favorite vim trick to do that:
	fu! VimSQL()
    nnoremap <C-K> :<C-U>
	exe "let linenum=".v:count<CR>:1,$-1d<CR><C-W>j:exe lin
	enum."y"<CR><C-W>kP
    let linenum=line("$")
    1,$-1w! >> ~/.sqlplus.history
    e ~/.sqlplus.history
    execute ":$-".(linenum-1).",$m0"
    %!uniq
    if line("$")>100
      101,$d
    endif
    b#
    set splitbelow
    sp ~/.sqlplus.history
    au! BufEnter afiedt.buf
endf
au BufEnter afiedt.buf call VimSQL()

VimTip 42: Using marks
http://vim.sourceforge.net/tip_view.php?tip_id=

To mark one or more positions in a file, use the m[ark] command.

Examples:

ma       -    set current cursor location as mark a

'a       -    jump to beginning of line of mark a

`a       -    jump to postition of mark a

d'a      -    delete from current line to line of mark a

d`a      -    delete from current cursor position to mark a

c'a      -    change text from current line to line of mark a

y`a      -    yank text to unnamed buffer from cursor to mark a

:marks   -    list all the current marks

NB: Lowercase marks (a-z) are valid within one file. Uppercase marks
(A-Z), also called file marks, are valid between files.

For a detailed description of the m[ark] command refer to

:help mark

See also:

:help various-motions

VimTip 43: Using abbreviations
http://vim.sourceforge.net/tip_view.php?tip_id=

To define abbreviations, use the ab[breviate] command.

Examples:

:ab rtfm read the fine manual  -  Whenever you type 'rtfm' followed by a <space> (or <esc> or <cr>) vim
                                  will expand this to 'read the fine manual'.

:ab                            -  list all defined abbreviations

:una[bbreviate] rtfm           -  remove 'rtfm' from the list of abbreviations

:abc[lear]                     -  remove all abbreviations

NB: To avoid expansion in insert mode, type CTRL-V after the last character of the abbreviation.

For a detailed description of the ab[breviate] command and some more examples refer to

:help abbreviations

VimTip 44: Repeat last changes
http://vim.sourceforge.net/tip_view.php?tip_id=

Simple text changes in normal mode (e.g. "dw" or "J") can be repeated with the "." command.
The last command-line change (those invoked with ":", e.g. ":s/foo/bar") can be
repeated with the "@:" command.

For more informations about repeating single changes refer to:

:help single-repeat

VimTip 45: Using command-line history
http://vim.sourceforge.net/tip_view.php?tip_id=

You can recall previous command lines from a history table by hitting
the <Up> and <Down> cursor keys in command-line mode.
For example, this can be used to find the previous substitute command:
Type ":s" and then <Up>.

There are separate history tables for the ':' commands and for
previous '/' or '?' search strings.

To display the history of last entered commands or search strings,
use the :his[tory] command:

:his       -      Display command-line history.

:his s     -      Display search string history.



For a detailed description of the command-line history refer to:

:help cmdline-history

See also:

:help Cmdline-mode

VimTip 46: Win32 binaries with perl, python, and tcl
http://vim.sourceforge.net/tip_view.php?tip_id=

> Does anyone know if windows binaries of vim 5.7 are available with perl and
> python support turned on?

ftp://vim.sourceforge.net/pub/vim/upload_binaries/

http://vim.sourceforge.net/bin_download/

VimTip 47: Swapping characters, words and lines
http://vim.sourceforge.net/tip_view.php?tip_id=

To swap two characters or lines, use the following commands:

xp       -     delete the character under the cursor and put it afterwards.
               (In other words, it swaps the characters.)

ddp      -     delete the current line and put it afterwards.
               (In other words, it swaps the lines.)

Unfortunately there is no universal solution to swap two words.
You may try the following ones, but don't expect too much of them:

dawwP    -     delete the word under the cursor, move forward one word
               and put it back after the cursor.  (In other words, it
               swaps the current and following word.)


dawbP    -     delete the word under the cursor, move backward on word
               and put it back after the cursor.  (In other words, it
               swaps the current and preceeding word.)

VimTip 48: Moving around
http://vim.sourceforge.net/tip_view.php?tip_id=

You can save a lot of time when navigating through the text by using
appropriate movements commands. In most cases the cursor keys,
<PageUp> or <PageDown> are NOT the best choice.

Here is a selection of some basic movement commands that
hopefully helps you to acquire a taste for more:

e   - move to the end of a word
w   - move forward to the beginning of a word
3w  - move forward three words
b   - move backward to the beginning of a word
3b  - move backward three words

$       - move to the end of the line
<End>   - same as $
0       - move to the beginning of the line
<Home>  - same as 0

)   - jump forward one sentence
(   - jump backward one sentence

}   - jump forward one paragraph
{   - jump backward one paragraph

H   - jump to the top of the display
M   - jump to the middle of the display
L   - jump to the bottom of the display

'm  - jump to the beginning of the line of mark m
`m  - jump to the location of mark m

G   - jump to end of file
1G  - jump to beginning of file
50G - jump to line 50

'' - return to the line where the cursor was before the latest jump
`` - return to the cursor position before the latest jump (undo the jump).

%  - jump to corresponding item, e.g. from an open brace to its
     matching closing brace


For some more interesting movement commands (especially those
for programmers) refer to:

:help motion.txt

:help search-commands

VimTip 49: Switching case of characters
http://vim.sourceforge.net/tip_view.php?tip_id=

To switch the case of one or more characters use the "~", "gU" or
"gu" commands.

Examples:

~     -     switch case of character under cursor
            (in visual-mode: switch case of highlighted text)

3~    -     switch case of next three characters

g~~   -     switch case of current line

U     -     in visual-mode: make highlighted text uppercase

gUU   -     make current line uppercase

u     -     in visual-mode: make highlighted text lowercase

guu   -     make current line lowercase

gUaw  -     make current word uppercase

guaw  -     make current word lowercase

For some more examples refer to

:help ~

See also:

:help simple-change

VimTip 50: Recovering files
http://vim.sourceforge.net/tip_view.php?tip_id=

If your computer has crashed while editing a file, you should be able
to recover the file by typing

      vi -r <filename>

where <filename> is the name of the file you were editing at the time
of the crash.
If you were editing without a file name, give an empty string as argument:

      vim -r ""

To get a list of recoverable files start vim without arguments:

      vim -r

For more information about file recovery refer to:

:help recovery

VimTip 51: Entering german umlauts
http://vim.sourceforge.net/tip_view.php?tip_id=

To enter german umlauts (or any other of those weired
characters) not available on your keyboard use 'digraphs':

In insert-mode type for example:


     CTRL-K "a

     CTRL-K ^e


which gives an 'ä' and 'e' with a hat.

You can also set the digraph option:

    :set digraph (or :set dg)

With digraph option set you can enter

    " <BS> a

    ^ <BS> e

which gives the same result.

To get a list of currently defined digraphs type

   :dig[graphs]

For more information about defining and using digraphs refer to:

:help digraph.txt

VimTip 52: Scrolling synchronously
http://vim.sourceforge.net/tip_view.php?tip_id=

If you want to bind two or more windows such that when one
window is scrolled, the other windows are scrolled simultaneously,
set the 'scrollbind' option for these windows:

:set scrollbind

When a window that has 'scrollbind' set is scrolled, all other
'scrollbind' windows are scrolled the same amount, if possible.

For more information about the 'scrollbind' option refer to

:help scoll-binding

VimTip 53: Better colors for syntax highlighting
http://vim.sourceforge.net/tip_view.php?tip_id=

For syntax highlighting there are two sets of default color
maps: One for a light and another one for a dark background.
If you have a black background, use the following command to
get a better color map for syntax highlighting:

:set background=dark

You have to switch off and on again syntax highlighting to
activate the new color map:

:syntax off
:syntax on

For a detailled description of syntax highlighting refer to

:help syntax.txt

See also the Vim syntax support file: $VIMRUNTIME/syntax/synload.vim

VimTip 54: View a Java Class File Decompiled thru Vim
http://vim.sourceforge.net/tip_view.php?tip_id=

Hi All,
Wish u could view a Java Class File using Vim,
Well ur query ends here.
First of all u will need a Java Decompiler to decompile
the Class File.
I would suggest the JAD decompiler by Pavel Kouznetsov
http://www.geocities.com/SiliconValley/Bridge/8617/jad.html

Its a command line decompiler and absolutely free.
U can use any command line decompiler of ur choice.

Next create a vimscript file called jad.vim as
######################### FILE START ################
augr class
au!
au bufreadpost,filereadpost *.class %!d:jad.exe -noctor -ff -i -p %
au bufreadpost,filereadpost *.class set readonly
au bufreadpost,filereadpost *.class set ft=java
au bufreadpost,filereadpost *.class normal gg=G
au bufreadpost,filereadpost *.class set nomodified
augr END
######################## FILE END #####################

Note:- Keep the Jad.exe in a directory with out white spaces.
The -p options directs JAD to send the output to standard output
instead of a .jad file. Other options are described on the JAD site.

Next add the following line in the .vimrc file.
so jad.vim

Next time u do vim abc.class. Viola u have the source code
for abc.class.

NOTE:- I have written the script so as to open the class file
read only, So that u dont accidently modify it.
U can also exted this script to unjar a jar file and then view each
file in the JAR file.
thanks
bhaskar
Any suggestions are welcome

VimTip 55: previous buffer
http://vim.sourceforge.net/tip_view.php?tip_id=

One of the keys to vim is buffer management. If I have to use another IDE that makes me click on a tab every time I want to look at another file I'm going to go postal.

So of course you know about :ls which lists all the current open buffers. This gets a little unweildly once you have a full project open so you can also use :b <any snipit of text> <tab> to complete to an open buffer. This is really nice because you can type any fragment of a file name and it will complete to the matching file. (i.e. RequestManager.java can be completed using "tma"<tab> or "req"<tab> or "r.java"<tab>).

Now for awhile I was also using :bn and :bp which jumps you to the next and previous buffer respectively. I found I was often frustrated because I wanted :bp to be the previous buffer I was in, not the previous buffer in the list. So (drum roll) the reason I wrote this tip was because of:

:b#

jump to the previous buffer you were in. Very very handy. The only thing nicer are tag, but that's a tip for another time.

:help buffers
:help bn
:help bp

If anybody knows where to get help on # in this context please add notes.

VimTip 58: how to avoid obliterating window layout
http://vim.sourceforge.net/tip_view.php?tip_id=

If you take the time to lay out several windows
with vim (especially vertically in version 6), you may be bummed when
you hit an errant key and find that all but what one window
disappears.

What happens: while navigating between windows, you
hit <C-W>j, <C-W>k, etc.  At some point you accidently
hit <C-W> but then don't follow with a window command.
Now hitting 'o' to start insert mode issues a command
equivalent to :only, and closes all windows execept
for the one you are in (unless some windows have unsaved
changes in them).

How to avoid this: petition the vim-dev mailing list about
how :only is sufficient for the infrequenty use this might
get (j/k).

Really: use mapping to disable the <C-W>o functionality; put
this in your .vimrc:

nnoremap <C-W>O :echo "sucker"<CR>
nnoremap <C-W>o :echo "sucker"<CR>
nnoremap <C-W><C-O> :echo "sucker"<CR>

references:

:help :only
:help CTRL-W_o

That is all.
Scott

VimTip 62: Applying substitutes to a visual block
http://vim.sourceforge.net/tip_view.php?tip_id=

If you'd like to apply a substitute, or even any ex command, to a visual-block
selected text region (ctrl-v and move), then you'll want Stefan Roemer's
http://www.erols.com/astronaut/vim/vimscript/vis.vim .  Just source it in,
and then press ":B".  On the command line you'll see

:'<,'>BCtrl-V

Just continue with the substitute or whatever...

:'<,'>B s/abc/ABC/g

and the substitute will be applied to just that block of text!

Example: Ctrl-V Select..........|......Type
..................just the central....|......:B s/abc/ABC/g
..................four "abc"s..............|
..................----------------....|...-------------
..................abcabcabcabc............|......abcabcabcabc
..................abcabcabcabc............|......abcABCABCabc
..................abcabcabcabc............|......abcABCABCabc
..................abcabcabcabc............|......abcabcabcabc
 (dots inserted to retain tabular format)

VimTip 63: Applying substitutes to a visual block
http://vim.sourceforge.net/tip_view.php?tip_id=

If you'd like to apply a substitute, or even any ex command, to a visual-block
selected text region (ctrl-v and move), then you'll want Stefan Roemer's
http://www.erols.com/astronaut/vim/vimscript/vis.vim .  Just source it in,
and then press ":B".  On the command line you'll see

:'<,'>BCtrl-V

Just continue with the substitute or whatever...

:'<,'>B s/abc/ABC/g

and the substitute will be applied to just that block of text!

Example: Ctrl-V Select..........|......Type
..................just the central.......|......:B s/abc/ABC/g
..................four "abc"s.................|
..................---------............|...-------------
..................abcabcabcabc............|......abcabcabcabc
..................abcabcabcabc............|......abcABCABCabc
..................abcabcabcabc............|......abcABCABCabc
..................abcabcabcabc............|......abcabcabcabc
 (dots inserted to retain tabular format)

VimTip 64: Always set your working directory to the file you're editing
http://vim.sourceforge.net/tip_view.php?tip_id=

Sometimes I think it's helpful if your working directory is always the same as the buffer you are editing.  You need to put this in your .vimrc:

function! CHANGE_CURR_DIR()
	let _dir = expand("%:p:h")
	exec "cd " . _dir
	unlet _dir
endfunction

autocmd BufEnter * call CHANGE_CURR_DIR()

Doing this will make a "cd" command to your the current buffer each time you switch to it.  This is actually similar to vimtip#2 but more automatic.

You should see for more details:
:help autocmd
:help expand
:help function

Note: This tip was contributed by somebody on the list a while ago (sorry for no reference) and it has been extremely helpful to me. Thanks!

VimTip 65: Insert line number into the actuall text of the file.
http://vim.sourceforge.net/tip_view.php?tip_id=

Although :set number will add nice line number for you At time you may wish to actually place the line numbers into the file. For example on GNU Unix you can acomplish a simular task using cat -n file > new_file

In VIM you can use the global command to do this

:g/^/exec "s/^/".strpart(line(".")."    ", 0, 4)

What this does is run the exec comand on every line that matches /^/ (All)
The exec command taks a string and executes it as if it were typed in.

line(".")."    " -> returns the number of the current line plus four spaces.
strpart("123    ", 0, 4) -> returns only the first four characters ("123 ").
"s/^/123 " -> substituts the begining of the line with "123 ".

VimTip 66: Transfer text between two Vim 'sessions',
http://vim.sourceforge.net/tip_view.php?tip_id=

This one is a one of my favorites from Dr. Chip, and I haven't seen it come
across vim tips yet...

Can use either visual, or marking to denote the text.

" transfer/read and write one block of text between vim sessions
" Usage:
" `from' session:
"     ma
"     move to end-of-block
"     xw
"
" `to' session:
"     move to where I want block inserted
"     xr
"
if has("unix")
  nmap xr   :r $HOME/.vimxfer<CR>
  nmap xw   :'a,.w! $HOME/.vimxfer<CR>
  vmap xr   c<esc>:r $HOME/.vimxfer<CR>
  vmap xw   :w! $HOME/.vimxfer<CR>
else
  nmap xr   :r c:/.vimxfer<CR>
  nmap xw   :'a,.w! c:/.vimxfer<CR>
  vmap xr   c<esc>:r c:/.vimxfer<cr>
  vmap xw   :w! c:/.vimxfer<CR>
endif

VimTip 67: Ascii Value
http://vim.sourceforge.net/tip_view.php?tip_id=

Sometimes we, the programmers, need the value of a character, don't we?
You can learn the ascii value of a character by pressing g and a keys.(ga)!
It displays the value in dec, hex and octal...

VimTip 68: Delete key
http://vim.sourceforge.net/tip_view.php?tip_id=

Don't worry if your delete key does not work properly.
Just press <CTRL>-Backspace.
It works under both mode(insert or normal).

VimTip 69: dot makes life easier
http://vim.sourceforge.net/tip_view.php?tip_id=

You can copy and paste the last changes you made in the last insert mode
without using y and p by pressing . (just dot).
Vim memorizes the keys you pressed and echos them if you hit the dot key.
You must be in command mode as usual.
It can be helpful...

VimTip 70: running a command on all buffers
http://vim.sourceforge.net/tip_view.php?tip_id=

From Peter Bismuti on the vim list:

How to global search and replace in all buffers with one command?
You need the AllBuffers command:

:call AllBuffers("%s/string1/string2/g")

"put this in a file and source it
function AllBuffers(cmnd)
  let cmnd = a:cmnd
  let i = 1
  while (i <= bufnr("$"))
    if bufexists(i)
      execute "buffer" i
      execute cmnd
    endif
    let i = i+1
  endwhile
endfun

":call AllBuffers("%s/foo/bar/ge|update")

Thanks Peter!

VimTip 71: Transfer text between two gvim sessions using clipboard
http://vim.sourceforge.net/tip_view.php?tip_id=

If you use gvim, you can transfer text from one instance of gvim into another one using clipboard.  It is convenient to use * (star) register, like this:

In one instance yank two lines into clipboard:
    "*2yy
Paste it in another instance in normal mode:
    "*p
or in insert mode:
    <Ctrl-R>*

VimTip 72: Remove unwanted empty lines
http://vim.sourceforge.net/tip_view.php?tip_id=

Sometimes to improve the readability of the document I insert empty lines, which will be later removed.
To get rid off them try:
:%g/^$/d
This will remove a l l  empty line in the document.
Some other tipps you can find under www.linuxclass.de/vim.phtml

VimTip 73: Using vim as calculator
http://vim.sourceforge.net/tip_view.php?tip_id=

Basic calculations can done within vim easily by typing (insert-mode):
STRG (=CTRL) + R followed by =
then for example 2+2 and hit RETURN
the result 4 will be printed in the document.

Some other tipps you can find under www.linuxclass.de/vim.phtml

VimTip 74: Using Vim as an outline processor
http://vim.sourceforge.net/tip_view.php?tip_id=

With the addition of folding, Vim6 can function as a high performance outline processor. Simply :set ai and in insert mode use backspace to promote and tab to demote headlines.

In command mode, << promotes (n<< to promote multiple lines), and >> demotes. Also, highlight several headlines and < or > to promote or demote.

:set foldmethod=indent, and then your z commands can expand or collapse headline trees, filewide or by the tree.

The VimOutliner GPL distro contains the scripts and configs to easily configure Vim6 as an outliner, including scripts to create tag files enabling interoutline hyperlinking.

The VimOutliner project is at http://www.troubleshooters.com/projects/vimoutliner/index.htm.

Steve (Litt)
slitt@troubleshooters.com

VimTip 75: Remap CAPSLOCK key in Windows 2000 Professional and NT4.0
http://vim.sourceforge.net/tip_view.php?tip_id=

If you're Windows 2000 Professional user and got tired to move your hands off basic row when hitting <ESC> key
here the solution (not for Windows 9x.):
remap CapsLock key as <ESC> key. It's located in useful position.
Put this lines into <EscLock.reg> file and start it in explorer.Reboot.Enjoy.

REGEDIT4
[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Keyboard Layout]
"Scancode Map"=hex:00,00,00,00,00,00,00,00,02,00,00,00,01,00,3a,00,00,00,00,00

To restore you capslock back just delete this entry from Registry and reboot.
And below is remapping <capslock> as <Left Control>:

REGEDIT4
[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Keyboard Layout]
"Scancode Map"=hex:00,00,00,00,00,00,00,00,02,00,00,00,1d,00,3a,00,00,00,00,00

VimTip 76: Folding for Quickfix
http://vim.sourceforge.net/tip_view.php?tip_id=

The Quickfix mode aims to "speed up the edit-compile-edit cycle" according to ':help quickfix'. After executing ':make' or ':grep' it is possible to skim through the list of errors/matches and the appropriate source code locations with, for instance, the ':cnext' command.
Another way to get a quick overview is to use VIMs folding mode, to fold away all the error-free/match-free regions.
The script at the end of this message can be used for this purpose. It is at the moment not elaborate enough to put it up as a 'script'; but it might give someone inspiration to do so.
Big restrictions / bugs are as follows:
1. Vim Perl interface is required, i.e. the output of ':version' must contain '+perl' (People with Vim scripting knowledge might fix this)
2. Works only for one file, i.e. the current buffer.
3. It's a quick hack.
Sample usage: (a) edit a file, (b) do ':grep regexp %' to get a quickfix error list and (c) ':source foldqf.vim' will fold as described
Increasing the value of $CONTEXT gives you more context around the error regions.

Here comes it, it should be 7 lines:
---foldqf.vim
cwindow
perl $CONTEXT = 0;
perl @A = map { m/\|(\d+)\|/; $1 +0 } $curbuf->Get(1..$curbuf->Count());
close
normal zD
perl sub fold { VIM::DoCommand( $_[0] . ',' . ($_[1]) . "fold" ) if( $_[0] < $_[1] ); }
perl $last = 0; for (@A) { fold( $last+1+$CONTEXT, $_-1-$CONTEXT ); $last = $_; }; VIM::DoCommand(($A[-1]+1+$CONTEXT ) . ',$fold' );

VimTip 77: Displaying search results using folds
http://vim.sourceforge.net/tip_view.php?tip_id=

A guy I work with told me about a function that an old IBM text editor had that he said was useful, and that is to create folds in the file after a search such that every line that is visible contains the search pattern(except possibly the first). All lines that do not contain the search pattern are folded up to the last occurence of the pattern or the top of the file.

One use for such a function is to be able to make a quick and dirty api of a source file.  For example, if working in Java, you could run the function using the pattern "public|protected|private" and ithe results would be that only the method headers would be visible (well, close enough).

function! Foldsearch(search)
        normal zE          "erase all folds to begin with
        normal G$          "move to the end of the file
	let folded = 0     "flag to set when a fold is found
        let flags = "w"    "allow wrapping in the search
        let line1 =  0     "set marker for beginning of fold
        while search(a:search, flags) > 0
                let  line2 = line(".")
		"echo "pattern found at line # " line2
                if (line2 -1 > line1)
                        "echo line1 . ":" . (line2-1)
                        "echo "A fold goes here."
                        execute ":" . line1 . "," . (line2-1) . "fold"
						let folded = 1       "at least one fold has been found
                endif
                let line1 = line2     "update marker
                let flags = "W"       "turn off wrapping
        endwhile
		" Now create the last fold which goes to the end of the file.
        normal $G
        let  line2 = line(".")
		"echo "end of file found at line # " line2
        if (line2  > line1 && folded == 1)
                "echo line1 . ":" . line2
                "echo "A fold goes here."
                execute ":". line1 . "," . line2 . "fold"
        endif
endfunction

" Command is executed as ':Fs pattern'"
command! -nargs=+ -complete=command Fs call Foldsearch(<q-args>)
" View the methods and variables in a java source file."
command! Japi Fs public\|protected\|private

VimTip 78: rotating mail signatures
http://vim.sourceforge.net/tip_view.php?tip_id=

For people using mutt and vim for mail, the following script will allow you to insert a new signature (and again and again if you don\'t like the current one) at the bottom of your mail. This is usefull eg when you don\'t want to send a potentially offensive quote to someone you don\'t know very well (or a mailing list), but are too lazy to delete the quote, open your quotes file, and cut and paste another one in. (I put it here in \'tips\' and not in \'scripts\' because it is imo too short to be a \'real\' script)

" rotate_sig.vim
" Maintainer:  Roel Vanhout <roel@2e-systems.com>
" Version:     0.1
" Last Change: Tuesday, June 12, 2001
" Mapping I use:
" nmap ,r :call RotateSig()<CR>
" Usage:
" -Make sure you delimit your sig with '-- ', or adjust the script
" -Adjust the last execute to a command that prints a sig to stdout
" Known problems:
"   - You'll get an error message when you're below the last
"     '^-- $' in your mail (nothing bad though - just an not-
"     found marker)

function! RotateSig()
    normal mQG
    execute '?^-- $'
    execute ':nohl'
    normal o<ESC>
    normal dG
    normal <CR>
    execute 'r !~/bin/autosig ~/.quotes \%'
    normal `Q
endfunction

VimTip 79: How to use :grep to get a clickable list of function names
http://vim.sourceforge.net/tip_view.php?tip_id=

The following function will make a :cwindow window with a line per function
in the current C source file. NOTE: It writes the file as a side effect.

Invoke with ':call ShowFunc()'
You may want to do :nmap <somekey> :call ShowFunc()<CR>

function! ShowFunc()


    let gf_s = &grepformat
    let gp_s = &grepprg

    let &grepformat = '%*\k%*\sfunction%*\s%l%*\s%f %*\s%m'
    let &grepprg = 'ctags -x --c-types=f --sort=no -o -'

    write
    silent! grep %
    cwindow

    let &grepformat = gf_s
    let &grepprg = gp_s

endfunc

VimTip 80: Restore cursor to file position in previous editing session
http://vim.sourceforge.net/tip_view.php?tip_id=

Here's something for your <.vimrc> which will allow you to restore your cursor position in a file over several editing sessions.  This technique uses the viminfo option:

Ex. set viminfo='10,\"100,:20,%,n~/.viminfo
    au BufReadPost * if line("'\"") > 0|if line("'\"") <= line("$")|exe("norm '\"")|else|exe "norm $"|endif|endif

If you're on Unix, the viminfo is probably fine as is (but check up on Vim's help for viminfo to see if you like the settings above).  For Windows you'll need to change the "n" suboption to something like

Ex. set viminfo='10,\"100,:20,%,nc:\\some\\place\\under\\Windoz\\_viminfo

This tip is a somewhat improved version of the example given for :he line()
in the Vim on-line documentation.

VimTip 81: Substitution of characters and lines in VIM is made far easier with the s and S commands
http://vim.sourceforge.net/tip_view.php?tip_id=

Substitute  Characters
-----------------------------------
I was just editing a file that contained the same leading string on many lines.

example:

foo_bar_baz1=a
foo_bar_baz1=abc674
foo_bar_baz1=qrs
foo_bar_baz1=m1
foo_bar_baz1=bz90
foo_bar_baz1=bc
...

Needing to only substitute a portion of the string, I referred to a VIM reference card and discovered a command answering my need exactly. The s command is used to subsitute a certain number of characters. In my example file above, if I only needed to subsititute the characters foo_bar, I set the cursor on the first character where I'd like the subsitution to begin and type 7s. VIM drops the characters foo_bar and goes to insert mode, waiting for the substitution text.

Substitute Lines
-----------------------
After years of using vi and VIM and always deleting multiple lines in order to replace them, I just discovered the S command. If you need to subsitute three lines of text, simply type 3S. VIM drops the three lines and goes into insert mode, waiting for the subsitution text.

VimTip 82: letting variable values be overwritten in a script
http://vim.sourceforge.net/tip_view.php?tip_id=

this is a simple function i wrote to get the value of a variable from three different places (in that order):  the current buffer, the global setting or from the script itself.

this allows me to set a default value for a configuration variable inside my script and the user to change it on a global level by setting the same variable with a g: prepended.  then, they can further set it on a per-buffer level by the the b: mechanism.  one of the examples for this might be my comments script (not uploaded).  i have a variable in there that determines whether comment characters (// for java, for example) are placed the beginning of the line or just before the first-non-blanks in the text.  i set up a default in my script:

let s:comments_hug_start_of_line=0   " comments should hug the text

that's fine as a default, but if i want to overwrite it for vim scripts, i just put the following in my ftplugin/vim.vim:

let b:comments_hug_start_of_line=1   " vim comments should hug the first column, always

" tries  to return  the buffer-specific  value of  a variable;  if not
" found,  tries to  return the  global value  -- if  that's not  found
" either, returns the value set in the script itself
function! GetVar(varName)
  if (exists ("b:" . a:varName))
    exe "let retVal=b:" . a:varName
  elseif (exists ("g:" . a:varName))
    exe "let retVal=g:" . a:varName
  elseif (exists ("s:" . a:varName))
    exe "let retVal=s:" . a:varName
  else
    retVal=-1
  endif
  return retVal
endfunction

personally, i never let it get to the -1 state by always having an s: set with SOME default value.

VimTip 83: how to indent (useful for source code)
http://vim.sourceforge.net/tip_view.php?tip_id=

Here is the most useful vim command that I know of and I'm surprised that it's not yet in the tips list.

I use the indent features of vim all the time. Basically, it lets you indent your source code.

SETUP: To make indentation work nicely I have the following in my .vimrc file:
set et
set sw=4
set smarttab

these make vim behave nicely when indenting, giving 4 spaces (not tabs) for each "tabstop".

HOW TO USE:
in command mode, == will indent the current line
selecting a range of lines (with shift-v) then == will indent your selection
typing a number then == will indent that many lines, starting from your cursor
(you get the idea, there are many other things you can do to select a range of lines)

Tell me that isn't great?

VimTip 84: Changing the behaviour of . to include visual mode
http://vim.sourceforge.net/tip_view.php?tip_id=

one of the things i do a lot in vim is to make a change to the beginning
or end of  the line (such as adding  the text '// remove' at  the end of
java debug code).  a quick way of doing  this is to use a  to append the
text to the end of the first line  and then move down one, hit . (repeat
last edit), move down, hit .  etc. etc. the following mapping allows one
to  simply  highlight the  region  in  question and  hit  .  -- it  will
automatically execute the . once on each line:

  " allow the . to execute once for each line of a visual selection
  vnoremap . :normal .<CR>

another thing i do a lot is to  record a quick macro in the "a" register
and then play it back a number of  times. while @@ can be used to repeat
the last register used, my recorded macros sometimes use other registers
so @@ doesn't necessarily  give me the same results as  @a. also, i have
mapped ' to `  because i like to go to the precise  location of my marks
-- always --  and never to the  beginning of the line. this  leaves my `
key unused. so:

  " make ` execute the contents of the a register
  nnoremap ` @a

then, in keeping with the visual . above, i did the same for the ` -- is
thexecutes @a once on each highlighed line.

  vnoremap ` :normal @a<CR>

as an example, say i have the following lines of java code:

      public String m_asdf;
      public String m_lkhj;
      public int m_hjkhjkh;

and, for some reason, i need to get the following:

      "asdf"
      "lkhj"
      "hjkhjkh"

i record the following into a:

  ^cf_"<ESC>$r"

the ^  is because my  java code is  indented and i  don't want to  go to
column 0 and the <esc> is an actual escape i hit to exit insert mode.

then, i  simply select (visually) the  other lines (only two  in case --
admittedly not an overly useful example) and just hit `.

VimTip 85: How to mimic the vim 6.0 plugin feature with older versions
http://vim.sourceforge.net/tip_view.php?tip_id=

If you do not have vim 6.0, but would like to mimic the plugins directory feature then copy and paste this into your vimrc:

exec "source " . substitute(glob($VIM."/plugins/*.vim"), "\n", "\nsource ", "g")

It will automatically source every vim script file located in the vim/plugins directory.
Now, to add a new plugin, just drop the script in this directory and vim will automatically find it.

VimTip 86: Helps undo 1 line when entered many
http://vim.sourceforge.net/tip_view.php?tip_id=

When U entered text, U cannot undo only 1 line, for example, when U press "u", all entered in last "insert" text removed.

If U add this line to .vimrc:
inoremap <Return> <Return>^O^[
where "^O" or "^[" is 1 char
"u" will undo (remove) only 1 line.

VimTip 87: Get vim 5.x window in vim 6.x
http://vim.sourceforge.net/tip_view.php?tip_id=

The format of the window title in vim 5.x (well, at least for 5.7,.8, for Win32) used to be VIM - <full filename with path>.  It's not in the win32 binary of 6.0an that I found.  I want my old way back.

Turns out, all that it takes to get it back is
:set title titlestring=VIM\ -\ %F "make sure that the window caption setting is turned on and set caption to vim 5.x style

Oh, however, one thing I did like about the 6.0 style is that it puts the word "help" in the title when the current buffer is a help file; so, I just tacked %h to my titlestring giving:

:set title titlestring=VIM\ -\ %F\ %h "make sure that the window caption setting is turned on and set caption to vim 5.x style

see also:
:he 'titlestring'
:he 'statusline'    "for the format for titlestring

VimTip 88: How to maximize vim on entry (win32)
http://vim.sourceforge.net/tip_view.php?tip_id=

Maybe it's just because I have far too small of a monitor, because I can get distracted while coding if I have other stuff on the screen, or because I starting using vim on a console, but I definitely like my vim window maximized.  Anyway, sticking the following in your vimrc will always maximize your vim window on startup.

au GUIEnter * simalt ~x

:he win16-maximized

VimTip 89: Get more screen real estate by hidding toolbar and/or menus
http://vim.sourceforge.net/tip_view.php?tip_id=

I use gvim over console vim because gvim is much more readable (under Windows).  However, that doesn't mean I want to dedicate screen space to things I'll never use (i.e. the toolbar and the menus).

Anyway, you can give the following a try if you'd like.

set guioptions-=T "get rid of toolbar
set guioptions-=m "get rid of menu

Oh, yeah.  If you decide that you don't really like being without your the toolbar or menus, issue the following:

set guioptions+=T "bring back toolbar
set guioptions+=m "bring back menu

see also:
:he 'guioptions

VimTip 90: Encryption
http://vim.sourceforge.net/tip_view.php?tip_id=

You can encrypt your texts by using vim.
:X  prompts for an encryption key.
After writing your key, if you save your document
it will be encrypted and no one else (but you and vim)
can read your documents.
If you reopen the file, VIM will ask for the key.
If you want to disable encryption, just type
:set key=
if you forget your key you will lose your document.
So please DO NOT forget your key,



VimTip 91: Dictionary completions
http://vim.sourceforge.net/tip_view.php?tip_id=

This tip will will explain how to use the dictionary completion facilities provided by vim.  This can be useful if you use vim to type your email, edit code, etc.

Dictionary completion is one of many search facilites provided by Insert mode completion.  It allows the user to get a list of keywords, based off of the current word at the cursor.  This is useful if you are typing a long word (e.g. acknowledgeable) and don't want to finish typing or don't remember the spelling.

To start, we must first tell vim where our dictionary is located.  This is done via the 'dictionary'  option.  Below is an example.  Your location may vary.  See :help 'dictionary'  for hints as to where you should look.

	:set dictionary-=/usr/share/dict/words dictionary+=/usr/share/dict/words

Now, to use this list we have to enter insert mode completion.  This is done by hitting CTRL-X while in insert mode.  Next, you have to specify what you want to complete.  For dictionaries use CTRL-K.  Once in this mode the keys CTRL-N and CTRL-P will cycle through the matches.  So, to complete the word "acknowledgeable" I would do the following in insert mode:

	acknow<CTRL-X><CTRL-K><CTRL-N>

It can be cumbersome to type CTRL-X CTRL-K for many different completions.  So, vim gives us a shortcut.  While in insert mode CTRL-N and CTRL-P will cycle through a predetermined set of completion sources.  By default, dictionary completion is not a part of this set.  This set is defined by the 'complete' option.  Therefore, we must add dictionary to this as shown below:

	:set complete-=k complete+=k

Now, while in insert mode we can type the following to complete our example:

	acknow<CTRL-N><CTRL-N>

This shortcut may not save a whole lot of typing.  However, I find that it requires less hand movement to only worry myself with two key combinations, rather than 4.

I find that the completion facilites provided by vim save me a *HUGE* amount of typing.  These savings can be realized in only a short amount of time if you are editing some code with functions and variables that have long names with underscores in them.

For more help:
	help ins-completion
	help compl-dictionary
	help 'complete'
	help 'dictionary'
	help :set+=

VimTip 92: Reducing 'doc' directory size
http://vim.sourceforge.net/tip_view.php?tip_id=

As everyone knows, the $VIMRUNTIME/doc is increasing rapidly in size. The directory contained so many plain-text documents that I often compress them to save my diskspace. With the support of VIM's GZIP plugin, VIM will automatically uncompress the files when we need to read them.
Here is my procedure:
1.  If you have the source, go to 'runtime/doc' and edit 'doctags.c', change       printf("%s\t%s\t/*", p1, argv[0]);  to  printf("%s\t%s.gz\t/*", p1, argv[0]);
     then make. This is to modify the tag, or you'll have to change the 'tags' file by hand if you don't have doctags.c.
2. Edit the new generated 'tags' file to rename 'help.txt.gz' back to 'help.txt' because it's hard-written in VIM executable binary.
     :% s/help\.txt\.gz/help\.txt/g
3. Copy the new 'tags' to $VIMRNUTIME/doc and run 'gzip *.txt; gunzip help.txt'

On VIM 6.0an, we can reduce the original size (3302k) to 1326k.
I don't know if this helps, but if someone likes to compress documents... this can be reffered :)



VimTip 93: if you use 'highlight search' feature, map a key to :noh
http://vim.sourceforge.net/tip_view.php?tip_id=

It is very convenient to use 'hlsearch' option.  However it can be annoying to have the highlight stick longer than you want it.  In order to run it off you have to type at least 4 keystrokes, ":noh".  So, it's a good idea to map this to a key.  I like to map it to control-n.  This is the line I use in my .vimrc file to do it:

nmap <silent> <C-N> :silent noh<CR>

VimTip 94: Questions & Answers about using tags with Vim
http://vim.sourceforge.net/tip_view.php?tip_id=

Using tags file with Vim
------------------------
This document gives you a idea about the various facilities available
in Vim for using a tags file to browse through program source files.
You can read the Vim online help, which explains in detail the tags
support, using :help tagsearch.txt.  You can also use the help
keywords mentioned in this document to read more about a particular
command or option.  To read more about a particular command or option
use, :help <helpkeyword> in Vim.

1. How do I create a tags file?

   You can create a tags file either using the ctags utility or using
   a custom script or utility.

   Help keyword(s): tag

2. Where can I download the tools to generate the tags file?

   There are several utilities available to generate the tags file.
   Depending on the programming language, you can use any one of them.

   1. Exuberant ctags generates tags for the following programming
      language files:


      Assembler, AWK, ASP, BETA, Bourne/Korn/Zsh Shell, C, C++, COBOL,
      Eiffel, Fortran, Java, Lisp, Make, Pascal, Perl, PHP, Python,
      REXX, Ruby, S-Lang, Scheme, Tcl, and Vim.

      You can download exuberant ctags from
      http://ctags.sourceforge.net/

   2. On Unix, you can use the /usr/bin/ctags utility.  This utility
      is present in most of the Unix installations.


   3. You can use jtags for generating tags file for java programs.
      You can download jtags from: http://www.fleiner.com/jtags/

   4. You can use ptags for generating tags file for perl programs.
      You can download ptags from:
      http://www.eleves.ens.fr:8080/home/nthiery/Tags/

   5. You can download scripts from the following links for
      generating tags file for verilog files:


            http://www.probo.com/vtags.htm
            http://www.cs.albany.edu/~mosh/Perl/veri-tags
            http://www.verilog.net/vrtags.txt

   6. You can download Hdrtag from the following linke:

            http://www.erols.com/astronaut/vim/index.html#Tags

      This utility generates tags file for the following programming
      languages: assembly, c/c++, header files, lex, yacc,LaTeX, vim,
      and Maple V.

   7. You can also use the following scripts which are part of the Vim
      runtime files:

          pltags.pl - Create tags file for perl code
          tcltags - Create tags file for TCL code
          shtags.pl - Create tags file for shell script

   Help keyword(s): ctags

3. How do I generate a tags file using ctags?

   You can generate a tags file for all the C files in the current
   directory using the following command:

        $ ctags *.c

   You can generate tags file for all the files in the current
   directory and all the sub-directories using (this applies only to
   exuberant ctags):

        $ ctags -R .

   You can generate tags file for all the files listed in a text file
   named flist using (this applies only to exuberant ctags)

       $ ctags -L flist

4. How do I configure Vim to locate a tags file?

   You can set the 'tags' option in Vim to specify a particular tags
   file.

        set tags=/my/dir/tags

   Help keyword(s): 'tags', tags-option

5. How do I configure Vim to use multiple tags files?

   The 'tags' option can specify more than one tags file.  The tag
   filenames are separated using either comma or spaces.

        set tags=/my/dir1/tags, /my/dir2/tags

6. How do I configure Vim to locate a tags file in a directory tree?

   Note that the following will work only in Vim 6.0 and above.  You
   can set the 'tags' option to make Vim search for the tags file in a
   directory tree.  For example, if the 'tags' option is set like
   this:

        set tags=tags;/

   Vim will search for the file named 'tags', starting with the
   current directory and then going to the parent directory and then
   recursively to the directory one level above, till it either
   locates the 'tags' file or reaches the root '/' directory.

   Help keyword(s): file-searching

7. How do I jump to a tag?

   There are several ways to jump to a tag location.
        1. You can use the 'tag' ex command.  For example,

               :tag <tagname>


           will jump to the tag named <tagname>.
        2. You can position the cursor over a tag name and then press
           Ctrl-].
        3. You can visually select a text and then press Ctrl-] to
           jump to the tag matching the selected text.
        4. You can click on the tag name using the left mouse button,
           while pressing the <Ctrl> key.
        5. You can press the g key and then click on the tag name
           using the left mouse button.
        6. You can use the 'stag' ex command, to open the tag in a new
           window.  For example,

                :stag func1

           will open the func1 definition in a new window.
        7. You can position the cursor over a tag name and then press
           Ctrl-W ].  This will open the tag location in a new window.

   Help keyword(s): :tag, Ctrl-], v_CTRL_], <C-LeftMouse>,
                    g<LeftMouse>, :stag, Ctrl-W_]

8. How do I come back from a tag jump?

   There are several ways to come back to the old location from a tag
   jump.
        1. You can use the 'pop' ex command.
        2. You can press Ctrl-t.
        3. You can click the right mouse button, while pressing the
           <Ctrl> key.
        4. You can press the g key and then click the right mouse
           button.

   Help keyword(s): :pop, Ctrl-T, <C-RightMouse>, g<RightMouse>

9. How do I jump again to a previously jumped tag location?

   You can use the 'tag' ex command to jump to a previously jumped tag
   location, which is stored in the tag stack.

   Help keyword(s): tag

10. How do I list the contents of the tag stack?

   Vim remembers the location from which you jumped to a tag in the
   tag stack.  You can list the current tag stack using the 'tags' ex
   command.

   Help keyword(s): :tags, tagstack

11. How do I jump to a particular tag match, if there are multiple
    matching tags?

    In some situations, there can be more than one match for a tag.
    For example, a C function or definition may be present in more
    than one file in a source tree.  There are several ways to jump to
    a specific tag from a list of matching tags.


        1. You can use the 'tselect' ex command to list all the tag
           matches.  For example,

                :tselect func1

          will list all the locations where func1 is defined.  You can
          then enter the number of a tag match to jump to that
          location.
        2. You can position the cursor over the tag name and press g]
           to get a list of matching tags.
        3. You can visually select a text and press g] to get a list
           of matching tags.
        4. You can use the 'stselect' ex command.  This will open the
           selected tag from the tag list in a new window.
        5. You can position the cursor over the tag name and press
           Ctrl-W g] to do a :stselect.

    Help keyword(s): tag-matchlist, :tselect, g], v_g], :stselect,
                     Ctrl-W_g]

12. I want to jump to a tag, if there is only one matching tag,
    otherwise a list of matching tags should be displayed.  How do I
    do this?

    There are several ways to make Vim to jump to a tag directly, if
    there is only one tag match, otherwise present a list of tag
    matches.

        1. You can use the 'tjump' ex command.  For example,

                :tjump func1

           will jump to the definition func1, if it is defined only
           once.  If func1 is defined multiple times, a list of
           matching tags will be presented.
        2. You can position the cursor over the tag and press g
           Ctrl-].
        3. You can visually select a text and press g Ctrl-] to jump
           or list the matching tags.
        4. You can use the 'stjump' ex command.  This will open the
           matching or selected tag from the tag list in a new window.
        5. You can press Ctrl-W g Ctrl-] to do a :stjump.

    Help keyword(s): :tjump, g_Ctrl-], v_g_CTRL-], :stjump,
                     Ctrl-W_g_Ctrl-]

13. How do browse through a list of multiple tag matches?

    If there are multiple tag matches, you can browse through all of
    them using several of the Vim ex commands.

    1. To go to the first tag in the list, use the 'tfirst' or
       'trewind' ex command.
    2. To go to the last tag in the list, use the 'tlast' ex command.
    3. To go to the next matching tag in the list, use the 'tnext' ex
       command.
    4. To go to the previous matching tag in the list, use the
       'tprevious' or 'tNext' ex command.

    Help keyword(s): :tfirst, :trewind, :tlast, :tnext, :tprevious,
                     :tNext

14. How do I preview a tag?

    You can use the preview window to preview a tag, without leaving
    the original window.  There are several ways to preview a tag:

        1. You can use the 'ptag' ex command to open a tag in the
           preview window.
        2. You can position the cursor on a tag name and press Ctrl-W
           } to open the tag in the preview window.
        3. You can use the 'ptselect' ex command to do the equivalent
           of the 'tselect' ex command in the preview window.
        4. You can use the 'ptjump' ex command to do the equivalent of
           the 'tjump' ex command in the preview window.
        5. You can position the cursor on the tag and press Ctrl-W g}
           to do a :ptjump on the tag.

    Help keyword(s): :preview-window, :ptag, Ctrl-W_}, :ptselect,
                     :ptjump, Ctrl-W_g}

15. How do I browse through the tag list in a preview window?

    If there are multiple tag matches, you can browse through all of
    them in the preview window using several of the Vim ex commands.

    1. To go to the first tag in the list, use the 'ptfirst' or
       'ptrewind' ex command.
    2. To go to the last tag in the list, use the 'ptlast' ex command.
    3. To go to the next matching tag in the list, use the 'ptnext' ex
       command.
    4. To go to the previous matching tag in the list, use the
       'ptprevious' or 'ptNext' ex command.

    Help keyword(s): :ptfirst, :ptrewind, :ptlast, :ptnext,
                     :ptprevious, :ptNext

16. How do I start Vim to start editing a file at a given tag match?

    While starting Vim, you can use the command line option '-t' to
    supply a tag name.  Vim will directly jump to the supplied tag
    location.

    Help keyword(s): -t

17. How do I list all the tags matching a search pattern?

    There are several ways to go through a list of all tags matching a
    pattern.

        1. You can list all the tags matching a particular regular
           expression pattern by prepending the tag name with the '/'
           search character.  For example,

                :tag /<pattern>
                :stag /<pattern>
                :ptag /<pattern>
                :tselect /<pattern>
                :tjump /<pattern>
                :ptselect /<pattern>
                :ptjump /<pattern>

         2. If you have the 'wildmenu' option set, then you can press
            the <Tab> key to display a list of all the matching tags
            in the status bar.  You can use the arrow keys to move
            between the tags and then use the <Enter> key to select a
            tag.

         3. If you don't have the 'wildmenu' option set, you can still
            use the <Tab> key to browse through the list of matching
            tags.

    Help keyword(s): tag-regexp, wildmenu

18. What options are available to control how Vim handles the tags
    file?

    You can use the following options to control the handling of tags
    file by Vim:

    1. 'tagrelative' - Controls how the file names in the tags file
                       are treated.  When on, the filenames are
                       relative to the directory where the tags file
                       is present.

    2. 'taglength' -  Controls the number of significant characters
                      used for recognizing a tag.

    3. 'tagbsearch' - Controls the method used to search the tags file
                      for a tag.  If this option is on, binary search
                      is used to search the tags file.  Otherwise,
                      linear search is used.

    4. 'tagstack' - Controls how the tag stack is used.

    Help keyword(s): 'tagrelative', 'taglength', 'tagbsearch',
                     'tagstack'

19. Is it possible to highlight all the tags in the current file?

    Yes.  Read the Vim online help on "tag-highlight".

20. Is it possible to create a menu with all the tags in the current
    file?

    Yes.  It is possible to create a menu with all the tags in the
    current file using a Vim script.  Download the TagsMenu.vim script
    from the following link:

    http://members.home.net/jayglanville/tagsmenu/TagsMenu.html

21. Is there a workaround to make the Ctrl-] key not to be treated as
    the telnet escape character?

    The default escape characters for telnet in Unix systems is
    Ctrl-].  While using Vim in a telnet session, if you use Ctrl-] to
    jump to a tag, you will get the telnet prompt.  There are two ways
    to avoid this problem:


    1. Map the telnet escape character to some other character using
       the "-e <escape character>" telnet command line option

    2. Disable the telnet escape character using the "-E" telnet
       command line option.

    Help keyword(s): telnet-CTRL-]

VimTip 95: How do I pipe the output from ex commands into the text buffer?
http://vim.sourceforge.net/tip_view.php?tip_id=

This is a *request* for a tip.  I need to be able to pipe the output of a :blah ex command into the vim text buffer for editing.  I wanted to do this many times for different reasons and could never find a way!

I would just love to be able to do :hi --> textBuffer and examine the output at my own leasure scrolling up and down and using vim search commands on it.  Same thing for :set all, and other things.  Considering that cut and paste is horrible in windows, I can't for example do :set guioptions? then cut and paste!  So I have to retype it, or cut and paste from the help manual.  I really want to be able to pipe the output of ex commands into the text buffer.  Can someone help me?

VimTip 96: Cooperation of Gvim and AutoCad [MTEXT]
http://vim.sourceforge.net/tip_view.php?tip_id=

You can - like me :o)  - use gvim, like replacement of internal AutoCad MTEXT editor. You need switch variable MTEXTED to "gvim" (or maybe fullpath, something like "c:\vim\vim60aq\gvim" ), and to your _vimrc you can put line:

autocmd BufRead,BufNewFile *.tmp source c:\vim\aacad.vim

And when you edit MTEXT in acad, menu AutoCad will be for your use in gvim (only in INSERT and VISUAL mode)

[NOTE: Only I can't start gvim like gvim -y (for any other person, not so accustomed vith gvim) or start gvim from gvim.lnk or gvim.bat (I'am using windows95) and automatic skip to INSERT mode -latest word star, on end of script- is without functionality(?) Maybe someone advise me?? ]

Well, script aacad.vim is listed here:

"VIM menu for AutoCad's MTEXT editation
"brz; mailto:brz@centrum.cz;  8. 8. 2001
" Version Mk.I
"--------------------------------------------------------------------------

imenu &AutoCad.Insert.Space \~
vmenu &AutoCad.Insert.Space <Esc>`<i\~<Esc>%
imenu &AutoCad.Insert.Backslash \\
vmenu &AutoCad.Insert.Backslash <Esc>`<i\\<Esc>%
imenu &AutoCad.Insert.Brackets \{\}<Esc>F\i
vmenu &AutoCad.Insert.Brackets <Esc>`>a\}<Esc>`<i\{<Esc>%
imenu &AutoCad.Insert.Paragraph \P
vmenu &AutoCad.Insert.Paragraph <Esc>`>a\P<Esc>%

imenu &AutoCad.-SEP1- :

imenu &AutoCad.Colour.Red \C1;
vmenu &AutoCad.Colour.Red <Esc>`>a\C7;<Esc>`<i\C1;<Esc>%
imenu &AutoCad.Colour.Yellow \C2;
vmenu &AutoCad.Colour.Yellow <Esc>`>a\C7;<Esc>`<i\C2;<Esc>%
imenu &AutoCad.Colour.Green \C3;
vmenu &AutoCad.Colour.Green <Esc>`>a\C7;<Esc>`<i\C3;<Esc>%
imenu &AutoCad.Colour.Cyan \C4;
vmenu &AutoCad.Colour.Cyan <Esc>`>a\C7;<Esc>`<i\C4;<Esc>%
imenu &AutoCad.Colour.Blue \C5;
vmenu &AutoCad.Colour.Blue <Esc>`>a\C7;<Esc>`<i\C5;<Esc>%
imenu &AutoCad.Colour.Violet \C6;
vmenu &AutoCad.Colour.Violet <Esc>`>a\C7;<Esc>`<i\C6;<Esc>%
imenu &AutoCad.Colour.Black \C7;
vmenu &AutoCad.Colour.Black <Esc>`>a\C7;<Esc>`<i\C7;<Esc>%
imenu &AutoCad.Colour.D_Grey \C8;
vmenu &AutoCad.Colour.D_Grey <Esc>`>a\C7;<Esc>`<i\C8;<Esc>%
imenu &AutoCad.Colour.L_Grey \C9;
vmenu &AutoCad.Colour.L_Grey <Esc>`>a\C7;<Esc>`<i\C9;<Esc>%

imenu &AutoCad.Font.Arial \fArial;
vmenu &AutoCad.Font.Arial <Esc>`<i\fArial;<Esc>%
imenu &AutoCad.Font.Symbol \Fsymbol;
vmenu &AutoCad.Font.Symbol <Esc>`<i\Fsymbol;<Esc>%
imenu &AutoCad.Font.RomanC \Fromanc;
imenu &AutoCad.Font.RomanC <Esc>`<i\Fromanc;<Esc>%
imenu &AutoCad.Font.RomanS \Fromans;
vmenu &AutoCad.Font.RomanS <Esc>`<i\Fromans;<Esc>%
imenu &AutoCad.Font.RomanD \Fromand;
vmenu &AutoCad.Font.RomanD <Esc>`<i\Fromand;<Esc>%
imenu &AutoCad.Font.RomanT \Fromant;
vmenu &AutoCad.Font.RomanT <Esc>`<i\Fromant;<Esc>%

imenu &AutoCad.Size.0_5x \H0.5x;
vmenu &AutoCad.Size.0_5x <Esc>`<i\H0.5x;<Esc>%
imenu &AutoCad.Size.1_5x \H1.5x;
vmenu &AutoCad.Size.1_5x <Esc>`<i\H1.5x;<Esc>%
imenu &AutoCad.Size.2x \H2x;
vmenu &AutoCad.Size.2x <Esc>`<i\H2x;<Esc>%
imenu &AutoCad.Size.3x \H3x;
vmenu &AutoCad.Size.3x <Esc>`<i\H3x;<Esc>%

imenu &AutoCad.Effects.Set_Out_1_5 \T1.5;
vmenu &AutoCad.Effects.Set_Out_1_5 <Esc>`>a\T1;<Esc>`<i\T1.5;<Esc>%
imenu &AutoCad.Effects.Set_Out_2 \T2;
vmenu &AutoCad.Effects.Set_Out_2 <Esc>`>a\T1;<Esc>`<i\T2;<Esc>%

imenu &AutoCad.Effects.-SEP3- :
imenu &AutoCad.Effects.Tilt_15deg \Q15;
vmenu &AutoCad.Effects.Tilt_15deg <Esc>`>a\Q0;<Esc>`<i\Q10;<Esc>%
imenu &AutoCad.Effects.Tilt_20deg \Q20;
vmenu &AutoCad.Effects.Tilt_20deg <Esc>`>a\Q0;<Esc>`<i\Q20;<Esc>%
imenu &AutoCad.Effects.Tilt_30deg \Q30;
vmenu &AutoCad.Effects.Tilt_30deg <Esc>`>a\Q0;<Esc>`<i\Q30;<Esc>%

imenu &AutoCad.Effects.-SEP4- :
imenu &AutoCad.Effects.Change_Width_0_5x \W0.5;
vmenu &AutoCad.Effects.Change_Width_0_5x <Esc>`>a\W1;<Esc>`<i\W0.5;<Esc>%
imenu &AutoCad.Effects.Change_Width_2x \W2;
vmenu &AutoCad.Effects.Change_Width_2x <Esc>`>a\W1;<Esc>`<i\W2;<Esc>%

imenu &AutoCad.Effects.-SEP5- :
imenu &AutoCad.Effects.Justify_Down \A0;
vmenu &AutoCad.Effects.Justify_Down <Esc>`<i\A0;<Esc>%
imenu &AutoCad.Effects.Justify_Middle \A1;
vmenu &AutoCad.Effects.Justify_Middle <Esc>`<i\A1;<Esc>%
imenu &AutoCad.Effects.Justify_Up \A2;
vmenu &AutoCad.Effects.Justify_Up <Esc>`<i\A2;<Esc>%
imenu &AutoCad.Effects.Overlined_Characters \O\o<Esc>F\i
vmenu &AutoCad.Effects.Overlined_Characters <Esc>`>a\O<Esc>`<i\o<Esc>%
imenu &AutoCad.Effects.Underlined_Characters \L\l<Esc>F\i
vmenu &AutoCad.Effects.Underlined_Characters <Esc>`>a\l<Esc>`<i\L<Esc>%
imenu &AutoCad.Effects.Index_Top \S^;

imenu &AutoCad.-SEP6- :
imenu &AutoCad.Help <CR><CR>***Quit Editor: press Alt-F4 and 'No' ***<CR><CR>

star

VimTip 97: How do I add a current time string inside Vim?
http://vim.sourceforge.net/tip_view.php?tip_id=

This is a *request* for a tip.
Sometimes (eg. editing HTML pages) I need to add a timestamp string to my editing buffer.
On UNIX systems, I can use
  :r!date
to get a localized date time string; but on Windows ('date' on Windows will query the user to input new date)
or other platforms which does not have 'date' command, how do I get a timestamp easily?

VimTip 98: Getting vim help from mailing lists and newsgroups.
http://vim.sourceforge.net/tip_view.php?tip_id=

There have been a few "requests for tips" entered into the tips database lately.  If you have specific questions that aren't answered by the existing tips, there are a couple of resources that may be more appropriate:

The mailing list vim@vim.org is for vim users.  If you send an email to vim-help@vim.org, you'll get a message back telling you how to subscribe, as well as how to request old messages and contact the list maintainer.  This mailing list is also archived at http://groups.yahoo.com/group/vim.

The newsgroup comp.editors discusses many different editors, but most of the traffic is about vim.  When posting, it is appreciated if you include "vim" in the subject line.  The comp.editors newsgroup is archived at http://groups.google.com/groups?hl=en&safe=off&group=comp.editors.

Using the tips database for asking questions is not likely to work well.  For example, if you ask a question titled "Searching for strings in a file" and I read this site and see that tip, I'm not going to read it if I already know how to search for strings in a file.  In comp.editors and vim@vim.org, people expect to find questions from others and are therefore more likely to see your questions.

After finding the answer to your question, please consider whether it would make an appropriate tip, and if so, add it to the tips database.

VimTip 99: How to tell what syntax highlighting group *that* is!
http://vim.sourceforge.net/tip_view.php?tip_id=

Here's a (what should be a one-line) map to help you tell just what
syntax highlighting groups the item under the cursor actually is:

map  <F10>  :echo "hi<" . synIDattr(synID(line("."),col("."),1),"name") . '> trans<' . synIDattr(synID(line("."),col("."),0),"name") . "> lo<" . synIDattr(synIDtrans(synID(line("."),col("."),1)),"name") . ">"<CR>

Once known you can override the current highlighting with whatever you want.
If you're debugging a syntax highlighting file (a rare occupation), sometimes
you'll wish to know the entire chain of syntax highlighting.  For that,
check out

http://www.erols.com/astronaut/vim/vimscript/hilinks.vim

VimTip 100: Jump to tag (e.g. help topic) with German keyboard (PC)
http://vim.sourceforge.net/tip_view.php?tip_id=

You're a newbie in vim and need some ":help"? Well, help.txt reads:

"Jump to a subject:  Position the cursor on a tag between |bars| and hit CTRL-]."

Unfortunately there is no "]" key on German keyboards. On Win32 try CTRL-+ (Strg-+), on Linux console I use CTRL-AltGr-9 (Strg-AltGr-9).

Kind regards

VimTip 101: Change automatically to the directory the file in the current buffer is in
http://vim.sourceforge.net/tip_view.php?tip_id=

To change automatically to the directory the file in the current buffer is in
add a line (below)  to the file .vimrc .
The file .vimrc should have the following if-statement to control the autocmd feature:

  if has("autocmd")


    < ... lot of autocmd stuff ... >


    " Change to the directory the file in your current buffer is in
    autocmd BufEnter * :cd %:p:h


  endif " has("autocmd")

Add the line above the endif and restart vim/gvim.

VimTip 102: smart mapping for tab completion
http://vim.sourceforge.net/tip_view.php?tip_id=

I'm used to complete words with <tab>, however when editing source I can't just map that to vim keyword completion because I sometime need to insert real tabs,
since it mostly happen when at the beginning of the line or after a ; and before a one line comma (java, c++ or perl anyone...) I've come to find the following really usefull
This is how you can map the <tab> key in insert mode while still being able to use it when at the start of a line or when the preceding char is not a keyword character.
in a script file in a plugin directory or in your .vimrc file:
first define a function which returns a <tab> or a <C-N> depending on the context:

function InsertTabWrapper()
      let col = col('.') - 1
      if !col || getline('.')[col - 1] !~ '\k'
          return "\<tab>"
      else
          return "\<c-p>"
      endif
endfunction

then define the appropriate mapping:
inoremap <tab> <c-r>=InsertTabWrapper()<cr>

the trick here is the use of the <c-r>= in insert mode to be able to call your function without leaving insert mode.
:help i_CTRL-R
Benoit

VimTip 103: Move to next/previous line with same indentation
http://vim.sourceforge.net/tip_view.php?tip_id=

When working with Python and other languages which don't use braces, it's useful to be able to jump to and from lines which have the same indentation as the line you are currently on.

nn <M-,> k:call search ("^". matchstr (getline (line (".")+ 1), '\(\s*\)') ."\\S", 'b')<CR>^
nn <M-.> :call search ("^". matchstr (getline (line (".")), '\(\s*\)') ."\\S")<CR>^

will map Alt-< and Alt-> in Normal mode to upward and downward searching for lines with the same indent as the current line.

VimTip 104: using vim to complement Perl's DBI::Shell
http://vim.sourceforge.net/tip_view.php?tip_id=

DBI::Shell is a Perl module that is used as a shell interface to Perl's popular DBI (database interface) package. Forget your favorite SQL navigation gui and give this method a shot. This has only been tested in UNIX.

1. run dbish (runs DBI::Shell; installed with DBI::Shell) and connect to any database
2. in dbish, set /format box
3. enter your query
4. to execute query, type "/ | vim -"

This runs the query and pipes the output to the standard input of vim. Here are some follow-up tips:
-use gvim instead of vim so a new window will pop up
-set nowrap once in vim
-make a syntax highlighting file for me!

-Adam Monsen

VimTip 105: combining move and scroll
http://vim.sourceforge.net/tip_view.php?tip_id=

I sometimes found myself moving down a few lines with j, then scrolling down
about the same number of lines with <C-E> to put the cursor in roughly the
same place as it started.  I decided I wanted to map <C-J> (and <C-K>,
respectively) to the move-and-scroll operation.  First, I did

    :map <C-J> <C-E>j

This was pretty good, but behaved funny at the beginning and end of files.
Then, I realized that <C-D> already combined move and scroll, so I figured
that giving <C-D> a count of 1 would do it:

    :map <C-J> 1<C-D>

Unfortunately, this permanently attaches a count to <C-D> (ugh!), so I have
to undo that:

    :map <C-J> 1<C-D>:set scroll=0<CR>

This has the drawback of not necessarily resetting scroll to its original
value, but since I never change scroll, it's good enough for me.  It would
be nice if there were a version of <C-D> that did not have the side-affect
of changing scroll.

Happy vimming,
Andrew

VimTip 106: Mail signature rotation: Supersimple one-line solution
http://vim.sourceforge.net/tip_view.php?tip_id=

Hallo,
next solution for _most_simple_ signature rotater:
You can only put one line to your .vimrc || _vimrc:
map <Leader>ms :e c:\sign.txt<CR>ggV/--<CR>k"*xG$a<C-R><C-O>*<Esc>:w<CR>:bd<CR>G$a<C-M><Esc>"*P

Must exist file (from eg above) c:\sign.txt, with content:
--
first signature
--
second signature
--
third signature
--

When You finished mail, only call shortcut \ms and 'first signature' will be insert in your mail. In c:\sign.txt will be first signature pushed to the end of this file. When You want use other signature, only press 'u' and \ms again
(Or You can change \ms to e.g. <F12>, indeed. ) You can change this and append one part like 'basic' from command and append 'changing' part from .signature file, as you like...
Ok, one unpleasant thing is here: your signature must not contain '--' (signature separator)...
Anyhow, I find it useful
brz* <brz@centrum.cz>
http://brz.d2.cz/

VimTip 107: C/C++: convert enum to string table
http://vim.sourceforge.net/tip_view.php?tip_id=

When testing your own C/C++ programs you sometimes wish to have a trace output,
which shows you, which enum value is used.
You can do this by creating a string table for that enum type,
which contains the enum identifyer as a string.
e.g.
printf ("%s", MyEnumStringTable [ MyEnumVal] );

You can create the complete string table by
- marking the lines containing the complete typedef enum
- select menu C/C++.transform enum2Stringtab

You can create string table entries by
- marking the lines within the typedef enum
- select menu C/C++.transform enum2String

This makes it easy to keep the enum (on changes) consistent to the string table.

Add the following lines to your _GVIMRC file:
31amenu C/C++.transform\ enum2Stringtab 	:s#[ 	]*\\(\\w\\+\\)#/* \\1	*/	"\\1"#<CR>o};<ESC>uOstatic const char* const Names[] = {<ESC><CR>/sdfsdf<CR>
31vmenu C/C++.transform\ enum2Stringtab 	:s#[ 	]*\\(\\w\\+\\)#/* \\1	*/	"\\1"#<CR>o};<ESC>uOstatic const char* const Names[] = {<ESC><CR>/sdfsdf<CR>

31amenu C/C++.transform\ enum2String 	:s#[ 	]*\\(\\w\\+\\)#/* \\1	*/	"\\1"#<CR>o}<ESC>/sdfsdf<CR>
31vmenu C/C++.transform\ enum2String 	:s#[ 	]*\\(\\w\\+\\)#/* \\1	*/	"\\1"#<CR>o}<ESC>/sdfsdf<CR>

hint: '/sdfsdf' is added for deactivating search highlighting,
ok, you'll sure find a better way to do this.

VimTip 108: Toggle a fold with a single keystroke
http://vim.sourceforge.net/tip_view.php?tip_id=

When viewing/editing a folded file, it is often needed to inspect/close some fold.
To speed up these operation use the following (put in your $HOME/.vimrc):

" Toggle fold state between closed and opened.
"
" If there is no fold at current line, just moves forward.
" If it is present, reverse it's state.
fun! ToggleFold()
	if foldlevel('.') == 0
		normal! l
	else
		if foldclosed('.') < 0
			. foldclose
		else
			. foldopen
		endif
	endif
	" Clear status line
	echo
endfun

" Map this function to Space key.
noremap <space> :call ToggleFold()<CR>

See :help folding for more information about folding.

VimTip 109: jump between files
http://vim.sourceforge.net/tip_view.php?tip_id=

Often I know I'm likely to edit many files. I run 'vim *.pl' and get a whole bunch of open files.

To make jumping between files to a pleasure, I defined to mapss:

map <f1> :previous<cr>
map <f2> :next<cr>

Press F1 to go back and F2 to go forward.

--
Kirill

VimTip 110: text->html table converter.
http://vim.sourceforge.net/tip_view.php?tip_id=

Below are two functions and a mapping which will convert lines of plain text into
HTML table code.
For example, you have several lines like:
-----------------------------------------------
1
2
3

4
5
6
---------------------------------------------------
by visualizing all the 7 lines and press <F5>, you can change the text into
<table><tr>
   <td>1</td>
   <td>2</td>
   <td>3</td>
</tr><tr>
   <td>4</td>
   <td>5</td>
   <td>6</td>
</tr></table>
which will eventually render into a table.
So the rule is:
Every line is a table item, every empty line means starting of a new table row.

"A text->html table code converter
"By: Wenzhi Liang wzhliang@yahoo.com
"You can distribute/change this file freely as long as you keep the title area. Thanks

func Table()
	let end=line("'>")
	let start=line("'<")
	let i=start

	wh i <= end
		exe ":" . i
		let e=Empty()
		if e == 1
			exe "normal I</tr><tr>"
		else
			exe "normal I<td>A</td>>>"
		endif
		let i=i+1
	endwh

	exe "normal o</tr></table><<"
	exe ":" . start
	exe "normal O<table><tr><<"
endfunc

vmap <F5> <ESC>:call Table()<CR>

func Empty()
	let line_nr= line (".")
	let a=getline ( line_nr )
	let m=match(a, "\\S")
	if m == -1
		return 1
	else
		return 0
	endif
endfunc

VimTip 111: Printing with syntax highlighting independent of your normal highlighting
http://vim.sourceforge.net/tip_view.php?tip_id=

I have found it undesirable to use :hardcopy directly because it uses the current syntax highlighting to determine how to print the text.  For example, I like to print comments in italics, but I don't like italic fonts on the screen. This tip will show you how to set up a colorscheme for printing and use it only when you print.

I copied an existing colorscheme to ~/.vim/colors/print.vim, and changed all the lines like this:

  highlight Normal ctermbg=DarkGrey ctermfg=White guifg=White guibg=grey20
to this:
  highlight clear Normal

Then I set the syntax groups how I wanted them to be printed on the printer:

  highlight Comment        term=italic    cterm=italic    gui=italic
  highlight Constant       term=bold      cterm=bold      gui=bold
  etc....

I then defined the following command in my .vimrc file:

command! -nargs=* Hardcopy call DoMyPrint("<args>")

And, finally, I defined this function in my .vimrc:

function DoMyPrint(args)
    let colorsave=g:colors_name
    color print
    exec "hardcopy ".a:args
    exec 'color '.colorsave
endfunction

After this is complete, you can do:
   :Hardcopy > /tmp/out.ps
or just
   :Hardcopy
(Note the capital H)

VimTip 112: Back and forth between indented lines again
http://vim.sourceforge.net/tip_view.php?tip_id=

Paul Wright posted a tip which explained how to jump back and forth between lines with the same indentation level. I do this a lot, so I came up with this slightly more comprehensive solution.

The example mappings below work as follows:

[l and ]l jump to the previous or the next line with the same indentation level as the one you're currently on.

[L and ]L jump to the previous or the next line with an indentation level lower than the line you're currently on.

These movements also work in visual mode and (only as of one of the 6.0 alpha versions) in operator pending mode, meaning that you can do a d]l. The motion is specified as being exclusive when in operator pending mode.

When might you use this? If you're writing programs in Python, Haskell, or editing XML files, they will be very useful. E.g. in XML you can jump to the outer enclosing tag, or the next matching tag. I use it for practically anything I edit, so it's not limited to this.

"
" NextIndent()
"
" Jump to the next or previous line that has the same level or a lower
" level of indentation than the current line.
"
" exclusive (bool):   true:  Motion is exclusive
"                     false: Motion is inclusive
" fwd (bool):         true:  Go to next line
"                     false: Go to previous line
" lowerlevel (bool):  true:  Go to line with lower indentation level
"                     false: Go to line with the same indentation level
" skipblanks (bool):  true:  Skip blank lines
"                     false: Don't skip blank lines

function! NextIndent(exclusive, fwd, lowerlevel, skipblanks)
	let line = line('.')
	let column = col('.')
	let lastline = line('$')
	let indent = indent(line)
	let stepvalue = a:fwd ? 1 : -1

	while (line > 0 && line <= lastline)
		let line = line + stepvalue
		if (	! a:lowerlevel && indent(line) == indent ||
				\ a:lowerlevel && indent(line) < indent)
			if (! a:skipblanks || strlen(getline(line)) > 0)
				if (a:exclusive)
					let line = line - stepvalue
				endif
				exe line
				exe "normal " column . "|"
				return
			endif
		endif
	endwhile
endfunc

" Moving back and forth between lines of same or lower indentation.
nnoremap <silent> [l :call NextIndent(0, 0, 0, 1)<cr>
nnoremap <silent> ]l :call NextIndent(0, 1, 0, 1)<cr>
nnoremap <silent> [L :call NextIndent(0, 0, 1, 1)<cr>
nnoremap <silent> ]L :call NextIndent(0, 1, 1, 1)<cr>
vnoremap <silent> [l <esc>:call NextIndent(0, 0, 0, 1)<cr>m'gv''
vnoremap <silent> ]l <esc>:call NextIndent(0, 1, 0, 1)<cr>m'gv''
vnoremap <silent> [L <esc>:call NextIndent(0, 0, 1, 1)<cr>m'gv''
vnoremap <silent> ]L <esc>:call NextIndent(0, 1, 1, 1)<cr>m'gv''
onoremap <silent> [l :call NextIndent(0, 0, 0, 1)<cr>
onoremap <silent> ]l :call NextIndent(0, 1, 0, 1)<cr>
onoremap <silent> [L :call NextIndent(1, 0, 1, 1)<cr>
onoremap <silent> ]L :call NextIndent(1, 1, 1, 1)<cr>

VimTip 113: Translator in vim (Windows solution)
http://vim.sourceforge.net/tip_view.php?tip_id=

Hallo, today I found script "translate.vim", but on Windows this will be probably difficult to run it (maybe with Cygwin is it possible). I've simpler solution of keymap for vim interlacing to dictionary:
Must exist file with vocabulary (e.g. "an-cs.txt"), which is called for word under cursor. In 'normal' is only displayed window with translations, in 'insert' is word under cursor deleted and is insert selected form of word from translantion window (select it by mouse and than press right button: It works fine on W2k). Key _F12_ is looking for "word", shifted _S-F12_ is looking for "pattern".
For windows is needed agrep, which is localy placed on http://www.tgries.de/agrep/index.html

map <F12> b"*yw<Esc>:! c:/bin/agrep -wih <C-R>* "c:/dict/an-cs.txt"<CR>
imap <F12> <Esc>b"*yw<Esc>:! c:/bin/agrep -wih <C-R>* "c:/dict/an-cs.txt"<CR>dwi <C-R>*
map <S-F12> b"*yw<Esc>:! c:/bin/agrep -ih <C-R>* "c:/dict/an-cs.txt"<CR>
imap <S-F12> <Esc>b"*yw<Esc>:! c:/bin/agrep -ih <C-R>* "c:/dict/an-cs.txt"<CR>dwi <C-R>*


brz* <brz@centrum.cz>

VimTip 114: Browsing by  paragraph
http://vim.sourceforge.net/tip_view.php?tip_id=

It can be done by reaching the blank lines in up and down directions just by pressing

{    ----  For going to the blank line above the paragraph
}    ----  For going to the blank line below the paragraph

VimTip 115: Browsing by  paragraph
http://vim.sourceforge.net/tip_view.php?tip_id=

It can be done by reaching the blank lines in up and down directions just by pressing

{    ----  For going to the blank line above the paragraph
}    ----  For going to the blank line below the paragraph

VimTip 116: Search all occurances of the word under cursor in all the open files
http://vim.sourceforge.net/tip_view.php?tip_id=

Sometimes it is useful to know all the occurances of the word under cursor in all the open files. This can be done by pressing [I ( bracket and capital I ) . it shows the results found in the command window.

VimTip 117: FAST SEARCH ACROSS THE PROJECT
http://vim.sourceforge.net/tip_view.php?tip_id=

Searching for a word across the project wastes most of the developres time, which can be avoided by the use of GNU Id_utils with VIM.
The procedure needs to be followed is as follows:
download GNU idutils 3.2d (mkid,lid,fid,fnid,xtokid)
from http://www.mossbayeng.com/~ron/vim/builds.html

uncompress and store these files in the directory from where vim is running.

goto the top level directory of the project, and run mkid, it will create ID file in that directory (As it is time consuming process, so be patient). copy this file ID to the directory from where vim is running.

USAGE:

Put these lines in your .vimrc:

	map _u :call ID_search()<Bar>execute "/\\<" . g:word . "\\>"<CR>
	map _n :n<Bar>execute "/\\<" . g:word . "\\>"<CR>

	function ID_search()
	  let g:word = expand("<cword>")
	  let x = system("lid --key=none ". g:word)
	  let x = substitute(x, "\n", " ", "g")
	  execute "next " . x
	endfun

To use it, place the cursor on a word, type "_u" and vim will load the file
that contains the word.  Search for the next ocurance of the word in the same
file with "n".  Go to the next file with "_n".

The mapping of "_u" and "_n" can be done to some other key as per your preference but I use ^K and ^L for this purpose.

VimTip 118: Configuring gVim as Internet Explorer 'View Source' editor
http://vim.sourceforge.net/tip_view.php?tip_id=

Within the registry, you can specify the source editor to be used by Internet Explorer when {View|Source} is selected. Unfortunately, you can't specify a quoted filename argument here, i.e. "%1". The editor specified is supposed to handle filenames which contain spaces. This will cause problems for Vim because Vim treats each space as an argument separator. If an unquoted filename contains spaces, Vim treats the filename as multiple arguments and will open multiple files instead of one. To workaround this problem a quoted filename has to be passed to Vim. This can be done by creating the following Visual Basic Script file gVim.vbs:

'--- gVim.vbs -----------------------------------------------------------------
'function: Start gvim, combining multiple arguments to single file argument.
'changes:  20010905: Quoted 'oWShell.Run' filename argument, allowing spaces.
'          20010518: Created.
'author:   Freddy Vulto <fvu@fvu.myweb.nl>

  ' Making variable declaration mandatory
option explicit

dim oWShell, sArg, sFile

  ' Create script object
set oWShell = CreateObject("wscript.shell")
  ' Loop through arguments
for each sArg in wscript.arguments
    ' Add argument to filename
  sFile = sFile & sArg & " "
next
  ' Remove excess space
sFile = Trim(sFile)
  ' Run Vim with file argument.  Additional arguments:
  ' -R: View file readonly
  ' -c "set syntax=html": Use HTML syntax-highlighting
  '    NOTE: Use "-c ""set ft=html""" to make it work for Vim v6.
oWShell.Run _
  """D:\Programs\Vim\Vim58\gvim.exe """ & _
  "-R """ & sFile & """ " & _
  "-c ""set syntax=html"""

  ' Destroy script object
set oWShell = NOTHING

The source editor now can be specified by adding the following key to the registry:

HKEY_LOCAL_MACHINE
|- Software
   |- Microsoft
      |- Internet Explorer
         |- View Source Editor
            |- Editor Name       (Default) = D:\Programs\Vim\gvim.vbs

Freddy Vulto <fvu@fvu.myweb.nl>
http://fvu.myweb.nl/Projects/Vim/Web/vim.htm

VimTip 119: Explorer startup and shutdown
http://vim.sourceforge.net/tip_view.php?tip_id=

I really like the new explorer window, but I wanted it to function a little more seemlessly in the editor.  The following code does two things.  First, the explorer is started when vim is started.   I also noticed and fixed that the explorers size is not equal to the window size, hence the strange behavior when popping between two windows.  The other major function of the code is to close the explorer when it's the only window that's left.  I'd actually like to take this a step further and close the window if the last _document_ window is closed.  I'd prefer that multiple explorers or help windows don't keep the application running - only having a file open keeps the application running.  But I didn't see an easy way to do this... anyone else?

BTW, thank you Bram for the help figuring this out.

Code (which currently lives in my _vimrc):

" FILE BROWSER STARTUP
func OpenFileWindow()
	" :runtime plugin/*.vim		" this would be useful if you were calling this
				"   function from the .vimrc directly
	let g:explDetailedList=1	" show size and date by default
	let g:explVertical=1		" Split vertically
	let g:explStartRight=0    	" Put new explorer window to the left of the current window
	:Sexplore
	set nonu
	set winwidth=15		" Make the width of the window match the explorer setting
	"let g:explVertical=0		" Split vertically
	doautocmd fileExplorer BufEnter " Forces the directory refresh to occur
	:winc l			" change to the document window
endfunc


func CloseIfLast()
	if exists("b:completePath")	" this is how I determine that I'm in an explorer window
		let n = winnr()
		wincmd p
		if n == winnr()
			quit	" quit the window
		endif
		wincmd p
	endif
endfunc

if has("autocmd")
	if !exists("rudyautocommands")
		let rudyautocommands = 1
		autocmd VimEnter * call OpenFileWindow()
		autocmd WinEnter * call CloseIfLast()

	endif
endif

VimTip 120: Compiling Java with Sun JDK (javac) within VIM
http://vim.sourceforge.net/tip_view.php?tip_id=

The $VIMRUNTIME/compiler has 'jikes.vim', but there's nothing for traditional Sun JDK(javac),
so I tried (Only tested on Win 2000):

" Vim Compiler File    javac.vim
" Compiler:	Sun/IBM JDK: Javac

if exists("current_compiler")
  finish
endif
let current_compiler = "javac"

" Javac defaults to printing output on stderr and no options can convert, so we have to set 'shellpipe'
setlocal shellpipe=2>
" 2> works on Win NT and UNIX
setlocal makeprg=javac\ #<.java
setlocal errorformat=%f:%l:%m
" Sorry I'm not familiar with 'errorformat', so I set it very simple.

VimTip 121: Using vim as a syntax-highlighting pager
http://vim.sourceforge.net/tip_view.php?tip_id=

If you want to use Vim's syntax highlighting in a "more"-style pager, here's
one way to set it up:

First, create a vimrc like the following -- I called mine ~/.vimrc.more

---8<---cut here---8<---
" No compatibility -- necessary for mappings to work.
set nocompatible

" Status line
set laststatus=0
set cmdheight=1
set nomodifiable	" Only in version 6.0
set readonly

" Syntax colouring -- lines taken from syntax.txt discussion on colour xterms.
" See ':help color-xterm'. Use appropriate lines for your own set-up.
if has("terminfo")
    set t_Co=16
    set t_Sf=[3%p1%dm
    set t_Sb=[4%p1%dm
else
    set t_Co=16
    set t_Sf=[3%dm
    set t_Sb=[4%dm
endif
" My xterms have a navy-blue background, so I need this line too.
set background=dark
" Turn syntax on
syntax on

" Key bindings.
nmap b <C-B><C-G>
nmap q :q<CR>
" To type the following line, type *two* C-V's followed by two spaces. This
" is how you map the spacebar.
nmap ^V  <C-F><C-G>
---8<---cut here---8<---

Then, to use this .vimrc, add an alias. If you're using tcsh, the syntax will
be something like:

alias vmore "vim -u ~/.vimrc.more"

Then you can type "vmore [filename]" to view a file in this "pager". Spacebar
will move down, 'b' will move back up, and 'q' quits. You can add mappings for
other keys if you want to, also.

VimTip 122: Skip blank lines when folding text.
http://vim.sourceforge.net/tip_view.php?tip_id=

I love the text folding capabilities of vim.  I didn't like that it would display the first line of the range as the "title" for the fold.  I like to write my comments with the "/*" on a line by itself.  So I wrote this little function that will skip over anything that isn't a character, and then display whatever it finds after that character.

Just include this in your ~/.vimrc (or ~/.gvimrc):

function GetFirstLineWithChars()
	let line_num = 0
	let charline = matchstr(getline(v:foldstart), '[a-zA-Z][a-zA-Z ]*')
	while strlen(charline) == 0
		let line_num = line_num + 1
		let charline = matchstr(getline(v:foldstart + line_num), '[a-zA-Z][a-zA-Z ]*')
	endw
	return charline
endfunction
set foldtext='+'.v:folddashes.substitute(GetFirstLineWithChars(),'\\\/\\\/\\\|\\*\\\|\\*\\\|{{{\\d\\=','','g')
set fillchars=fold: 
hi folded guibg=black guifg=yellow gui=bold

And as an added bonus, for those new to text folding, add this to your .vimrc file too:

autocmd BufWinLeave *.* mkview
autocmd BufWinEnter *.* silent loadview

That way whatever folds you set won't get lost when you quit.  I had that happen after spending 15 minutes folding up a 3000+ line file.  Happy vimming!

VimTip 123: use functionality similar to the * search on multiple files
http://vim.sourceforge.net/tip_view.php?tip_id=

The use of star as in vimtip#1 and vimtip#5 is great, here is how to use this type of search accross a
whole directory:
Just add the mappings (or choose different letter combinations):
map gr :grep <cword> *<cr>
map gr :grep <cword> %:p:h/*<cr>
map gR :grep \b<cword>\b *<cr>
map GR :grep \b<cword>\b %:p:h/*<cr>

mapping one will search for the word under the cursor (like g*) in any of the files in the current directory
mapping two will search for the word under the cursor (like g*) in any of the files in the same directory as the current file
mapping three will search for the word under the cursor by itself (i.e. surrounded by word boundary like *) in any of the files in the current directory
mapping four will search for the word under the cursor by itself (i.e. surrounded by word boundary like *) in any of the files in the same directory as the current file

Benoit

VimTip 124: Number a group of lines
http://vim.sourceforge.net/tip_view.php?tip_id=

Below is a way to number a set of lines.  Here is an exaple before and after snapshot:

apple
bob
pear
tree

1 apple
2 bob
3 pear
4 tree

" Description:
" This provides a command and a function.  They both can be called with or
" without a range.  In addition, they can be called with or without
" arguments.  Without a range they operate on the current line.
"
" There are two supported arguments.  They are described below:
"     arg1 -> the number to start at.  The default is one.  This will
"             number your selected lines sequentially.  The start can be a
"             number, ., $, or, 'x (like getline).
"     arg2 -> Text to append after numbers.  The default is a space.
"
" Examples:
"     To provide your functionality:
"         :%Nlist 20
"         :%call Nlist(20)
"     To make a list start at 1:
"         :'<,'>Nlist
"         :'<,'>call Nlist()
"     To number the whole buffer (with it's actual line number):
"         :%Nlist
"         :%call Nlist()
"     To number a subset of lines with their line number (and put a '] ' in
"     front of every number):
"         :'<,'>Nlist . ]\
"         :'<,'>call Nlist(".", "] ")

command! -nargs=* -range Nlist <line1>,<line2>call Nlist(<f-args>)
function! Nlist(...) range
    if 2 == a:0
        let start = a:1
        let append = a:2
    elseif 1 == a:0
        let start = a:1
        let append = " "
    else
        let start = 1
        let append = " "
    endif

    " try to work like getline (i.e. allow the user to pass in . $ or 'x)
    if 0 == (start + 0)
        let start = line(start)
    endif

    exe a:firstline . "," . a:lastline . 's/^/\=line(".")-a:firstline+start.append/'
endfunction

VimTip 125: Auto commenting for "}"
http://vim.sourceforge.net/tip_view.php?tip_id=

I always wanted a script that would auto-comment the end of a conditional block.  So, I wrote one.  This function searches for the previous matching "{", grabs the line, and inserts it as a comment after the "}".  If there is no previous matching "{", it inserts nothing.

So...

    if (test){

will generate:
    } // if (test)

This is obviously not work if you use a different style.  If you use

   if (test)
   {

then substituting 'getline(".")', use  'getline(line(".") - 1)' should work.

Put the following in your .vimrc:
au BufNewFile,BufRead *.c,*.cc,*.C,*.h imap } <ESC>:call CurlyBracket()<CR>a


function CurlyBracket()
  let l:my_linenum = line(".")
  iunmap }
  sil exe "normal i}"
  imap } <ESC>:call CurlyBracket()<CR>
  let l:result1 =  searchpair('{', '', '}', 'bW')
  if (result1 > 0)
    let l:my_string = substitute(getline("."), '^\s*\(.*\){', '\1', "")
    sil exe ":" . l:my_linenum
    sil exe "normal a //" . l:my_string
  endif
endfunction

VimTip 126: how do I get rid of that bold stuff with my xterm?
http://vim.sourceforge.net/tip_view.php?tip_id=

Having problems setting up your syntax highlighting because
everything is coming up in bold?

You're probably using an 8 color xterm and setting up highlighting
lines such as  hi Normal ... ctermfg=green .  The solution: use
numbers! 0=black, 1=red, 2=green, 3=yellow, 4=blue, 5=magenta,
6=cyan, and 7=white.  Vim tries to use "bright" colors when its
given names (because Windoz machines prefer to use dim text unless
its been made bold).

Read more about it under :help highlight-ctermfg .

VimTip 127: Preview HTML files quickly
http://vim.sourceforge.net/tip_view.php?tip_id=

I've found while writing HTML files that it can become cumbersome when I have to switch to a web browser, load my page, and move back to VIM regularly to preview what I've written.  I've come up with the following tricks.

The first one requires that you have lynx (the text-based browser) installed on your computer (available from http://lynx.isc.org/release/).  If your HTML page is primarily text, with few (if any) images, you can set up the following function and mapping:

   function PreviewHTML_TextOnly()
      let l:fname = expand("%:p" )
      new
      set buftype=nofile nonumber
      exe "%!lynx " . l:fname . " -dump -nolist -underscore -width " . winwidth( 0 )
   endfunction

   map <Leader>pt  :call PreviewHTML_TextOnly()<CR>

This will open a new window and display your formatted HTML document in that window.  Note that bold-face, italics, links, etc. will be lost -- all you will see is the text -- but the "-underscore" parameter to Lynx causes any text that would have been bold, italicized, or underlined to be displayed like _this_.

The other trick requires that vim be running on your current machine, and that you be running a GUI of some sort (X-Windows, Windows, etc.).  You can cause vim to invoke your favorite browser and have it display the file, like this:
   function PreviewHTML_External()
      exe "silent !mozilla -remote \"openurl(file://" . expand( "%:p" ) . ")\""
   endfunction

   map <Leader>pp :call PreviewHTML_External()<CR>
If you don't use mozilla, you will need to modify the function to use your preferred browser.

Happy vimming!

VimTip 128: grep, diff, patch, idutils, etc. for Windows systems
http://vim.sourceforge.net/tip_view.php?tip_id=

     If you use Vim on Windows, and you wish you had some of those nifty UNIX command-line tools,
but do not feel like installing all of Cygwin, you can get many of the most-used tools from Ron Aaron's
web site:
http://www.mossbayeng.com/~ron/vim/builds.html
Since Ron is a big Vim fan (see http://www.mossbayeng.com/~ron/vim/vimrant.html ) you can count on
these tools' working well with Vim.  For some hints on how to use them, read
:help :grep
:help lid
inside Vim.
     Happy Vimming!

VimTip 129: Removing automatic comment leaders
http://vim.sourceforge.net/tip_view.php?tip_id=

     If you include the "r" flag in the 'formatoptions' option (:help 'fo' , :help fo-table ) then the comment leader is inserted
automatically when you start a new line in a comment.  For example, in TeX the "%" character is the comment leader,
and you might type

% This is a tex file.
% The comment leaders on all lines but the first were generated automatically.
% This is the last line of the comment, but Vim will insert the comment leader on the next line.
%

You can get rid of the comment leader (along with anything you may already have typed on the line) without affecting
the indent, if any, by typing "<C-U>" while in Insert mode.

     Related point:  if you want to adjust the indent while in Insert mode, you can use "<C-D>" (to Decrease the indent)
or "<C-T>" (to increase it).  In the docs for Vim 6.0, this is described in the users' manual, :help 30.4 .

VimTip 130: disabling default ftplugins
http://vim.sourceforge.net/tip_view.php?tip_id=

     For an overview of ftplugins (filetype plugins) see

:help ftplugins

If you want to disable all ftplugins, or disable a particular default ftplugin, see

:help :filetype
:help ftplugin-overrule

If you have your own ftplugins, and you want to disable all the default ones, then
do NOT include a check for b:did_ftplugin in your ftplugin files, and add the line

:autocmd BufEnter * let b:did_ftplugin = 1

to your VIMRC file, BEFORE the ":filetype ftplugin on" line.

VimTip 131: Scroll alternate window
http://vim.sourceforge.net/tip_view.php?tip_id=

This mapping allow you to quickly scroll inactive window when displaying several windows concurrently.

nmap <silent> <M-Down> :call ScrollOtherWindow("down")<CR>
nmap <silent> <M-Up> :call ScrollOtherWindow("up")<CR>

fun! ScrollOtherWindow(dir)
	if a:dir == "down"
		let move = "\<C-E>"
	elseif a:dir == "up"
		let move = "\<C-Y>"
	endif
	exec "normal \<C-W>p" . move . "\<C-W>p"
endfun

PS: Original idea and discussion of this tip appeared on vim@vim.org mailing list, I'm just prettified it a little.

VimTip 132: window zooming convenience
http://vim.sourceforge.net/tip_view.php?tip_id=

i frequently have multiple windows open in vim -- this reduces the number of lines each window displays -- i almost always have my windows either all the same size or the current one as big as possible.

the following function can be toggled on or off by typing <Leader>max (i can do this quite quickly); just change the mapping at the bottom to something else if you prefer.

this causes the current window to be as big as possible (moving into another window causes that one to become big) and all the others get very small.  i actually use this ALL the time.  turning it off (by typing the hotkey sequence again) will cause all windows to have the same height.

"toggles whether or not the current window is automatically zoomed
function! ToggleMaxWins ()
  if exists ('g:windowMax')
    au! maxCurrWin
    exe "normal \<c-w>="
    unlet g:windowMax
  else
    augroup maxCurrWin
    " au BufEnter * exe "normal \<c-w>_\<c-w>\<bar>"
    "
    " only max it vertically
    au! BufEnter * exe "normal \<c-w>_"
    augroup END
    do maxCurrWin BufEnter
    let g:windowMax=1
  endif
endfunction
map <Leader>max :call ToggleMaxWins ()<CR>

VimTip 133: Windo and Bufdo
http://vim.sourceforge.net/tip_view.php?tip_id=

i like bufdo and windo but i don't like the fact that the commands end in a different window/buffer than from where i executed them.  these versions (starts with a capital letter) will restore the current window or buffer when the command's done.

for example, to turn on line numbers everywhere, i use :Windo set nu -- :windo set nu does the trick also but leaves me in a different window than where i started.

" just like windo but restores the current window when it's done
function! WinDo(command)
  let currwin=winnr()
  execute 'windo ' . a:command
  execute currwin . 'wincmd w'
endfunction
com! -nargs=+ -complete=command Windo call WinDo(<q-args>)

" just like bufdo but restores the current buffer when it's done
function! BufDo(command)
 let currBuff=bufnr("%")
 execute 'bufdo ' . a:command
 execute 'buffer ' . currBuff
endfunction
com! -nargs=+ -complete=command Bufdo call BufDo(<q-args>)

VimTip 134: View Source in IE6 using VIM
http://vim.sourceforge.net/tip_view.php?tip_id=

You can change the "View Source" editor of IE6 by adding the following to the Windows Registry. Change the path in case you installed VIM in another location.

[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Internet Explorer\View Source Editor\Editor Name]
@="C:\\vim\\vim60\\gvim.exe"

VimTip 135: Vim buffer FAQ
http://vim.sourceforge.net/tip_view.php?tip_id=

Vim provides various commands and options to support editing multiple
buffers.  This document covers some of the questions asked about using
multiple buffers with Vim.  You can get more detailed information about Vim
buffer support using ":help windows.txt" in Vim.  You can also use the help
keywords mentioned in this document to read more about a particular command
or option.  To read more about a particular command or option use, ":help
<helpkeyword>" in Vim.

1. What is a Vim buffer?
   A buffer is a file loaded into memory for editing.  All opened files are
   associated with a buffer. There are also buffers not associated with any
   file.

   Help keyword(s): windows-intro

2. How do I identify a buffer?
   Vim buffers are identified using a name and a number.  The name of the
   buffer is the name of the file associated with that buffer.  The buffer
   number is a unique sequential number assigned by Vim.  This buffer
   number will not change in a single Vim session.

   Help keyword(s): :buffers

3. How do I create a buffer?
   When you open a file using any of the Vim commands, a buffer is
   automatically created.  For example, if you use the ":edit file" command
   to edit a file, a new buffer is automatically created.

4. How do I add a new buffer for a file to the buffer list without opening
   the file?
   You can add a new buffer for a file without opening it, using the
   ":badd" ex command.  For example,

       :badd f1.txt
       :badd f2.txt

   The above commands will add two new buffers for the files f1.txt and
   f2.txt to the buffer list.

   Help keyword(s): :badd

5. How do I get a list of all the existing buffers?
   You can get a list of all the existing buffers using the ":buffers" or
   ":ls" or ":files" ex command.  This list is called the 'buffer list'.

   In Vim 6.0, to display all the buffers including unlisted buffers, use
   the ":buffers!" or ":ls!" or ":files!" ex command.

   Help keyword(s): :buffers, :ls, :files

6. How do I delete a buffer?
   You can delete a buffer using the ":bdelete" ex command.  You can use
   either the buffer name or the buffer number to specify a buffer.  For
   example,

       :bdelete f1.txt
       :bdelete 4

   The above commands will delete the buffer named "f1.txt" and the fourth
   buffer in the buffer list.  The ":bdelete" command will remove the buffer
   from the buffer list.

   In Vim 6.0, when a buffer is deleted, the buffer becomes an
   unlisted-buffer and is no longer included in the buffer list.  But the
   buffer name and other information associated with the buffer is still
   remembered.  To completely delete the buffer, use the ":bwipeout" ex
   command.  This command will remove the buffer completely (i.e. the
   buffer will not become a unlisted buffer).

   Help keyword(s): :bdelete, :bwipeout

7. How do I delete multiple buffers?
   You can delete multiple buffers in several ways:

   1. Pass a range argument to the ":bdelete" command. For example,

           :3,5bdelete

      This command will delete the buffers 3, 4 and 5.
   2. Pass multiple buffer names to the ":bdelete" command.  For example,

           :bdelete buf1.txt buf2.c buf3.h

      This command will delete buf1.txt, buf2.c and buf3.h buffers.  In
      this example, after typing ":bdelete buf", you can press <Ctrl-A> to
      expand all the buffer names starting with 'buf'.

   Help keyword(s): :bdelete, :bwipeout

8. How do I remove a buffer from a window?
   You can remove a buffer displayed in a window in several ways:

   1. Close the window or edit another buffer/file in that window.
   2. Use the ":bunload" ex command. This command will remove the buffer
      from the window and unload the buffer contents from memory.  The
      buffer will not be removed from the buffer list.

   Help keyword(s): :bunload

9. How do I edit an existing buffer from the buffer list?
   You can edit or jump to a buffer in the buffer list in several ways:

   1. Use the ":buffer" ex command passing the name of an existing buffer
      or the buffer number.  Note that buffer name completion can be used
      here by pressing the <Tab> key.
   2. You can enter the buffer number you want to jump/edit and press the
      Ctrl-^ key.
   3. Use the ":sbuffer" ex command passing the name of the buffer or the
      buffer number.  Vim will split open a new window and open the
      specified buffer in that window.
   4. You can enter the buffer number you want to jump/edit and press the
      Ctrl-W ^ or Ctrl-W Ctrl-^ keys.  This will open the specified buffer
      in a new window.

   Help keyword(s): :buffer, :sbuffer, CTRL-W_^, CTRL-^

10. How do I browse through all the available buffers?
    You can browse through the buffers in the buffer list in several ways:

    1. To jump to the first buffer in the buffer list, use the ":bfirst" or
       ":brewind" ex command.
    2. To jump to the first buffer in the buffer list in a new window, use
       the ":sbfirst" or ":sbrewind" ex command.
    3. To edit the next buffer in the buffer list, use the ":bnext" ex
       command.
    4. To open the next buffer in the buffer list in a new window, use the
       ":sbnext" ex command.
    5. To edit the previous buffer in the buffer list, use the ":bprevious"
       or ":bNext" ex command.
    6. To open the previous buffer in the buffer list in a new window, use
       the ":sbprevious" or ":sbNext" ex command.
    7. To open the last buffer in the buffer list, use the ":blast" ex
       command.
    8. To open the last buffer in the buffer list in a new window, use the
       ":sblast" ex command.

    Help keyword(s): :bfirst, :brewind, :sbfirst, :sbrewind, :bnext,
                     :sbnext, :bprevious, :bNext, :sbprevious, :sbNext,
                     :blast, :sblast

11. How do I open all the buffers in the buffer list?
    You can open all the buffers present in the buffer list using the
    ":ball" or ":sball" ex commands.

    Help keyword(s): :ball, :sball

12. How do I open all the loaded buffers?
    You can open all the loaded buffers in the buffer list using the
    ":unhide" or ":sunhide" ex commands.  Each buffer will be loaded in a
    separate new window.

    Help keyword(s): :unhide, :sunhide

13. How do I open the next modified buffer?
    You can open the next or a specific modified buffer using the
    ":bmodified" ex command.  You can open the next or a specific modified
    buffer in a new window using the ":sbmodified" ex command.

    Help keyword(s): :bmodified, :sbmodified

14. I am using the GUI version of Vim (gvim), is there a simpler way for
    using the buffers instead of the ex commands?
    Yes.  In the GUI version of Vim, you can use the 'Buffers' menu, which
    simplifies the use of buffers.  All the buffers in the buffer list are
    listed in this menu.  You can select a buffer name from this menu to
    edit the buffer.  You can also delete a buffer or browse the buffer
    list.

    Help keyword(s): buffers-menu

15. Is there a Vim script that simplifies using buffers with Vim?
    Yes.  You can use the bufexplorer.vim script to simplify the process of
    using buffers.  You can download the bufexplorer script from:

        http://lanzarotta.tripod.com/vim.html

16. Is it possible to save and restore the buffer list across Vim sessions?
    Yes.  To save and restore the buffer list across Vim session, include
    the '%' flag in the 'viminfo' option.  Note that if Vim is invoked with
    a filename argument, then the buffer list will not be restored from the
    last session.  To use buffer lists across sessions, invoke Vim without
    passing filename arguments.

    Help keyword(s): 'viminfo', viminfo

17. How do I remove all the entries from the buffer list?
    You can remove all the entries in the buffer list by starting Vim with
    a file argument.  You can also manually remove all the buffers using
    the ":bdelete" ex command.

18. What is a hidden buffer?
    A hidden buffer is a buffer with some unsaved modifications and is not
    displayed in a window.  Hidden buffers are useful, if you want to edit
    multiple buffers without saving the modifications made to a buffer
    while loading other buffers.

    Help keyword(s): :buffer-!, 'hidden', hidden-buffer, buffer-hidden

19. How do I load buffers in a window, which currently has a buffer with
    unsaved modifications?
    By setting the option 'hidden', you can load buffers in a window that
    currently has a modified buffer.  Vim will remember your modifications
    to the buffer.  When you quit Vim, you will be asked to save the
    modified buffers.  It is important to note that, if you have the
    'hidden' option set, and you quit Vim forcibly, for example using
    ":quit!", then you will lose all your modifications to the hidden
    buffers.

    Help keyword(s): 'hidden'

20. Is it possible to unload or delete a buffer when it becomes hidden?
    The following works only in Vim 6.0 and above. By setting the
    'bufhidden' option to either 'hide' or 'unload' or 'delete', you can
    control what happens to a buffer when it becomes hidden.  When
    'bufhidden' is set to 'delete', the buffer is deleted when it becomes
    hidden. When 'bufhidden' is set to 'unload', the buffer is unloaded
    when it becomes hidden.  When 'bufhidden' is set to 'hide', the buffer
    is hidden.

    Help keyword(s): 'bufhidden'

21. How do I execute a command on all the buffers in the buffer list?
    In Vim 6.0, you can use the ":bufdo" ex command to execute an ex
    command on all the buffers in the buffer list.

    Help keyword(s): :bufdo

22. When I open an existing buffer from the buffer list, if the buffer is
    already displayed in one of the existing windows, I want Vim to jump to
    that window instead of creating a new window for this buffer.  How do I
    do this?
    When opening a buffer using one of the split open buffer commands
    (:sbuffer, :sbnext), Vim will open the specified buffer in a new
    window.  If the buffer is already opened in one of the existing
    windows, then you will have two windows containing the same buffer.
    You can change this behavior by setting the 'switchbuf' option to
    'useopen'.  With this setting, if a buffer is already opened in one of
    the windows, Vim will jump to that window, instead of creating a new
    window.

    Help keyword(s): 'switchbuf'

23. What information is stored as part of a buffer?
    Every buffer in the buffer list contains information about the last
    cursor position, marks, jump list, etc.

24. What is the difference between deleting a buffer and unloading a
    buffer?
    When a buffer is unloaded, it is not removed from the buffer list.
    Only the file contents associated with the buffer are removed from
    memory.  When a buffer is deleted, it is unloaded and removed from the
    buffer list.  In Vim 6, a deleted buffer becomes an 'unlisted' buffer.

    Help keyword(s): :bunload, :bdelete, :bwipeout, unlisted-buffer

25. Is it possible to configure Vim, by setting some option, to re-use the
    number of a deleted buffer for a new buffer?
    No.  Vim will not re-use the buffer number of a deleted buffer for a
    new buffer.  Vim will always assign the next sequential number for a
    new buffer.  The buffer number assignment is implemented this way, so
    that you can always jump to a buffer using the same buffer number.  One
    method to achieve buffer number reordering is to restart Vim.  If you
    restart Vim, it will re-assign numbers sequentially to all the buffers
    in the buffer list (assuming you have properly set 'viminfo' to save
    and restore the buffer list across vim sessions).

    Help keyword(s): :buffers

26. What options do I need to set for a scratch (temporary) buffer?
    The following works only in Vim 6.0 and above.  You can set the the
    following options to create a scratch (temporary) buffer:

        :set buftype=nofile
        :set bufhidden=hide
        :setlocal noswapfile

    This will create a buffer which is not associated with a file, which
    does not have a associated swap file and will be hidden when removed
    from a window.

    Help keyword(s): special-buffers, 'buftype'

27. How do I prevent a buffer from being added to the buffer list?
    The following works only in Vim 6.0 and above. You can prevent a buffer
    from being added to the buffer list by resetting the 'buflisted'
    option.

        :set nobuflisted

    Help keyword(s): 'buflisted'

28. How do I determine whether a buffer is modified or not?
    There are several ways to find out whether a buffer is modified or not.
    The simplest way is to look at the status line or the title bar.  If
    the displayed string contains a '+' character, then the buffer is
    modified.  Another way is to check whether the 'modified' option is set
    or not.  If 'modified' is set, then the buffer is modified.  To check
    the value of modified, use

        :set modified?

    You can also explicitly set the 'modified' option to mark the buffer as
    modified like this:

        :set modified

    Help keyword(s): 'modified'

29. How can I prevent modifications to a buffer?
    The following works only in Vim 6.0 and above. You can prevent any
    modification to a buffer by re-setting the 'modifiable' option.  To
    reset this option, use

        :set nomodifiable

    To again allow modifications to the buffer, use:

        :set modifiable

    Help keyword(s): 'modifiable'

30. How do I set options specific to the current buffer?
    The following works only in Vim 6.0 and above.  You can set Vim options
    which are specific to a buffer using the "setlocal" command.  For
    example,

        :setlocal textwidth=70

    This will set the 'textwidth' option to 70 only for the current buffer.
    All other buffers will have the default or the previous 'textwidth'
    value.

    Help keyword(s): 'setlocal', local-options

31. How do I define mappings specific to the current buffer?
    The following works only in Vim 6.0 and above.  You can define mappings
    specific to the current buffer by using the keyword "<buffer>" in the
    map command.  For example,

        :map <buffer>  ,w  /[.,;]<CR>

    Help keyword(s): :map-local

32. How do I define abbreviations specific to the current buffer?
    The following works only in Vim 6.0 and above.  You can define
    abbreviations specific to the current buffer by using the keyword
    "<buffer>" in the :abbreviate command.  For example,

        :abb <buffer> FF  for (i = 0; i < ; ++i)

    Help keyword(s): :abbreviate-local

VimTip 136: Remapping Alt, Ctrl and Caps in Win2k
http://vim.sourceforge.net/tip_view.php?tip_id=

Since I installed Win2K on my laptop, I had been unable to locate a utilitie that would simply enable me to remap my Crtl Alt and Caps the way I think they should be and the way they were until MS kill all competition in computing, that is Crtl on the left of the letter A, Alt to the left bottom of the letter Z and Caps approximately until the C.

After some research, I came across a tip posted here by juano@mindspring.com. I tried to make sense of it and then downloaded the MS scan keys map at the URL he mentionned.

Extrapolating his tip, I wrote this ASCI file that I named keys2000.reg :

Regedit4
[HKey_Local_MACHINE\SYSTEM\CurrentControlSet\Control\Keyboard Layout]
"Scancode Map"=hex:00,00,00,00,00,00,00,00,04,00,00,00,3A,00,38,00,38,00,1D,00,1D,00,3A,00,00,00,00

Once you have saved this file, left click on it from Explorer and answer yes to the prompt "do you want to enter this into the registry".

Reboot and you are done.

A few explanations :04 stands for 3 remappings (Caps lock to Control, Control to Alt and Alt to Caps Lock) plus the closing one which is always required (1 remapping would require 02, 2 would require 03, and so on). 3A,00,38 remaps Caps to Left Alt, 38,00,1D remaps Left Alt to Left Ctrl and 1D,00,3A remaps Left Ctrl to Caps Lock since 3A=Caps, 1D=Left Ctrl and 38=Left Alt.

Based on Juano tip and on this one, I believe a lot of remapping can be done as long as you keep the separators 00 and remember to add one to the number of remappings. What I do not know is how far you can extend this instruction without getting into trouble with the registry. At worst, if you keyboard does not behave as expected, go into the registry and delete this instruction (be careful here since it is easy to confuse this instruction with the Keyboard LayoutS (S for emphasis) which must not be deleted.

Again, thanks to Juano@mindspring.com who got me going and suggested I post my tip. Took me some time to retrieve the VIM Url but fortunately, I had printed his tip.

Regards

VimTip 137: automatically wrap left and right
http://vim.sourceforge.net/tip_view.php?tip_id=

I hate it when I hit left (or h) and my screen flickers.  I want it to go up to the next line.  Ditto fir right (or l).  Below are two functions / mappings to help with that.  I'm pretty sure that if you remove the <silent>, then it will work in 5.x...

nnoremap <silent> <Left>  :call WrapLeft()<cr>
nnoremap <silent> <Right> :call WrapRight()<cr>

nnoremap <silent> h       :call WrapLeft()<cr>
nnoremap <silent> l       :call WrapRight()<cr>

function! WrapLeft()
    let col = col(".")


    if 1 == col
        " don't wrap if we're on the first line
        if 1 == line(".")
            return
        endif
        normal! k$
    else
        normal! h
    endif
endfunction

function! WrapRight()
    let col = col(".")
    if 1 != col("$")
        let col = col + 1
    endif


    if col("$") == col
        " don't wrap if we're on the last line
        if line("$") == line(".")
            return
        endif
        normal! j1|
    else
        normal! l
    endif
endfunction

VimTip 138: Getting name of the function
http://vim.sourceforge.net/tip_view.php?tip_id=

Hi All,


While browsing code one always needs to know which function you are currently looking. Getting the name is very painful when the functions are lengthy and you are currently browsing NOT near to the start of the function. You can get the function's name by using this simple mapping.


Just place this in your .vimrc.


map _F ma[[k"xyy`a:echo @x<CR>


now _F will display which function you are currently in.


Enjoy the power of Vim
-Nitin Raut

PS: The working is as follows, mark the current line with a, jump to the previous '{' in the first column, go one line up, yank the line in register x, return to the mark a, echo the value of register x, which is the wanted function name.

VimTip 139: Alignment: =, LaTeX tables, declarations, etc
http://vim.sourceforge.net/tip_view.php?tip_id=

Check out

http://www.erols.com/astronaut/vim/textab.html

and see some examples of text alignment (its hopeless to do it here with
proportional fonts).  You'll be able to download textab source, a Windows-based
textab executable, and a scriptfile containing a convenient interface (ttalign.vim).  The textab program coupled with <ttalign.vim> lets you:

1. align C language statements on their = += -= /= etc symbols
2. align C language declararations: separate columns for types, *[, variable
   names, initializations (=), and comments (// or /* .. */)
3. align C/C++ language comments (//, /* .. */)
4. align C/C++ language (ansi) function argument lists
5. align LaTeX tables on their && separators
6. align HTML tables with </TD><TD> separators
7. align on several characters: < ? : | @ ;  (or modify them to handle whatever
   alignment characters you want)

VimTip 140: tip using embedded perl interpreter
http://vim.sourceforge.net/tip_view.php?tip_id=

When writing scripts using the embedded interpreter available if vim has the +perl ore +perl/dyn on
gives you access to this powerfull and FAST scripting language (especially fast compared to vim
scripts)  there are some gotchas.

First:
never embed complex perl command in the body of a vim function this will be recompiled and evaled
each time for a tremendous loss of time.instead to it like this

perl << EOF
sub mySub
{
  #some usefull perl stuff
}
EOF

function! MyFunction
perl mySub "an argument", "another"
endfunction

to pass computed argument to your perl sub use the vim exec command
function! MyFunction
exec "perl mySub " . aLocalVar . ", " b:aBufferLocalVar
endfunction

It may be very hard to debug your perl sub since the output of the perl compiler is
somehow lost in the middle of nowhere and the debugger is not available.
When a compilation error occurs in your sub definition you'll get an error message
when you try to call it saying that the sub does not exists.
One thing which I have found very usefull is to write a fake VIM module with stub
methods which will allow you to use the command line perl interpretor to at least
compile your program.  You could make your stub smart enough to fake a vim
and use the debugger.  Here is a sample for such a fake module defining just
those method which I was using.

package VIM;
use diagnostics;
use strict;
sub VIM::Eval
{
	$_ = shift;


	print "Eval $_\n";


	{
		  return '^(?!!)([^\t]*)\t[^\t]*\t(.*);"\t([^\t]*)\tline:(\d*).*$' if (/g:TagsBase_pattern/);
		  return $ARGV[0] if (/b:fileName/);
		  return '$3' if (/g:TagsBase_typePar/);
		  return '$1' if (/g:TagsBase_namePar/);
		  return '$4' if (/g:TagsBase_linePar/);
		  return 'Ta&gs' if (/s:menu_name/);
		  return $ARGV[1] if (/g:TagsBase_groupByType/);
		die "unknown eval $_";
	}
}
sub VIM::Msg
{
	my $msg = shift;
	print "MSG $msg\n";
}
sub VIM::DoCommand
{
	my $package;
	my $filename;
	my $line;
    ($package, $filename, $line) = caller;


	my $command = shift;
	print "at $filename $line\n";
	print "DoCommand  $command\n";
}
1;

Then you can copy other your perl code in a separate file and add a use VIM; at the top
and your set to debug.

Good Vimming good perling.
Benoit
PS:
this tips are probably true for other scripting languages

VimTip 141: Add your function heading with a keystroke
http://vim.sourceforge.net/tip_view.php?tip_id=

Below is a tip that the C/C++ Newbies may find interesting and handy to use.  The following code will add a function heading and position your cursor just after Description so that one can document as one proceeds with code.

function FileHeading()
	let s:line=line(".")
	call setline(s:line,"/***************************************************")
	call append(s:line,"* Description - ")
	call append(s:line+1,"* Author -      Mohit Kalra")
	call append(s:line+2,"* Date -        ".strftime("%b %d %Y"))
	call append(s:line+3,"* *************************************************/")
	unlet s:line
endfunction

imap <F4>  <esc>mz:execute FileHeading()<RET>`zjA

Where <esc> stands for ^V+ESC and <RET> for ^V+ENTER

VimTip 142: Automatic function end commenting for C++ and Java
http://vim.sourceforge.net/tip_view.php?tip_id=

Some people have a habit of adding the function name as a comment to the end of that function, if it is long, so that he/she knows which function the '}' ends. Here's a way to automate the process.

Use the following abbreviation:
iab }// } // END: <esc>10h%$?\w\+\s*(<cr>"xy/\s*(<cr>/{<cr>:nohl<cr>%$"xpa

If you now end the function with '}//', the follwoing string will be automatically generated: '} //END: functionname'

VimTip 143: Use of Vim folds for javadocs
http://vim.sourceforge.net/tip_view.php?tip_id=

Hi,

The fold-method marker can be effectively use to set the folds in your Java source.  Define some marker and place it inside HTML comments <!-- xx -->.  This way, it does not affect the Javadocs generated without the necessity of a seprate comment line.
e.g.

/**
 * <!-- zz.FOLDSTART class AbcClass -->
 * The class description.
 * ...
 */
public class AbcClass {

    /**
     * <!-- method zz.FOLDSTART someMethod() -->
     * Method description.
     */
    public void someMethod();

    ...

} /* zz.END: AbcClass */

/* Put this at the end of your file */
/* vim:fdm=marker fmr=zz.FOLDSTART,zz.END fdl=2 fdc=2: */

Now, the files will be opened with the methods neatly folded.
You can use "zR" to open all folds (or click on the "+" at the left column).

Sameer.

VimTip 144: recording keystrokes by "q" for repested jobs
http://vim.sourceforge.net/tip_view.php?tip_id=

The most useful feature that I find in VIM is the "recording" feature (:help recording).  I have used this to automatically insert function headers, re-indent lines, and convert some 34 source files into HTML.

This feature is most useful when you want to do some repeated jobs, which you cant do easily using ".".  You can set about writing a function, define a mapping, etc, but then these things might take time.  By recording, you can try out and find the actual keystrokes that does the job.

To start recording, press "q" in normal mode followed by any of "0-9a-z".  This will start recording the keystrokes to the register you choose.  You can also see the word "recording" in the status(?) line.  You can start the key sequences that you want to record.  You can go to insert mode and type if you want.

To stop recording, press "q" in the normal mode.

To playback your keystrokes, press "@" followed by the character you choose.  Pressing "@@" will repeat the same again.

Sameer.

VimTip 145: Changing DOS style end of line to UNIX, or vise-versa
http://vim.sourceforge.net/tip_view.php?tip_id=

Those of us doomed to work in both the Unix and Windows world have many times encountered
files that were create/editted on systems other that the one we are on at the time of our edits.  We
can easily correct the dreaded '^M' at the end of our Unix lines, or make files have more than one
line in DOS by:

To change from <CR><LF> (DOS) to just <LF> (Unix):
:set fileformat=unix
:w

Or to change back the other way:
:set fileformat=dos
:w

It also works for Apple land:
:set fileformat=mac
:w

And to tell the difference:
set statusline=%<%f%h%m%r%=%{&ff}\ %l,%c%V\ %P
                                              ^^^^^  This shows what the current file's format is.

Happy Vimming!

VimTip 146: opening multiple files from a single command-line
http://vim.sourceforge.net/tip_view.php?tip_id=

i use the :split command a lot -- both to open a second window containing the currently edited file and to edit a new file altogether (with the :split <filename> option).  however, i also like to be able to edit more than one file and calling :sp multiple times is inconvenient.  so, i created the following command, function and abbreviation:

function! Sp(...)
  if(a:0 == 0)
    sp
  else
    let i = a:0
    while(i > 0)
      execute 'let file = a:' . i
      execute 'sp ' . file

      let i = i - 1
    endwhile
  endif
endfunction
com! -nargs=* -complete=file Sp call Sp(<f-args>)
cab sp Sp

this retains the behaviour of :sp in that i can still type :sp (the abbreviation takes care of that).  :Sp takes any number of files and opens them all up, one after the other.

the things i have noticed are that this causes 'sp' to be expanded to 'Sp' everywhere, even in search patterns.  also, prepending 'vert' doesn't work.  if there is interest, i'll do that.

VimTip 147: How to write a plugin
http://vim.sourceforge.net/tip_view.php?tip_id=

This tip gives a skeleton for writing a plugin; Vim's help files have plenty
of details (:he plugin, :he write-plugin, :he plugin-details).

# ------------------------------------------------------------------------------
# Exit when your app has already been loaded (or "compatible" mode set)
if exists("loaded_YourAppName") || &cp
  finish
endif

# Public Interface:
#  AppFunction: is a function you expect your users to call
#  PickAMap: some sequence of characters that will run your AppFunction
# Repeat these three lines as needed for multiple functions which will
# be used to provide an interface for the user
if !hasmapto('<Plug>AppFunction')
  map <unique> <Leader>PickAMap <Plug>AppFunction
endif

# Global Maps:
#
map <silent> <unique> <script> <Plug>AppFunction
\ :set lz<CR>:call <SID>AppFunc<CR>:set nolz<CR>

# ------------------------------------------------------------------------------

# AppFunction: this function is available vi the <Plug>/<script> interface above
fu! <SID>AppFunction()
..whatever..

# your script function can set up maps to internal functions
nmap <silent> <left> :set lz<CR>:silent! call <SID>AppFunction2<CR>:set nolz<CR>

# your app can call functions in its own script and not worry about name
# clashes by preceding those function names with <SID>
call <SID>InternalAppFunction(...)

# or you could call it with
call s:InternalAppFunction(...)
endf
# ------------------------------------------------------------------------------

# InternalAppFunction: this function cannot be called from outside the
#  script, and its name won't clash with whatever else the user has loaded
fu! <SID>InternalAppFunction(...)
..whatever..
endf

# ------------------------------------------------------------------------------

Plugins are intended to be "drop into <.vim/plugin>" and work.  The problem
that the <Plug>, <SID>, etc stuff is intended to resolve: what to do about
functions that have the same names in different plugins, and what to do about
maps that use the same sequence of characters?  The first problem is solved
with <SID> (a script identifier number) that vim assigns: program with it and
your users will be happier when your stuff works with all their other stuff.
The second problem: what to about those maps is addressed with <Plug>, <unique>,
etc.  Basically the idea is: let the user know that there are clashes and don't
overwrite previously existing maps.  Use the user's preferred map-introducer
sequence (I like the backslash, but there are many keyboards which make
producing backslashes unpleasant, and those users usually prefer something
else).

What I like to do is to have a pair of start/stop maps to reduce my impact on
the namespace.  When the starting map is used, it kicks off a starting function
that introduces all the maps needed.  When the stopping map is used, it not
only removes the maps the starter made but restores any maps the user had had
that would have clashed.  I also use the start/stop pair of functions to set
and restore options that cause my scripts difficulties.

Check out DrawIt.vim's SaveMap() function for a way to save user maps.
Restoring maps with it is easy:

if b:restoremap != ""
 exe b:restoremap
 unlet b:restoremap
endif

So you can see it sets up a string variable with all the maps that the user
had that would have clashed with my application.

One final thing: if your application needs to share information between its
various functions, see if you can use s:varname (a variable that only your
script's functions can access) or b:varname (a variable that anything associated
with the buffer your application is running with can access) instead of using
global variables.

Good luck and happy Vimming!

VimTip 148: Make great use of those homemade menus
http://vim.sourceforge.net/tip_view.php?tip_id=

Accidently discovered that using <alt><Menu Hotletter><cr> (e.g <alt>b<cr> - for the buffer menu) causes the menu to break out in a seperate window.
Selecting the menu with the mouse and then hitting enter does not seem to do it.

I will have to learn to add hotletters to my menus now so that the mouse can take a break.

I am a total newbie with vim, but constantly amazed....

VimTip 149: Automatically update your diff upon writing.
http://vim.sourceforge.net/tip_view.php?tip_id=

When trying to reconcile differences between files, and using the new
'diff' functionality in Vim 6.0 you may want to automatically update
the differences as you are working along.  A convienent time is when you
write out either of the files you are diff'ing.  This autocmd will take
care of doing that for you.

" If doing a diff.  Upon writing changes to file, automatically update the
  " differences
  au BufWritePost                  *              if &diff == 1
  au BufWritePost                  *              :diffupdate
  au BufWritePost                  *              endif

VimTip 150: Generating a column of increasing numbers
http://vim.sourceforge.net/tip_view.php?tip_id=

You can use the "Visual Incrementing" script from

  http://www.erols.com/astronaut/vim/index.html#VimFuncs

to convert a block of numbers selected via ctrl-v (visual block)
into a column of increasing integers.  Select the column, press :I<CR>,
and the first line's number will be used as a starting value.  Subsequent
lines's numbers will be incremented by one.

If the ctrl-v block is "ragged right", which can happen when "$" is used
to select the right hand side, the block will have spaces appended as
needed to straighten it out.  If the strlen of the count exceeds the
visual-block allotment of spaces, then additional spaces will be inserted.

Example:  Put cursor on topmost zero, select column with ctrl-v, then :I

   vector[0]= 1;       vector[0]= 1;
   vector[0]= 1;       vector[1]= 1;
   vector[0]= 1;  -->  vector[2]= 1;
   vector[0]= 1;       vector[3]= 1;
   vector[0]= 1;       vector[4]= 1;

This script works with both vim 5.7 (:so visincr.vim) or vim 6.0 (source it
as for vim 5.7 or drop it into the .vim/plugin directory).

VimTip 151: an ascii table
http://vim.sourceforge.net/tip_view.php?tip_id=

There is an ascii table in the vim-help files, but it's hard to find.  Thus, I shall give a pointer to it:

:help digraph-table

VimTip 152: Spelling checkers for: Dutch, English, German, Hungarian, and Yiddish
http://vim.sourceforge.net/tip_view.php?tip_id=

Under http://www.erols.com/astronaut/vim/index.html#vimlinks_scripts
are links to spelling checkers for Dutch, English, German, Hungarian,
and Yiddish, all based on the original engspchk.vim.  The spelling
checker provides as-you-type spell checking; with vim6.0 it will avoid
checking on partially typed words.

Provided are several maps:

  \et : add  word under cursor into database for just this file
  \es : save word under cursor into database (permanently)
  \en : move cursor to the next     spelling error
  \ep : move cursor to the previous spelling error
  \ea : look for alternative spellings of word under cursor

To use \ea you will need agrep:

  agrep source: ftp://sunsite.unc.edu/pub/Linux/utils/text/agrep-2.04.tar.Z
  agrep Win exe: http://www.tgries.de/agrep

To use the spell checkers just source it in:

  ex.  so engspchk.vim

To read more about it see

  http://www.erols.com/astronaut/vim/index.html#Spelling

VimTip 153: Making Parenthesis And Brackets Handling Easier
http://vim.sourceforge.net/tip_view.php?tip_id=

1) ++++++++++++++++++++++++++ "Automatic" bracket setting +++++++++++++++++++++++++++++
2) +++++++++++++ Further improvement of parenthesis/bracket expanding +++++++++++++++++
3) ++++++++++++++++++++++++++++ "Late" bracketing of text +++++++++++++++++++++++++++++
4) +++++++++++++++++++++++++++++ Conclusion ++++++++++++++++++++++++++++++++++++++ ++++

=======================================================================================

1) ++++++++++++++++++++++++++ "Automatic" bracket setting +++++++++++++++++++++++++++++

To automatically insert a closing parenthesis when typing an opening
parenthesis you can insert the following simple mapping to your vimrc:

	:inoremap ( ()<ESC>i

This ends up with the cursor between the opening and the closing parenthesis
in insert mode.

You can apply this and the following tips, of course, with the kind of parenthesis/bracket
character you want to, i.e. (, {, [, < ..... and, pretty useful as well,
quotation marks ",',.... (to be continued)

2) +++++++++++++++ Further improvement of parenthesis/bracket expanding ++++++++++++++++++

I you are ready with filling the parenthesis/brackets, you likely want to
"escape" from the brackets again to continue coding.
To make this pretty comfortable, I invented the following kind of mappings, which get out
of the last expanded parenthesis/bracket, regardless of the actual type of it, and
enter append mode again.
I mapped this kind of "getaway" with CTRL_j, you may use your favorite keystroke with it.

			...
	:inoremap ( ()<ESC>:let leavechar=")"<CR>i
	:inoremap [ []<ESC>:let leavechar="]"<CR>i
			...
	:imap <C-j> <ESC>:exec "normal f" . leavechar<CR>a

Explanation: The variable "leavechar" contents the actual char which is to "escape" from.

3) ++++++++++++++++++++++++++++ "Late" bracketing of text +++++++++++++++++++++++++++++

Occasionally I later want already written text parts to put in parenthesis.

I use the following macro, which brackets previously visually selected text.
I mapped it with _(.

	:vnoremap _( <ESC>`>a)<ESC>`<i(<ESC>

Furthermore, a sort of mapping for bracketing a *single word* is conceivable.
Because this is not as general like the kind of visual mode mapping, I use
this kind of "word bracketing" only for surrounding the word right behind the cursor in insert mode with **.  I use the following macro to "emphasize" the word i just typed,
for newsgroup articles.

	:imap _* <Esc>bi*<Esc>ea*<Space>

4) ++++++++++++++++++++++++++++++ Conclusion ++++++++++++++++++++++++++++++++++++++++++

Since I use these macros, I never caused a syntax error because of missing
brackets, and furthermore I can quickly insert parenthesis and qutotes into code-
and non-code files.

 JH 04.11.2001

VimTip 154: Mappings to facilitate the creation of text
http://vim.sourceforge.net/tip_view.php?tip_id=

"
" Mappings to facilitate the creation of text
"
" Author:  Suresh Govindachar sgovindachar@yahoo.com
" Date:     November 5, 2001
"
" While typing text to create a document, I often end up hitting
" <Esc>, issuing some commands (with or without ":") and getting back
" to typing by issuing a command such as "i", "O", "s" etc.
"
" I looked into using "set insertmode" to speed up such actions, but
" found that too confusing.
"
" I have come up with a set of mappings that have speeded up my process
" of creating documents.  I have saved these mappings in a file, named
" FullScreenVI.vim, in vim's plugin directory.
"
" Perhaps you will find these mappings helpful too.
"
" Please send me feedback.
"

"To allow overriding the Alt key
set winaltkeys=no
"To enable viewing messages from commands issued using the mappings presented here
set cmdheight=2

"The fundamental mapping that makes full-screen editing possible
imap <A-o>  <C-o>
imap <A-;>  <C-o>:

"Basic motions
imap <A-h>  <Left>
imap <A-j>  <Down>
imap <A-k>  <Up>
imap <A-l>  <Right>
imap <A-f>  <PageDown>
imap <A-b>  <PageUp>
imap <A-^>  <Home>
imap <A-$>  <End>

"Numbers for repeats
imap <A-1>  <C-o>1
imap <A-2>  <C-o>2
imap <A-3>  <C-o>3
imap <A-4>  <C-o>4
imap <A-5>  <C-o>5
imap <A-6>  <C-o>6
imap <A-7>  <C-o>7
imap <A-8>  <C-o>8
imap <A-9>  <C-o>9

"Basic searches
imap <A-/>  <C-o>/
imap <A-*>  <C-o>*
imap <A-#>  <C-o>#
imap <A-n>  <C-o>n
imap <A-N>  <C-o>N

"Deleting
imap <A-x>  <C-o>x
imap <A-d>  <C-o>d
imap <A-D>  <C-o>D

"Yanking and putting
imap <A-y>  <C-o>y
imap <A-Y>  <C-o>Y
imap <A-p>  <C-o>p
imap <A-P>  <C-o>P

"Common prefixes:  marking, matching etc.
imap <A-~>  <C-o>~
imap <A-m>  <C-o>m
imap <A-`>  <C-o>`
imap <A-">  <C-o>"
imap <A-%>  <C-o>%
imap <A-h>  <C-o>:h
imap <A-s>  <C-o>:s

"Interacting with the 'outside'
imap <A-!>  <C-o>:!
imap <A-w>  <C-o>:w<CR>
imap <A-e>  <C-o>:e

"Other commands
imap <A-u>  <C-o>u
imap <A-.>  <C-o>.

VimTip 155: Decompile Java .class files automatically
http://vim.sourceforge.net/tip_view.php?tip_id=

Here's a plugin to automatically decompile Java .class files as they're read in.  Tweak the javap flags for what you want to see.  I didn't post this as a script because it's too simple and it's really more useful for demonstrating how to read decompilable files (or other binary files that can be converted to text).

function s:ReadClass(dir, classname)
    execute "cd " . a:dir
    execute "0read !javap -c " . a:classname
    1
    setlocal readonly
    setlocal nomodified
endfunction

autocmd BufReadCmd *.class
    \ call <SID>ReadClass(expand("<afile>:p:h"), expand("<afile>:t:r"))

VimTip 156: describe <table name> from vim
http://vim.sourceforge.net/tip_view.php?tip_id=

i had some trouble with the sqlplus scripts (probably my fault).  but it seemed a little heavy for what i need, usually all i want is a listing of the columns for a given table while i'm whipping on some sql inside vim.

so i wrote a bash script (describe)...

~~~~~~~~~~~~~~~begin describe script
#!/usr/bin/bash

f=aTempFile.sql
u=<uName>
p=<pWord>
d=<dBase>

echo "/* describe for $1"
echo "describe $1;" > $f;
echo "quit;" >> $f;

sqlplus -S $u/$p@$d @$f
rm -f $f;
echo " end describe for $1 */"
~~~~~~~~~~~~~~~end describe script

your path needs to include the script (as well as sqlplus), then from vim you can just type....

:r !describe <tableName>

and you get a listing of the table columns slammed into wherever your cursor was, complete with java/c comments

VimTip 158: Using Computer Modern TT as gvim font (Win32)
http://vim.sourceforge.net/tip_view.php?tip_id=

If you really like the Computer Modern typewriter font (as seen in most TeX distributions) you can use it as the font in gvim! (looks excellent with font smoothing turned on)

First, get hold of the free Blue Sky Type 1 PS versions of the CM fonts from your local CTAN mirror. Unpack to a suitable directory.

Next locate the cmtt8.pfb file and open it (in Vim, naturally ;) - find the line
saying
dup 32 /visiblespace put

and change it to
dup 32 /space        put

that is, inserting enough spaces to keep the file size exactly the same
(IMPORTANT!)

Save the file in Mac format (:set fileformat=mac).

Now install the cmtt.pfm file - in Win9x/NT4, you'll need Adobe Type Manager
(free download), but in Win2k, you can just drop the .pfm file into the Fonts folder.

Now in your _gvimrc:
set guifont=CMTT8:h11:cSYMBOL

(use whatever height you like instead of h11)

..and enjoy! It's the first scalable font I can bear to edit code in... %-)

VimTip 159: Keystroke Saving Substituting and Searching
http://vim.sourceforge.net/tip_view.php?tip_id=

1) ++++++++++++++ Saving Keystrokes for common Searching and Substituting +++++++++++
--- a) Searching  b) Substituting ---------------------------------------------------
2) ++++  Searching for resp. Substituting of the current word under the cursor ++++++
--- a) Searching  b) Substituting ---------------------------------------------------
3) ++ Searching and Substituting for an arbitrary visually selected part of text ++++
--- a) Searching  b) Substituting ---------------------------------------------------
4) ++++++++++++++++++++++++++++++++  Conclusion +++++++++++++++++++++++++++++++++++++

=====================================================================================

1) ++++++++++++++ Saving Keystrokes for common Substituting and Searching +++++++++++

a) Searching ............
Sorry, there is not much that can be saved for common Searching. It's just hitting
/mypattern<RETURN>

b) Substituting .........
I think, common substitution requires pretty many keystrokes. So I use the
following macro with my favorite substitution options:

:map <F4> :%s//gc<Left><Left><Left>

This ends up with the cursor after the first '/' in the commandline. To complete it,
you only have to enter
->	myoldpattern/mynewpattern<RETURN>

Remark: I mapped it to <F4> (cause of tribute to the <F4> of the good old Norton
Commander editor). You may map it where you want to.

2) ++++  Searching for resp. Substituting of the current word under the cursor ++++++

a) Searching ............
If you don't know how to look for the next occurence of the word under the cursor, you
should *now* type
:help * or
:help star
or refer to the tips vimtip #1 or vimtip #5
((Tip within tip: To make your pattern more visible, look for :help hls))

b) Substituting .........
The following macro extends the one above with automatically inserting the current word
under the cursor into the from - pattern of the :s command.

:map <S-F4> :%s/<C-r><C-w>//gc<Left><Left><Left>

To complete it, just enter
->	mynewpattern<RETURN>

I use this i.e. for reliable and quickly renaming a variable in the entire buffer.
I mapped it to Shift-<F4>. You may map it to the keystroke you want.

Explanation: CTRL-v+CTRL-w expands to the word under the cursor.

3) ++ Searching and Substituting for an arbitrary visually selected part of text ++++

If you want to look or substitute (for) an *arbritary* pattern (which already exists at
least once in your text), the following 2 mappings do it for you.
The advantage is that you dont have to type again or cut & paste the appropriate text
but only have to visually select it.

a) Searching ...........

:vmap / y:execute "/".escape(@",'[]/\.*')<CR>

This immediately finds to the next occurence of the previously visually selected text.

b) Substituting .........

:vmap <F4> y:execute "%s/".escape(@",'[]/\')."//gc"<Left><Left><Left><Left>

Again, as in the mapping in chapter 2), you just have to complete it by entering
-> mynewpattern<RETURN>

Explanation/Discussion:
What both Substituting and Searching in this way generally does is:
- *y*anking the selected text
- Inserting the visually selected via adressing the '"' register with '@"' as a
  parameter of the escape() function going finally into the 'myoldpattern' part.
  The trickery problem is, if you have characters in your myoldpattern, which are
  regular expression chars, they are recognized and threated accordingly.  That
  is most likely not what you wanted.  To escape them, these chars have to be
  declared by the second parameter of the excape() function, which then escapes them
  with a backslash.  The few characters above work for me. If you run into problems,
  you should check for additional regexp chars in your text, and try to escape them
  by adding them to the escape() function parameter.

4) ++++++++++++++++++++++++++++++++  Conclusion +++++++++++++++++++++++++++++++++++++

With the appropriate mappings in your vimrc you can save keystrokes when Searching or
Substituting and avoid typing errors. That way, you can take lunch sooner

VimTip 161: Dutch spelling checker
http://vim.sourceforge.net/tip_view.php?tip_id=

Download at http://www.thomer.com/thomer/vi/nlspchk.vim.gz.

This sciript is based on Charles E. Campbell's English spelling checker script for ViM (http://users.erols.com/astronaut/vim/) and Piet Tutelaers' Dutch word list (http://www.ntg.nl/spell-nl-v5b/) using  Thomas Köhler's script (http://jeanluc-picard.de/vim/gerspchk/create). In other words, I didn't do much.

VimTip 162: write plugin with explorer like interfaces
http://vim.sourceforge.net/tip_view.php?tip_id=

Several plugins use a text base interface based on a special buffer, this is the case of the standard explorer plugin, several bufexplorer plugins, the option buffer and others...
Here is a quick guide in how to do this

Writing a special buf script
	| using a special buffer is a common technic when writing Vim scripts, it is used by
	| explorer, bufexplorer, DirDiff...
	| I'm currently writing one for TagsBase.vim
	| http://vim.sourceforge.net/scripts/script.php?script_id=100
	| and I'll use this document to take notes on how to do it.
	|

Setting up the buffer
	Opening the window TODO

	Using a setup function
		Principle
			| we can use a specific function to open and setup the special buffer. s:SetupBuf()
		Setup Function advantage
			| since the command will be defined in the main script you
			| can use script local functions
	Using a special filetype
		Principle
			| we can also use a new filetype and distribute a syntax and an ftplugin for this
			| filetype, the only thing needed in this case is to set the
			| filetype after creating the buffer
		Filetype advantage
			| better separations of different parts of your script. If
			| the main function of your plugin is not to have this
			| special buffer then it is nice to avoid clutering it.
	Things which needs to be done to setup the buffer
		The buffer should not be listed and does not correspond to a file
			* setlocal buftype=nofile
			-	options always local to buffer
			* set nobuflisted
			* set bufhidden=delete
			* set nomodifiable
		Setup the syntax for this buffer
			| see :help syntax
			| This is usually done in two steps, first describe the
			| syntax groups using :syn commands then setup the
			| hilighting using :hi def link commands.  Usually it is
			| best to link the newly defined groups to predefine ones in
			| order to make the coloring work fine with colorschemes.
			| You'll find the list of predefined group by doing:
			| :help group-name
		Setup the special mappings
			| since we have chosen to use the set nomodifiable option
			| our buffer will never be in insert mode. All our mapping
			| are in Normal, Visual or operator pending, they should
			| therefore use the map, nmap, vmap and omap mapping command
			| plus the associated 'nore' version.  I usually find it
			| better to use the 'nore' version to avoid surprises due to
			| mapping in the user configuration.
			|
			| We also want our mappings to be local to the special
			| buffer so all the commands will use the <buffer> modifier.
			|
			| Finally we want our mappings not to polute the status bar
			| so we use the <silent> modifier
			|
			| Putting all this together we end up with mapping commands
			| which look like:
			| noremap <buffer> <silent> {lhs} {rhs}
		Setup the special command
			| we will then setup special commands for this buffer.  Like
			| for the mapping there are some precautions to take:
			| we don't want an error message if the command is defined
			| twice so we use the command! variant.
			| We want a command local to our buffer wo we use the
			| -buffer attribute.  The rests of the command attributes
			|  and options depend on the actual command.
			|  So our commands look like:
			|  command! -buffer {attr} {cmd} {rep}
			|  where attr is optional.

VimTip 163: Toggle Search Highlighting
http://vim.sourceforge.net/tip_view.php?tip_id=

" Map H to toggle search highlighting
map H :let &hlsearch = !&hlsearch<CR>

VimTip 164: Make non-ASCII characters displayed on console
http://vim.sourceforge.net/tip_view.php?tip_id=

I had a problem with VIM on the FreeBSD console: it didn't display characters like German umlauts correctly, but escaped them with a tilde. The solution is to teach VIM about printable characters. I use the following on my .vimrc:

set isprint=@,128-255

VimTip 165: Deleting a buffer without closing the window
http://vim.sourceforge.net/tip_view.php?tip_id=

I'm not sure if this functionality is already within Vim, but I sometimes I find it useful to keep a split window from closing when deleting a buffer.  This has already been discussed on the vim@vim.org mailing list.  However, I feel this solution is a little easier to use.

" Put this into .vimrc or make it a plugin.
" Mapping :Bclose to some keystroke would probably be more useful.
" I like the way buflisted() behaves, but some may like the behavior
" of other buffer testing functions.

command! Bclose call <SID>BufcloseCloseIt()

function! <SID>BufcloseCloseIt()
	let l:currentBufNum = bufnr("%")
	let l:alternateBufNum = bufnr("#")

	if buflisted(l:alternateBufNum)
		buffer #
	else
		bnext
	endif

	if bufnr("%") == l:currentBufNum
		new
	endif

	if buflisted(l:currentBufNum)
		execute("bdelete ".l:currentBufNum)
	endif
endfunction

VimTip 166: Mapping caps lock to esc in XWindows
http://vim.sourceforge.net/tip_view.php?tip_id=

(This originally appeared on the vim mailing list as post by Adam Monsen http://groups.yahoo.com/group/vim/message/19856)

If you want to completely swap caps lock and escape, you have to replace the
"Lock" on caps lock. Drop this file in your home dir:<br>
-----------start------------<br>
! Swap caps lock and escape<br>
remove Lock = Caps_Lock<br>
keysym Escape = Caps_Lock<br>
keysym Caps_Lock = Escape<br>
add Lock = Caps_Lock<br>
------------end-------------<br>
and call it ".speedswapper". Then open a terminal and type<br>
$ xmodmap .speedswapper<br>
and you'll be twice as efficient in vim. Who needs caps lock anyway? The swapping lasts for the duration of the X session, so you can put it in a .xinitrc or similar startup file. As far as other people using my laptop, I'd rather they didn't! Using a Dvorak layout might protect me even more... :)

VimTip 167: Using vim as a man-page viewer under Unix
http://vim.sourceforge.net/tip_view.php?tip_id=

To use vim as a man-page viewer involves setting an environment variable:

    sh, ksh:  export MANPAGER="col -b | view -c 'set ft=man nomod nolist' -"
    csh    :  setenv MANPAGER "col -b | view -c 'set ft=man nomod nolist' -"

Put one of the above two lines into your <.profile> or <.login> file as
appropriate for your shell.

The man pages will then be displayed with vim called as "view" and will use
the <man.vim> syntax highlighting.  I myself use some additional highlighting
which is enabled by putting the following file into <.vim/after/syntax/man.vim>.
I usually use the <astronaut> colorscheme (also available from this archive);
those who use bright backgrounds may find the colors selected for
manSubSectionStart and manSubSection something they'll want to change:

  ---------------------------------------------------------------------
" DrChip's additional <man.vim> stuff

syn match  manSectionHeading    "^\s\+[0-9]\+\.[0-9.]*\s\+[A-Z].*$" contains=manSectionNumber
syn match  manSectionNumber     "^\s\+[0-9]\+\.[0-9]*"              contained
syn region manDQString          start='[^a-zA-Z"]"[^", )]'lc=1      end='"'         contains=manSQString
syn region manSQString          start="[ \t]'[^', )]"lc=1           end="'"
syn region manSQString          start="^'[^', )]"lc=1               end="'"
syn region manBQString          start="[^a-zA-Z`]`[^`, )]"lc=1      end="[`']"
syn region manBQSQString        start="``[^),']"                    end="''"
syn match  manBulletZone        transparent "^\s\+o\s" contains=manBullet
syn case    match
syn keyword manBullet contained o
syn match   manBullet contained "\[+*]"
syn match   manSubSectionStart  "^\*"   skipwhite nextgroup=manSubSection
syn match   manSubSection       ".*$"   contained

hi link manSectionNumber    Number
hi link manDQString         String
hi link manSQString         String
hi link manBQString         String
hi link manBQSQString       String
hi link manBullet           Special
hi manSubSectionStart       term=NONE cterm=NONE gui=NONE ctermfg=black ctermbg=black guifg=navyblue guibg=navyblue
hi manSubSection            term=underline cterm=underline gui=underline ctermfg=green guifg=green
set ts=8
  ---------------------------------------------------------------------



VimTip 168: Viewing the actual XPM data in GVIM
http://vim.sourceforge.net/tip_view.php?tip_id=

GVIM has an excellent syntax highlighting for XPM images, but sometimes it's useful to view the actual data. This can be achieved by searching for everything, type in "/." and all characters will be highlighted and therefore the old colouring is lost. To regain the normal highlighting you can search for a non-existent sequence, like "/foo".

VimTip 169: <Tab> = <C-I> and <Esc> = <C-[>
http://vim.sourceforge.net/tip_view.php?tip_id=

     An FAQ on the vim users' mailing list is whether <Tab> and <C-I>
can be mapped to different things.  The answer is no.  As I understand
it, this is a low level issue:  <Tab> and <C-I> are different names
for the same ASCII code, and there is no way for vim to tell them
apart.  Similarly, <Esc> and <C-[> are the same thing.

VimTip 170: Repeating a sequence of commands without defining a macro
http://vim.sourceforge.net/tip_view.php?tip_id=

Imagine.

You have just finished a complicated modification of a file,
involving numerous replace commands :%s/xxx/yyyy/g,
and other ex commands.

Then you realize, you have done it a little bit wrong,
and you have to begin all the operation again,
just to change one replace string, or do one more operation
"somewhere 10 commands ago".

Or you realize, you will have to do the same stuff tomorrow
with another file.

or you realize, you want to perform the same sequence
of commands, you have typed a few days ago

You should have made it a macro (normal command q),
but you haven't.

Nothing is lost yet.

You go to the command line (by typing :)
and press Ctrl+F.
(Ctrl+F in other modes scrolls the screen)

You get a temporary window, listing the history of command line.
It is possible to yank appropriate lines here,
make a new file called $VIMRUNTIME/macros/something.vim
put those lines here, edit them and save

see
:help cedit

Then you can call the macro using
:source something.vim

You might want to set variable 'history' to a higher
number then default in your vimrc file
like
:set history=300
see
:help history
:help vimrc

VimTip 171: Do you know the "g/" and "g?" commands?
http://vim.sourceforge.net/tip_view.php?tip_id=

Directly from the Vim Todo list:

7   For Visual mode: Command to do a search for the string in the marked area.
    Only when less than two lines. Use "g/" and "g?".

In other words, a way to search for visually selected text !!  :-)

"==== vsearch.vim ====

" Visual mode search

vmap g/ :call VsearchPatternSave()<cr>/<c-r>/<cr>
vmap g? :call VsearchPatternSave()<cr>?<c-r>/<cr>

function! VsearchPatternSave()
  let l:temp = @@
  normal gvy
  let @/ = substitute(escape(@@, '/\'), "\n", "\\\\n", "g")
  let @@ = l:temp
  unlet l:temp
endfunction

"==== END ====

Normally, this file should reside in the plugins directory and be automatically
sourced. If not, you must manually source this file using ':source vsearch.vim'.

In Visual mode, highlight the text for searching.  Then you can use the
default visual key mappings

g/ - search forwards
g? - search backwards

Visual searches behave like normal searches.  The 'n' and 'N' commands
work as they should, and the search history correctly records each search.
Multi-line searches behave as they should (this corrects the 'yank-only'
method mentioned in the Vim help files).  Block visual searches do not work
yet.  Hopefully, someone can figure out a way to do this easily.

I've only tested this on Win2000 and Redhat Linux 7.1.  I'm not really clear
on how the carriage returns are dealt with on other systems.

Anyway, enjoy!

VimTip 172: Using Ispell on a highlighted region
http://vim.sourceforge.net/tip_view.php?tip_id=

Suppose you would like to use Ispell to check a word or region that you've
visually highlighted.  The following macro will do the job.  Just type
Shift-Insert while in visual mode.

vnoremap <S-Insert> <C-C>`<v`>s<Space><Esc>mq:e ispell.tmp<CR>i<C-R>"<Esc>:w<CR>:! xterm -bg ivory -fn 10x20 -e ispell %<CR><CR>:e %<CR><CR>ggVG<Esc>`<v`>s<Esc>:bwipeout!<CR>:!rm ispell.tmp*<CR>`q"_s<C-R>"<Esc>

This is based on Chip Campbell's macro which uses Ispell on the whole file
(in normal mode).

noremap <S-Insert> :w<CR>:! xterm -bg ivory -fn 10x20 -e ispell %<CR><Space>:e %<CR><Space>

Carl Mueller

VimTip 173: Switch between splits very fast (for multi-file editing)
http://vim.sourceforge.net/tip_view.php?tip_id=

I am a Web developer and I use Vim as my primary editor.

Most programming projects (and Web programming projects, in particular) are spread out over multiple files, which you often want to have open concurrently. If you don't already know, Vim supports this very well! Just use:

:sp name-of-another-file-to-edit

My problems were that (1) it took too long to move between files, and (2) the files were taking up too much room on the screen.

(1) In order to move to the file in the split above my current window, I was typing Ctrl-W, Up (move up a window) Ctrl-W, _ (maximize the menu). That's four keystrokes (more if you count Ctrl and Shift), and they are all over the keyboard. To help avoid this problem, I created this mapping in my .vimrc:

map <C-J> <C-W>j<C-W>_
map <C-K> <C-W>k<C-W>_

Now I can hold down Ctrl and move between windows with the standard Vim movement keys. Much, much quicker!

(2) By default, Vim displays the current line of each minimized file, which (to me) isn't much help and takes up too much screen real estate. I use this line in my .vimrc:

set wmh=0

This sets the minimum window height to 0, so you can stack many more files before things get crowded. Vim will only display the filename.

Hope this helps those of you who are working on projects with large numbers of files you're constantly flipping through. Happy Vimming!

VimTip 174: Footnotes
http://vim.sourceforge.net/tip_view.php?tip_id=

ab (1 [1]<esc>:/^--\s/-1/<cr>o<insert><cr>Footnotes:<cr>----------<cr>[1]
ab (2 [2]<esc>:/^Footnotes\:/+2/<cr>o<insert>[2]
ab (3 [3]<esc>:/^Footnotes\:/+3/<cr>o<insert>[3]
ab (4 [4]<esc>:/^Footnotes\:/+4/<cr>o<insert>[4]
ab (5 [5]<esc>:/^Footnotes\:/+5/<cr>o<insert>[5]

VimTip 175: how to make VIM as ur default editor even without root ac.
http://vim.sourceforge.net/tip_view.php?tip_id=

hi,
if u have installed vim in your home directory somewhere
and u don't have a root account, and you want to
make VIM the default editor for anything u do.
i.e if ur using SQLplus and want to edit a sql command.
normally typing edit brings up the vi editor and not vim editor.
to solve this problem.
define these three variables in your .profile
VIM=<base directory where vim executable is placed>
VIMRUNTIME=<base direcoty where vim runtimes are kept>
EDITOR=$VIM/vim

note if u have installed vim with another name, say vim.exe then
change EDITOR=$VIM/vim to EDITOR=$VIM/vim.exe

source the .profile and viola. next time u start an editor from any
program u have the vim editor.

Njoy.

VimTip 176: Autocheckout from perforce
http://vim.sourceforge.net/tip_view.php?tip_id=

The following code automatically checks out files from perforce when the user modifies them. It first confirms the check-out with the user.

(Perforce is a commercial version control system.  I imagine this could be modified for RCS, CVS, etc., but I don't use those.)

I'm a vim newbie -- I've used vi since 1984, but just started with vim a couple days ago.  Color me impressed!  Please excuse any stupidity in the code..

Note that this function needs the "P4HOME" environment variable to be set.  I could extract it by invoking "p4 client", but I don't want to invoke p4 every time I start vim.  So I assume the user sets it in the environment.

" Set a buffer-local variable to the perforce path, if this file is under the perforce root.
function IsUnderPerforce()
    if exists("$P4HOME")
        if expand("%:p") =~ ("^" . $P4HOME)
            let b:p4path = substitute(expand("%:p"), $P4HOME, "//depot", "")
        endif
    endif
endfunction
" Confirm with the user, then checkout a file from perforce.
function P4Checkout()
   if exists("b:p4path")
        if (confirm("Checkout from Perforce?", "&Yes\n&No", 1) == 1)
            call system("p4 edit " . b:p4path . " > /dev/null")
            if v:shell_error == 0
                set noreadonly
            endif
        endif
    endif
endfunction

if !exists("au_p4_cmd")
    let au_p4_cmd=1

    au BufEnter * call IsUnderPerforce()
    au FileChangedRO * call P4Checkout()
endif

VimTip 177: Highlight matching brackets as one moves in normal mode (plugin)
http://vim.sourceforge.net/tip_view.php?tip_id=

Check out http://www.erols.com/astronaut/vim/index.html#VimFuncs for
a plugin script which highlights matching brackets.  The script has
two always-on maps:
	\[i   : start [HiMtchBrkt] mode
	\[s   : stop [HiMtchBrkt] mode
The plugin will save all user maps and options that the plugin uses and
will restore them when the mode is stopped.

VimTip 178: Making a "derived" colorscheme without copy & paste
http://vim.sourceforge.net/tip_view.php?tip_id=

Suppose there's a colorscheme that you're pretty fond of, but hate one or two particular aspects about.  For example, I love the "blue" colorscheme that ships with vim, but I find it's colors for the non-active status line to be unreadable.  Here's how to create a colorscheme which extends "blue" without copying it to a new file and editing it.

In my ~/.vim/colors, I created a "my-blue.vim" file with these contents:

"these lines are suggested to be at the top of every colorscheme
hi clear
if exists("syntax_on")
   syntax reset
endif

"Load the 'base' colorscheme - the one you want to alter
runtime colors/blue.vim

"Override the name of the base colorscheme with the name of this custom one
let g:colors_name = "my-blue"

"Clear the colors for any items that you don't like
hi clear StatusLine
hi clear StatusLineNC

"Set up your new & improved colors
hi StatusLine guifg=black guibg=white
hi StatusLineNC guifg=LightCyan guibg=blue gui=bold

That's all there is to it.

VimTip 179: Simplify help buffer navigation
http://vim.sourceforge.net/tip_view.php?tip_id=

Vim is distributed with comprehensive help system, which has basic hyperlink support -
you can press <C-]> over |some subject| or 'some option' to read more about particular term.

The following mappings simplify help buffer navigation:
pressing s(or S) will find next(previous) subject from cursor position
pressing o(or O) will find next(previous) option from cursor position
pressing Enter will jump to subject under cursor
pressing Backspace will return from the last jump

Put them into help filetype plugin (like ~/.vim/ftplugin/help.vim on UNIX).

nmap <buffer> <CR> <C-]>
nmap <buffer> <BS> <C-T>
nmap <buffer> o /'[a-z]\{2,\}'<CR>
nmap <buffer> O ?'[a-z]\{2,\}'<CR>
nmap <buffer> s /\|\S\+\|<CR>
nmap <buffer> S ?\|\S\+\|<CR>

VimTip 180: Reload your filetype/syntax plugin
http://vim.sourceforge.net/tip_view.php?tip_id=

Ever tried to write/debug your own  filetype/syntax plugin?

It's an iterative process which involves editing plugin code and testing it on some
sample file. To see changes you made in your plugin simply do :e on sample file.
This will force Vim to reload all buffer-specific files, including your plugin.

VimTip 181: get the vim patched source
http://vim.sourceforge.net/tip_view.php?tip_id=

Hi,
there has been a number of person (including) asking in the vim list how to keep up with Bram's incredible bug correction
and patch writing skills, but there is a great way to do this!
Use the cvs source which is available at http://sourceforge.net/cvs/?group_id=8
it is kept up to date and its a lot easier than applying all the patch in order.
Benoit

VimTip 182: Keep your cursor centered vertically on the screen
http://vim.sourceforge.net/tip_view.php?tip_id=

i hope i don't hear a collective 'DUH!' from around the world but i just did this and i think it's kinda cool.

in your .vimrc add...

map j jzz
map k kzz

so whenever you go up or down, vim does that and then re-centers.
obviously it doesn't work when you page up/ down.

VimTip 183: Select a buffer from those matching a pattern
http://vim.sourceforge.net/tip_view.php?tip_id=

The :bu command will take a pattern as an argument and jump to the matching buffer.  However, it's not very helpful if there is more than one buffer matching the pattern.  In that case, it will jump to the first match, which may not be what you want.  The following function and user-command will print a list of the matching buffers in the command-line area, and allow you to select one of the matching buffers by number.

"Select from buffers matching a certain pattern
"the 'pattern' argument shouldn't be prepended with a slash

function! BufSel(pattern)
   let bufcount = bufnr("$")
   let currbufnr = 1
   while currbufnr <= bufcount
      if(bufexists(currbufnr))
         let currbufname = bufname(currbufnr)
         if(match(currbufname, a:pattern) > -1)
               echo currbufnr . ":      ". bufname(currbufnr)
         endif
      endif
      let currbufnr = currbufnr + 1
   endwhile
   let desiredbufnr = input("Enter buffer number: ")
   if(strlen(desiredbufnr) != 0)
      exe ":bu ". desiredbufnr
   endif
endfunction

"Bind the BufSel() function to a user-command
command! -nargs=1 Bs :call BufSel("<args>")

VimTip 184: How to obscure text instantaneously
http://vim.sourceforge.net/tip_view.php?tip_id=

Hi,
Lets say your writing some imp. doc. and your colleague
comes along. you don't wan't him to see what you are typing.
so u start fumbling to type :wq! or switch with Alt-TAB. etc.
but wouldn't it be nice to just obsucre the text temporarily,
so that u don't have to quit or swith to another application using Alt-tab.
(and if u don;t have any other window open u can;t even use alt-tab)
well rot-13 comes to help. vim has a built in rot-13 encoder.

jut put the follwoing in your .vimrc

map <F3> ggVGg?

so next time some body comes along just press <F3> and all the buffer will
be rot-13 encoded. to decode just press <f3> again.
Njoy

VimTip 185: Make vim the editor for files with unregistered extensions in Windows
http://vim.sourceforge.net/tip_view.php?tip_id=

Normally in Windows, if you try to "launch" a file whose extension is not registered with the system, the OS will prompt you for what editor you would like to use to open the file.  A much more appealing solution, in my mind, is to make vim the default editor for any unregistered extension.

To set vim up as the default editor for unregistered extensions, follow these steps:
1. Copy the following into a file named unregistered.reg
-------------begin unregistered.reg-----------------
REGEDIT4
[HKEY_CLASSES_ROOT\Unknown\shell\Open\Command]
@="d:\\program files\\vim\\vim60\\gvim.exe \"%1\""
-------------end unregistered.reg-----------------

2. Import unregistered into your registry.  This can be done in vim by executing the following
:!regedit "unregistered.reg"

Disclaimer: This has been tested only on NT4.

VimTip 187: Making search powerful
http://vim.sourceforge.net/tip_view.php?tip_id=

(Sorry, I think I accidentally added an incomplete tip)

My tip is just a bunch of mappings that can be used while searching.
What it does?
  o. Extend your current search. (kinda emacs search where you can search each occurences
      one by one and go back to the cursor position.
  o. Scroll/position during mapping.
  o. Other miscellaneous stuffs ;) read on

How to use?
   o. copy and paste the mappings into a file
   o. open vim (like vim .profile)
   o. :so <saved-file>
   o. start using the mappings

Note:
   In case these mappings dont work run like, 'vim -u NONE -U NONE -c "so the-saved-file.vim"'

   Some of my mappings override the default vim bindings. (like Ctrl-A, Ctrl-Q). I
   selected those because, I feel by taking those I can do all the search stuff with
   my left hand.

   One thing I did not like with this is, I usually miss the "search hit bottom" message. I could have
   handled that by complicating the current mappings, but I preferred to make it simple

Mappings Used
/          => regular forward search start
?         => regular backward search start
Rest of the mappings are used during search
Ctrl-A  => search again forward (In normal mode, search forward with the word under cursor)
Ctrl-Q  => search again backward (in normal mode, search backward with the word under cursor)
Ctrl-X  => restore cursor (use at any point of time/during-any-operation mentioned during searching)
Ctrl-F  => search with the word under cursor
Ctrl-G  => incrementally add the letters following the search pattern (in current line)
Ctrl-T Ctrl-T => search for the exact
Ctrl-T Ctrl-Y => search partial (just strips \< and \>)
Ctrl-E  => scroll up during searching
Ctrl-Y  => scroll down during searching
Ctrl-Z Ctrl-Z => position the cursor to mid of screen (like zz in normal)
Ctrl-Z Ctrl-A => position the cursor to top of screen (like zt in normal)
Ctrl-Z Ctrl-X => position the cursor to bottom of screen (like zb in normal)

Misc:
Ctrl-K during search save the current matching line
Ctrl-K in normal mode pastes the saved line

C mappings
Ctrl-V Ctrl-G search for the global variable of the search pattern/word under cursor
Ctrl-V Ctrl-H search for the local variable of the search pattern/word under cursor

" --- cut n paste from here to end of document ---
se nocp incsearch
" core mappings
noremap  / mg/
noremap  ? mg?
ounmap /
ounmap ?
noremap <C-A> mg"gyiw/<C-R>g
cnoremap <C-A> <CR>/<Up>
cnoremap <C-X> <CR>`g
cnoremap <C-Q> <CR>?<Up>

" extending current search mappings
cnoremap <C-F> <CR>yiw<BS>/<C-R>"
cnoremap <C-G> <CR>y/<Up>/e+1<CR><BS>/<C-R>=escape(@",'.*\/?')<CR>

" miscellaneous: copy current line during search and later paste in NORMAL mode
cnoremap <C-K> <CR>"hyy?<Up><CR>/<Up>
noremap <C-K> "hp

" exact/partial search mappings
cnoremap <C-T><C-T> <Home>\<<C-End>\>
cnoremap <C-T><C-Y> <Home><Del><Del><End><Del><Del>

" C global/local variable search mappings
noremap <C-V><C-G> mgyiw<CR>gg/\<<C-R>"\>
noremap <C-V><C-H> mgyiw?^{<CR>/\<<C-R>"\>
cnoremap <C-V><C-G> <CR>yiwgg/\<<C-R>"\>
cnoremap <C-V><C-H> <CR>yiw?^{<CR>/\<<C-R>"\>

" positioning/scrolling during search mappings
cnoremap <C-E> <CR>mt<C-E>`t<BS>/<Up>
cnoremap <C-Y> <CR><C-Y><BS>/<Up>
cnoremap <C-Z><C-A> <CR>zt<BS>/<Up>
cnoremap <C-Z><C-X> <CR>zb<BS>/<Up>
cnoremap <C-Z><C-Z> <CR>zz<BS>/<Up>

" VISUAL mappings
vnoremap / ymg/<C-R>=escape(@",'.*\/?')<CR>
vnoremap ? ymg?<C-R>=escape(@",'.*\/?')<CR>

VimTip 188: Searching for more than one word at the same time.
http://vim.sourceforge.net/tip_view.php?tip_id=

Did you know that with VIM u can search for more
than one word with a single command.
say you want to search all occurances of "bill" or "ted", or
"harry" in a text.
in normal mode do the following.
/\(bill\)\|\(ted\)\|\(harry\) <Enter>

this will match all instances of either "bill", or "ted", or "harry" in your
text. the key is the \(\) and \| operators.
\(\) group characters in a word and \| is for ORing.

this is so cool u can even use it for replacing text.
to replace all instances of "bill" or "ted" or "harry" with "greg"
do the following
:%s/\(bill\)\|\(ted\)\|\(harry\)/greg/g <enter>
(note :- if u have set the option "gdefault" u don't need the "g" at the
end of the above command)

I don't know of any other editor which can do this, with so much ease.
Rock on VIM
Njoy

VimTip 189: Make Ctrl-Backspace delete previous word (like GTK inputs)
http://vim.sourceforge.net/tip_view.php?tip_id=

Stuff this into your ~/.gvimrc and then you'll be able to type Control-Backspace to delete the previous word.  I had gotten so used to C-BS working a certain way in all my editors with a ceezy input area (like mozilla/galeon, gabber, etc...), that I wanted the same behaviour when I used gvim.

" map control-backspace to delete the previous word
:imap <C-BS>        <Esc>vBc

Simple, I know, but reasonably useful.

--Robert

VimTip 190: XP > I-Explorer > HTML Editor < REG files
http://vim.sourceforge.net/tip_view.php?tip_id=

The issue is permitting other programs, besides NOTEPAD,
be the HTML editor under Internet Explorer.
(Adding "Edit" as a New Action in the publicly exposed
Files Types for HTM/L does NOT do the job.)

Given below are two REG files for vim.
Just cut 'em up where indicated.
They have been tested under Windows XP.

-------------------------------------------------------CUT HERE---------------
Windows Registry Editor Version 5.00

; GOAL: Set gvim as HTML editor in Internet Explorer 6.0
; Vim version : 6.0
; Windows version: XP
; EASY USAGE: name this file iex-vim60.reg and double click on it
; Hard Usage: IMPORT this file using REGEDIT.EXE found in c:\WINDOWS
; Last modified date : Dec 16, 2001

; gvim is expected in "C:\Program Files\Vim\vim60\gvim.exe"
; Be sure to also reset Explorer>Tools>Internet Options>Programs

; Microsoft documentation
; http://msdn.microsoft.com/workshop/browser/configuration/clientreg/clientregistrylayout.asp

; Add Vim in the list of supported HTML editors
[HKEY_CLASSES_ROOT\.htm\OpenWithList\Vim]

[HKEY_CLASSES_ROOT\.htm\OpenWithList\Vim\shell]

[HKEY_CLASSES_ROOT\.htm\OpenWithList\Vim\shell\edit]

[HKEY_CLASSES_ROOT\.htm\OpenWithList\Vim\shell\edit\command]
@="\"C:\\Program Files\\Vim\\vim60\\gvim.exe\" \"%1\""

; Do NOT add to .html, registry for .htm type suffices
;[HKEY_CLASSES_ROOT\.html\OpenWithList\Vim]

;[HKEY_CLASSES_ROOT\.html\OpenWithList\Vim\shell]

;[HKEY_CLASSES_ROOT\.html\OpenWithList\Vim\shell\edit]

;[HKEY_CLASSES_ROOT\.html\OpenWithList\Vim\shell\edit\command]
;@="\"C:\\Program Files\\Vim\\vim60\\gvim.exe\" \"%1\""

; OPTIONAL: Within Internet Explorer "View Source" with gvim
; but prefer to use Edit button (got to add this) on Toolbar
;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Internet Explorer\View Source Editor]

;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Internet Explorer\View Source Editor\Editor Name]
;@="C:\\Program Files\\Vim\\vim60\\gvim.exe"

; ============================================= EOF

-------------------------------------------------------CUT HERE---------------
Windows Registry Editor Version 5.00

; GOAL: UNINSTALL gvim as HTML editor in Internet Explorer 6.0
; Vim version : 6.0
; Windows version: XP
; EASY USAGE: name this file iex-vim60-uninstall.reg and double click on it
; Hard Usage: IMPORT this file using REGEDIT.EXE found in c:\WINDOWS
; Last modified date : Dec 16, 2001

; gvim is expected in "C:\Program Files\Vim\vim60\gvim.exe"
; Be sure to also reset Explorer>Tools>Internet Options>Programs

; Microsoft documentation
; http://msdn.microsoft.com/workshop/browser/configuration/clientreg/clientregistrylayout.asp

[-HKEY_CLASSES_ROOT\.htm\OpenWithList\Vim]

[-HKEY_CLASSES_ROOT\.html\OpenWithList\Vim]

[-HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Internet Explorer\View Source Editor]

; ============================================= EOF
-------------------------------------------------------CUT HERE---------------

Happy Vimming...

VimTip 191: Transposing
http://vim.sourceforge.net/tip_view.php?tip_id=

You can easily move lines with these maps using <C-Up> and <C-Down> (only in GUI version :( )
(Works in normal, insert, and visual mode, but you can't add a count to them)
" Transposing lines
nmap <C-Down> :<C-u>move .+1<CR>
nmap <C-Up> :<C-u>move .-2<CR>

imap <C-Down> <C-o>:<C-u>move .+1<CR>
imap <C-Up> <C-o>:<C-u>move .-2<CR>

vmap <C-Down> :move '>+1<CR>gv
vmap <C-Up> :move '<-2<CR>gv

" Transpose chars (like Ctrl-T in emacs, shell...)
imap <C-F> <Esc>Xpa

VimTip 192: Latex Help for VIM
http://vim.sourceforge.net/tip_view.php?tip_id=

LaTeX Help for aucTeX `translated' as vim help file.

Installing

:help add-local-help

VimTip 193: Insert the current filename at cursor postion.
http://vim.sourceforge.net/tip_view.php?tip_id=

I found this one good for when I was starting to learn Java, it simply inserts the current filename, at the cursor position, when you are in insert mode.  Honestly, its a mish-mash of some other tips I found here, but I thought it might be useful.

imap \fn   <C-R>=expand("%:t:r")<CR>

Enjoy!

VimTip 194: Inserting text in multiple lines
http://vim.sourceforge.net/tip_view.php?tip_id=

Do you know the I key in visual-block mode?

Suppose you have
let a=2
let b=3
let c=4

You want to make these variables script-wise. Then you move to over a, hit <C-v>, press jj and now press I.
You will be in insert mode before a
Now enter s:<Esc>, and when you press <Esc>, b and c will have the s: prefix too.
See |v_b_I|

Happy vimming!
Gergely Kontra

VimTip 195: Switching between files
http://vim.sourceforge.net/tip_view.php?tip_id=

When you edit multiple files, you often need to change windows.
You can set up vim in windows and gvim to switch between windows with the commonly used Ctrl-Tab and Ctrl-Shift-Tab
The mappings
nmap <C-Tab> <C-w>w
nmap <C-S-Tab><C-w>W
(They wrap around)
See also |Ctrl-w|

VimTip 196: FileName Completion in Shell Scripts
http://vim.sourceforge.net/tip_view.php?tip_id=

In shell scripts, you often define environment variables for diff directory names.
i.e.
JAVA_HOME=/opt/java/jdk1.4
PATH=/usr/local/bin:/bin....

Normally typing Ctrl-X Ctrl-F is used to complete FileName under cursor.
But this does not work if used on lines given above.
This is because vim treats "=" sign as a valid filename character.
Since the actual possibility of "=" being in any filename is very less, this
char can be removed from the list of valid filename char.

set isfname-==

putting the above line in .vimrc will remove "=" from the list of valid filename chars.
thus u can easyly complete filenames using <Ctrl-X> <Ctrl-F>
Njoy

VimTip 197: Open file in already running vim from elsewhere
http://vim.sourceforge.net/tip_view.php?tip_id=

If you want edit new file, and you  want do it  in alrady running vim, instead of launching another instance, you may use --remote argument:

gvim first_file
gvim --remote +split first_file

:he --remote
It requires X windows (but works in terminal version of vim there too) or MS windows and built-in client-server mechanism. If there are several instances of vim already running, you may choose to which you talk using --servername
:help --servername

VimTip 198: Pasting code with syntax coloring in emails
http://vim.sourceforge.net/tip_view.php?tip_id=

When sending code snippets or diffs to your colleagues either for code review or for something else as email, how nice and clear it will be if you can paste it with the Vim syntax highlighting? I am sure they will be impressed and feel much easier to read the code. It is also very easy and fast (once you practice it) to do this.

This probably works only on windows and requires you to use Internet Explorer and an email client that understand RTF content coming from clipboard, such as Outlook or Outlook Express. At least that would make the process faster. I haven't tried on any other combination though. This is what you need to do:

- Open the file containing the code/code snippet/diff etc. in gvim. If you use dark background for GVim (like me), then I would suggest you to change your color scheme temporarily to something else that has a white background or just use the "-U NONE" as below:

    gvim -U NONE <file>

- Convert the file into HTML by using the following command at the colon prompt as below:

    :runtime syntax/2html.vim

- The above step will open a new window with the HTML content in it. You might want to just save it with the suggested name or write into a temporary file as:

    :w! c:/tmp/t.html

- Open the IE browser window and open the above temp file "c:/tmp/t.html".
- Now you select all (press ^A) and copy it (^C).
- You are ready to paste it with syntax coloring in any application that accepts RTF content from clipboard, including Outlook or Outlook Express mail composing window.

VimTip 199: maximize window and return to previous split structure
http://vim.sourceforge.net/tip_view.php?tip_id=

Say you have layed out a complex window split structure, and want to temporarily open 1 window with max dimensions, but don't want to lose your split structure.  The following function and mappings let you toggle between the split windows and on window maximized. The mappings prevent the default behavior of calling :only and losing your finely tuned splits.

Put this bit in your vimrc file, change mappings if you don't want to override the defaults:

nnoremap <C-W>O :call MaximizeToggle ()<CR>
nnoremap <C-W>o :call MaximizeToggle ()<CR>
nnoremap <C-W><C-O> :call MaximizeToggle ()<CR>

function! MaximizeToggle()
        if exists("s:maximize_session")
                source s:maximize_session
                call delete(s:maximize_session)
                unlet s:maximize_session
                let &hidden=s:maximize_hidden_save
                unlet s:maximize_hidden_save
        else
            	let s:maximize_hidden_save = &hidden
                let s:maximize_session = tempname()
                set hidden
                mksession! s:maximize_session
                only
        endif
endfunction

VimTip 200: Bouncing Parentheses (during insertion)
http://vim.sourceforge.net/tip_view.php?tip_id=

When one is inserting parentheses some folks like to see the cursor
bounce off the matching parenthesis.  To do that, put the following
map into your <.vimrc> file:

    inoremap ) )<c-o>%<c-o>:sleep 500m<CR><c-o>%<c-o>a

Adjust the time delay (its 500 milliseconds above) to suit your needs.

VimTip 201: The meaning of life
http://vim.sourceforge.net/tip_view.php?tip_id=

Use this tip if you need to discover the meaning of life, the universe and everything.

Simply do:
:h 42

VimTip 202: debugging window autocommands
http://vim.sourceforge.net/tip_view.php?tip_id=

Don't know how people debug autocommands, but I just found out that you can debug (at least) those that result due to window close by just doing a debug quit, i.e.,

:debug quit

Vim will let you step into the autocommands. Try it to believe.

VimTip 203: Make make more helpful
http://vim.sourceforge.net/tip_view.php?tip_id=

I find this a very useful command to use.
Add the below 4 lines to your vimrc.
Then instead of "make" use "Make".

" Command Make will call make and then cwindow which
" opens a 3 line error window if any errors are found.
" if no errors, it closes any open cwindow.
:command -nargs=* Make make <args> | cwindow 3

VimTip 204: Some mappings for using cscope with vim.
http://vim.sourceforge.net/tip_view.php?tip_id=

These mappings can make using cscope a fun. You can copy the word under the cursor in one window, and search for it from other window.

" Copy and paste the word under cursor
map <silent> <C-Space> :let@m=expand("<cword>")<CR>

" Use the C-Space word as the search criterion
map <C-F6> :cscope find s <C-R>=@m<CR><CR>
map <C-F5> :cscope find c <C-R>=@m<CR><CR>
map <C-F7> :cscope find g <C-R>=@m<CR><CR>

VimTip 205: Computing a sum of numbers in vim
http://vim.sourceforge.net/tip_view.php?tip_id=

"Sometimes you need to sum a some numbers in vim.  There *are* some plugins
"that can do the job.  But what if the numbers are not in a columns or are on
"the same line or are sacttered all across the file? You might also need to
"sum all the numbers in file that look like '1234$', or '54565 Eu'  ignoring others.
"
"There is a very simple trick, using (my favourite) command
":s
"
"First you define following function

:let g:S=0 		"In global variable S we later find the result

:function! Sum(number)		"The function is defined with a '!',
				"so it does not complain during debugging
				"when you are redefining the function
	:let g:S=g:S+a:number	"we accumulate the result in global variable S
	:return a:number	"function returns the argument, so after a :s
				"command the text remains the same
:endfunction

"you can do issue those few commands from a command line,
"or create a small file and put it into your plugin directory,
"or write those few commands into a file end issue a command :so %

"how to use this little function:
"let's suppose you have a simple column of numbers like
"
"10
"20
"30
"
"you issue command like:
:let S=0
:%s/[0-9]\+/\=Sum(submatch(0))/
"the command finds the first number on the line and adds it to the S
"
"the result is displayed
:echo $S

"!!!! don't forget to do
:let g:S=0
"before use.

"you can also use \zs and \ze atoms in a regular expression to
"delimit the number, so submatch(0) returns only a number and
"the text remains unchanged after 'substitute'

"for starter on the wonderfull world of regular expressions see:
:help usr_27.txt

"for the definition of the search pattern see
:help :s
:help pattern

"for replacement strings begining with \= and special function submatch(0)see
:help sub-replace-special

"for the *ultimate* guide through the world of regular expressions see book:
"Mastering Regular Expressions
"Powerful Techniques for Perl and Other Tools
"by Jeffrey E.F. Friedl
"from O'REILLY

"the book does not write about vim, yet here you can learn that
":s command is the most powerfull command you can find in a text editor.
"(with the possible exception of :global command)

VimTip 206: Highlight doubled word errors in text
http://vim.sourceforge.net/tip_view.php?tip_id=

An error I sometimes make while working on a LaTeX file is the repetition of a
word as in "the the". Most often, such doubled words come about through a
careless edit. Doubled words are hard to spot when the first word of the
doubled pair is the last word on one line, and the second word of the pair is the
the first word on the next line. There is an example of such an error in the last
sentence. Vim's syntax mechanism can be used to highlight doubled words as an error.

To obtain this highlighting for TeX and LaTeX files, place the following two lines:

       syn match texDoubleWord "\c\<\(\a\+\)\_s\+\1\>"
       hi def link texDoubleWord Error

in a file called tex.vim in the directory that shows up last in your
runtimepath (:set runtimepath? to check). This will often be
either ~/.vim/after/syntax/tex.vim or $VIM/vimfiles/after/syntax/tex.vim

The same effect can be obtained for files of a different filetype, say html,
by putting the same lines in a file called html.vim in the same location.

For more on the runtimepath, :he runtimepath.
For more on syntax highlighting, :he syntax

VimTip 207: editing databases with Vim/Perl/DBI
http://vim.sourceforge.net/tip_view.php?tip_id=

Perl's Data-Base-Independent (DBI) module provides programming language level
access to a lot of databases.

Vim hosts an embedded Perl interpreter. So it is only a matter of some key
strokes to interactively issue DB commands from within Vim or to search, edit,
and replace database contents including retrieval and storage. Of course
"create table" scripts can be worked upon in Vim as well as storing recurring
patterns in Vim functions or Perl modules.

Prerequisites: Vim needs to be compiled with Perl support enabled. See the
|if_perl.txt| manual page! The CPAN module DBI as well as an appropriate
database driver has to be installed with Perl in order to execute these Vim
commands:

" connect to perl's dbi module:
:perl use dbi;

" connect to the database:
:perl $dbh = dbi->connect( "DBI:mysql:$DBNAME:$HOST",$USER,$PASSWORD,
                                        { raiseerror => 1});

" perform a simple query:
:perl $result = $dbh->selectall_arrayref("show tables;");

" insert the list of tables into the current buffer's top:
:perl $curbuf->Append(0, map($_->[0], @{$result}));

In MySql the command "show tables;" results in a list of table names. Inserted
into a Vim buffer this results in one line per table.

You can find more on my web page
http://members.chello.at/intelliware/dbEdit

VimTip 208: Alter the display of buffers in the buffers menu
http://vim.sourceforge.net/tip_view.php?tip_id=

If you use the buffers menu, here's where you can change how the buffernames are displayed:

menu.vim, function s:BMMunge

OLD:   let name2 = name2 . ' (' . a:bnum . ')'

displays:


  .vimrc (1)
  menu.vim (2)

NEW:    let name2 = '&' . a:bnum . '. ' . name2

displays


  1. .vimrc
  2. menu.vim
(with the 1 and the 2 underlined)

which is more useful, because you can (almost) always pick the buffer you want with one keystroke, the buffernumber, until you get to buffer 10 anyway.

Roger

VimTip 209: backtracking your movements in a file
http://vim.sourceforge.net/tip_view.php?tip_id=

If you are jumping from one line to another a lot.
You may find the "Ctrl-o" command handy.
Usually u can set markers in a buffer to keep track of your
movements.
but Ctrl-o makes it even easier. it takes you back sequentially to
all your previous cursor locations in a buffer.
just press ctrl-o in normal mode and u will go to your last cursor position.

Njoy

VimTip 210: compiling the actual file with gcc
http://vim.sourceforge.net/tip_view.php?tip_id=

if you use  set makeprg=gcc\ -o\ %<\ % in your .vimrc, and your actual file is file.c,  then :make will compile file.c with the output file. (gcc file.c -o file).

VimTip 211: Rotate color themes
http://vim.sourceforge.net/tip_view.php?tip_id=

This tip is for those who like to change their vim color themes pretty often.  I like different themes just for a change in my work environment.  To achieve this just add the following to your .vimrc or _vimrc file.

let themeindex=0
function! RotateColorTheme()
	let y = -1
	while y == -1
		let colorstring = "#blue.vim#elflord.vim#evening.vim#koehler.vim#murphy.vim#pablo.vim#ron.vim#"
		let x = match(colorstring,"#",g:themeindex)
		let y = match(colorstring,"#",x+1)
		let g:themeindex = x+1
		":echo x y g:themeindex
		if y == -1
			let g:themeindex = 0
		else
			let themestring = strpart(colorstring,x+1,y-x-1)
			echo("Setting Theme to-> ".themestring)
			return ":so $VIMRUNTIME/colors/".themestring
		endif
	endwhile
endfunction

Change the value of colorstring above by changing the line
let colorstring = "#blue.vim#elflord.vim#evening.vim#koehler.vim#murphy.vim#pablo.vim#ron.vim#"
You can add your favorite color themes in this string so that you can rotate between them.  Just make sure that any string that you add is in between the # as shown above.  Just follow the format above and things will work.

Then assign a key to roate the theme.
map <F8> :execute RotateColorTheme()

Dunno if there are better ways to do the same.  I just did a "help eval" and wrote the above.

VimTip 212: Setting file attributes without reloading a buffer
http://vim.sourceforge.net/tip_view.php?tip_id=

While creating scripts and others executable files with Vim it is needed to set UNIX executable bit on the file.
You can do this from inside Vim with :!chmod a+x %. The % represents current buffer's filename.
The problem is that Vim will notice attribute changes and prompt you to reload a file. If you do this, your undo history for the file will be lost.

The following function facilitate changing executable attributes without reloading a buffer.
Thanks to Bram for the algorithm for this function.

fun! SetExecutableBit()
	let fname = expand("%:p")
	:checktime
	exec "au FileChangedShell " . fname . " :echo"
	:silent !chmod a+x %
	:checktime
	exec "au! FileChangedShell " . fname
endfun

" Create an EX command that will call the function.
command -nargs=0 Xbit call SetExecutableBit()

Now you can type :Xbit to make the file executable!

VimTip 213: delet all lines containt TXT
http://vim.sourceforge.net/tip_view.php?tip_id=

I needed this one when I was editing an ldif file:

I needed to delete all lines containing "profile":

:g/profile/d

very handydandy

VimTip 214: Current buffer based menus
http://vim.sourceforge.net/tip_view.php?tip_id=

If you have different menus for different filetypes, and you want to have only the menu relevant to current buffer displayed, you can use this approach:

in .vimrc:
au BufEnter * if exists('b:BuffEnter')|exec b:BuffEnter|endif
au BufLeave * if exists('b:BuffEnter')|exec b:BuffLeave|endif

In appropriate ftplugin/?.vim, there are assigned commands to create or destroy the menus - here typed in directly, may be of course call to a menu-generating function or whatever.

let b:BuffEnter='amenu C.added ...'
let b:BuffLeave='unmenu! C|unmenu C'

VimTip 215: Edit configuration files for a filetype
http://vim.sourceforge.net/tip_view.php?tip_id=

When you open a file, vim may load several scripts to customize itself for editing the file type the file is associated with (for example a file "test.c" is associated with the filetype "c").
Such configurations include the setting of syntax highlighting colors (:help syntax) and support for indentation (:help filetype-indent-on).
When you start to override these files for yourself, it can sometimes be confusing, which file sets a specific option.
The following function can be used, to edit the configuration files which are associated with a specific filename. It open a buffer for all files which get loaded.
If I invoke it with ':call Edit_ft_conf("test.c")', for example, I end up with the following buffers / windows:
  1  a   "[No File]"                    line 1
  2  a   "test.c"                       line 1
  3  a=  "/usr/local/share/vim/vim60/syntax/c.vim" line 1
  4  a   "~/.vim/after/syntax/c.vim"    line 1
  5 #a=  "/usr/local/share/vim/vim60/indent/c.vim" line 1
  6 %a=  "/usr/local/share/vim/vim60/ftplugin/c.vim" line 1

Here comes the function:

" Edit filetype configuration files
" Usage: ':call Edit_ft_conf("file")'
" Purpose: open all scripts which get loaded implicitly by opening "file"
"   (syntax highlighting, indentation, filetype plugins, ..)
"   The order of windows reflects the order of script loading (but "file" is
"   the topmost window)
fun! Edit_ft_conf(name)
    " we may not do this with a loaded file, since this won't trigger the
    " configuration file loading as desired.
    " try calling with 'call Edit_ft_conf("nonexistingfile.<EXT>")' if this
    " gives you troubles
    if bufexists(a:name) && bufloaded(a:name)
        echo "!Attention: buffer for " . a:name . " is loaded, unload first."
        return
    endif
    " split-open the file with verbose set, grab the output into a register
    " (without clobbering)
    let safereg = @u
    redir @u " redirect command output to register @u
    exec "silent 2verbose split " . a:name
        " verbose level 2 suffices to catch all scripts which get opened
    redir END
    " Parse register @u, looking for smth like: 'sourcing"/usr/local/share/vim/vim60/syntax/c.vim"'
    let pos = 0
    let regexp = 'sourcing "[^"]\+"'
    while match(@u,regexp,pos) >= 0
        let file = matchstr(@u,regexp,pos)
        let pos = matchend (@u,regexp,pos)
        let file = strpart(file,10,strlen(file)-11)
        exec "silent below split " . file
    endwhile
    " restore the register
    let @u = safereg
endfun

VimTip 216: calculate equations from within vim
http://vim.sourceforge.net/tip_view.php?tip_id=

The following map and function calculates equations using the program 'bc' (found on most linux systems, available for most systems).  Visually select the equation you want to calculate, then hit ;bc - if the selection ends with an '=' sign, the answer will be appended after the equal, otherwise, the answer is echoed as a message.  The code to put in a vimrc and source is at the end.

Equations can span multiple lines, and the full bc syntax is probably supported.  Additionally, sin (), cos (), etc, are transformed into the names used by bc (s () c (), etc).

Here are some example lines:

2 * sqrt (2) =

3 * (2 - 1) + 4.0 ^ 6 =

4 / 3 =

3 +
   4 -
      2 * (1 / (3 + 2)) =

define rad (x) {
  return (x / 180) * 4 * atan (1)
}
cos (rad (45)) =

Select each of these in turn (continguous non-blank lines, and hit ;bc for each), and this is what you get:
2 * sqrt (2) = 2.82842712474619009760

3 * (2 - 1) + 4.0 ^ 6 = 4099.000000

4 / 3 = 1.33333333333333333333

3 +
   4 -
      2 * (1 / (3 + 2)) = 6.60000000000000000000

define rad (x) {
  return (x / 180) * 4 * atan (1)
}
cos (rad (45)) = .70710678118654752440

Fun, no?  Here is the code you need to put in your vimrc file:

vnoremap ;bc "ey:call CalcBC()<CR>
function! CalcBC()
	let has_equal = 0

	" remove newlines and trailing spaces
	let @e = substitute (@e, "\n", "", "g")
	let @e = substitute (@e, '\s*$', "", "g")

	" if we end with an equal, strip, and remember for output
	if @e =~ "=$"
		let @e = substitute (@e, '=$', "", "")
		let has_equal = 1
	endif

	" sub common func names for bc equivalent
	let @e = substitute (@e, '\csin\s*(', "s (", "")
	let @e = substitute (@e, '\ccos\s*(', "c (", "")
	let @e = substitute (@e, '\catan\s*(', "a (", "")
	let @e = substitute (@e, "\cln\s*(", "l (", "")

	" escape chars for shell
	let @e = escape (@e, '*()')

	" run bc, strip newline
	let answer = substitute (system ("echo " . @e . " \| bc -l"), "\n", "", "")

	" append answer or echo
	if has_equal == 1
		normal `>
		exec "normal a" . answer
	else
		echo "answer = " . answer
	endif
endfunction

VimTip 217: Translate &#nnn; in html source to readable ascii
http://vim.sourceforge.net/tip_view.php?tip_id=

I found a website *cough*Tivoli.com*cough* that likes to obfuscate some of its help file web pages using &#nnn; instead of normal ascii.  If you load the source with Vim (in Opera you can just designate Vim as your source viewing program), you can :so the following code to make it readable.

let n = 32
while n < 127
    if n == 38
        silent! exec '%s/&#38;/\&amp;/g'
    elseif n == 47
        silent! exec '%s/&#47;/\//g'
    else
        silent! exec '%s/&#' . n . ';/' . nr2char(n) . '/g'
    endif
    let n = n + 1
endwhile

Disclaimer: I hacked this together in about 10 minutes (or possibly longer :).  It worked suitably for the website I wrote it for (or possibly "against" :).  Your Milage May Vary.

See :help eval, :help silent, :help exec, :help :s

VimTip 218: Check for comments, independent of the filetype
http://vim.sourceforge.net/tip_view.php?tip_id=

For some scripts it might be useful to detect, whether a specific position in a buffer is inside
of a comment or not. Syntax highlighting can save us the work for parsing the comments ourselves.

The command
  :echo synIDattr(synIDtrans(synID(line("."), col("."), 0)), "name")
echoes the group used for *highlighting* the character at the current cursor position, see ':help synIDtrans()'. It will usually be "Comment" if the cursor is inside of a comment, so
   synIDattr(synIDtrans(synID(line("."), col("."), 0)), "name") == "Comment"
detects, independent of the filetype (which have their own group 'names' for comments), if the cursor is inside a comment or not.
The expression
  synIDattr(synIDtrans(synID(line("."), col("."), 0)), "name") =~ 'Comment\|Constant\|PreProc'
will detect additionally, if the cursor is inside of a string or some preprocessor statement.

VimTip 219: make from command line, open vim on errors
http://vim.sourceforge.net/tip_view.php?tip_id=

A simple alias (*csh) or shell function (bash) will let you run make from your shell, then automatically open vim or gvim on the errors (if there were any):

csh or tcsh:

alias Make 'make \!* |& tee make.errors || gvim -q make.errors -c :copen'

bash:

Make () { command make "$@" |& tee make.errors || gvim -q make.errors -c :copen ; }

If you use vanilla sh or ksh or even cmd.exe, you can probably do the same - add a not if you have ideas.

VimTip 220: Regexp: Match every word except 'foo'
http://vim.sourceforge.net/tip_view.php?tip_id=

This is a regular expression that matches all words except 'foo'
\v<(foo>)@!\k+>

\v 		Very magic
<		Start-of-word
(Foo>)	The atom 'Foo' followed by end-of-word
@!		Match (with zero length) when the previous atom doesn't
match.
\k+		Match one or more Keywords
>		Match end-of-word.

This is a kool example of using \@! in the middle of a regexp.
The non-magic version is:
\<\(foo\>\)\@!\k\+\>

VimTip 221: indenting "throws" in java
http://vim.sourceforge.net/tip_view.php?tip_id=

I want to indent java files like this:

    int x(int y, int z)
        throws Exception
    {
        [...]
        return something;
    }

By default vim will properly indent "throws" line, but following "{" will not be deindented back to the method declaration.

The following indentexpr does the trick:
let &indentexpr='getline(v:lnum)=~"^\\s*{" && getline(v:lnum-1)=~"^\\s*throws\\s" ? cindent(v:lnum)-&sw : cindent(v:lnum)'

It just checks that the current line starts with "{" and the previous line starts with "throws" and if that is the case, it subtracts one shiftwidth from the number returned by cindent.

VimTip 222: Building vim with color on HP-UX
http://vim.sourceforge.net/tip_view.php?tip_id=

Following the normal steps of running "./configure" and "make" to build
vim on an HP-UX 10.20 will result in vim being linked with the termlib
library.  This library does not support certain termcap capability
codes, such as the "Co" code used to query the number of colors
supported by the terminal.  Consequently, vim will not display colors
when used with a color terminal such as a color xterm.

One solution to this is to run the configure script with the
"--with-tlib=curses" option, like this:

    ./configure --with-tlib=curses

This will cause vim to be linked with the HP-UX curses library, which
does support the color termcap capability codes.

Note that the xterm that comes standard with HP-UX 10.20 does not
display color character attributes.  To see colors when running vim in a
terminal window, you will also need to install a color terminal emulator
such as a recent xterm.

VimTip 223: Reverse Selected Text
http://vim.sourceforge.net/tip_view.php?tip_id=

Suppose you want to reverse some text - I don't know why you would want to - maybe you're dyslexic.  Anyway, I had a need, so this mapping will reverse visually selected text.  Put the mapping in your vimrc or otherwise source it, then visually select the word or words, and hit ;rv - really only works with selections on one line:

vnoremap ;rv c<C-O>:set revins<cr><C-R>"<esc>:set norevins<cr>

VimTip 224: Shifting blocks visually
http://vim.sourceforge.net/tip_view.php?tip_id=

I use the < and > commands on blocks a lot, and it has always annoyed me that if you want to shift more than one 'shiftwidth', you have count how many 'shiftwidth's you want to enter the '[count]>', or restore the selection with "gv". So I've cooked up two mappings that come in very handy:

:vnoremap < <gv
:vnoremap > >gv

These mappings will reselect the block after shifting, so you'll just have to select a block, press < or > as many times as you like, and press <ESC> when you're done to unselect the block.

I know it's not rocket science, but it sure has helped me a lot.

VimTip 225: vim can interact with xdvi
http://vim.sourceforge.net/tip_view.php?tip_id=

 vim can interact with the tricks that the latest xdvi does:

 * If one clicks at some place in xdvi, vim automatically jumps to the
   corresponding line in the LaTeX source file ("reverse search")
 * Also, from inside vim, one can jump to the corresponding line in xdvi
   which becomes highlighted ("forward search").

 Here is how to do it:

 * Reverse search:
   We start a vim server by:  vim --servername xdvi
   We start xdvi(k) on file.dvi by:
      xdvik -editor "vim --servername xdvi --remote +%l %f" file.dvi
   At the desired location in xdvi, we press:   <ctrl><left_mouse>
   Then, vim will jump to the corresponding line in the source file.

 * Forward search:
   Inside vim, we type, for example,  _g  which is the following mapping:
        (the following should be a single line)

   map _g  :execute "!xdvik -name xdvi -sourceposition " . line(".") . expand("%") . " " . expand("%:r") . ".dvi" <cr><cr>

    [the command to go to the point of xdvi that corresponds to line, eg, 77
     of the source file is (no space after 77)
       xdvik -name xdvi -sourceposition 77file.tex file.dvi  ]

  For the above to work one needs:
  1) A recent version of xdvi or xdvik (>22.39 I think)
  2) The package srcltx.sty and \usepackage{srcltx} (which should  be
     commented out when one finishes and is ready for printing etc).
  3) Our version of vim should have been compiled with +clientserver
     (however, my vim doesn't have it and still works, so try it before
      Bram finds out what is happening and fixes it)

VimTip 226: Edit file under cursor after a horizontal split
http://vim.sourceforge.net/tip_view.php?tip_id=

I use the command 'gf' quite often. But with this command the current buffer is hidden. To avoid that I use the following mapping :

map gw <Esc>:sp %<CR> gf

With this mapping the file under the cursor is opened after a horizontal split.

VimTip 227: Power of :g
http://vim.sourceforge.net/tip_view.php?tip_id=

:g is something very old and which is very powerful. I just wanted to illustrate the use of it
with some examples. Hope, it will be useful for someone.

Brief explanation for ":g"
-------------------------
Syntax is:
    :[range]:g/<pattern>/[cmd]
You can think the working as, for the range (default whole file), execute
the colon command(ex) "cmd" for the lines matching <pattern>. Also, for all
lines that matched the pattern, "." is set to that particular line (for
certain commands if line is not specified "." (current line) is assumed).

Some examples
-------------
Display context (5 lines) for all occurences of a pattern
    :g/<pattern>/z#.5
    :g/<pattern>/z#.5|echo "=========="
    << same as first, but with some beautification >>
Delete all lines matching a pattern
    :g/<pattern>/d
Delete all blank lines (just an example for above)
    :g/^\s*$/d
Double space the file
    :g/^/pu =\"\n\"
    :g/^/pu _
    << the above one also works >>
Copy all lines matching a pattern to end of file
    :g/<pattern>/t$
Yank all lines matching a pattern to register 'a'
    0"ay0:g/<pattern>/y A
Increment the number items from current line to end-of-document by one
    :.,$g/^\d/exe "normal! \<c-a>"
Comment (C) lines containing "DEBUG" statements
    g/^\s*DEBUG/exe "norm! I/* \<Esc>A */\<Esc>"
A Reverse lookup for records
(eg: An address book, with Name on start-of-line and fields after a space)
    :g/<patern>?^\w?p               "if only name is interested
    :g/<patern>/ka|?^\w?p|'ap       "if name and the lookup-line is interested
    :g/<patern>/?^\w?|+,/^[^ ]/-1p  "if entire record is interested
Reverse a file (just to show the power of 'g')
    :g/^/m0

Foot note 1: use :v to negate the search pattern
Foot note 2: Some explanation of commonly used commands with :g
 :2,8co15 => Copy lines 2 through 8 after line 15
 :4,15t$  => Copy linesa 4 through 15 towards end of document (t == co)
    :-t$  => Copy previous line to end of document
     :m0  => Move current line to the top of the document
:.,+3m$-1 => Move current line through cur-line+3 to the last but one line
             of the document
Foot note 3: Commands used with :g are ex commands, so a help search should
             be,
                :help :<help-topic>
                eg. :help :k

VimTip 228: Deleting nested reply threads in emails
http://vim.sourceforge.net/tip_view.php?tip_id=

I find the following setting useful when replying to email threads that have lots of lines like the following:
> blah
> > blah
> > > blah

autocmd FileType mail map <F8> :%g/^> >/d<CR>

When replying to a mail and you want to remove everything except what the person you are directly replying to wrote just press F8.
From the example above, you would just be left with
> blah

What it does is simply match any line starting with > > and deletes it.  It's not perfect as sigs and other debris may remain but it takes a lot of the grunt work out of replying to mails.
The autocmd only maps F8 when using mails, this is handy if you use F8 for other things as I do.

:help autocmd
:help map
:help :g

VimTip 229: First thing to try before asking help
http://vim.sourceforge.net/tip_view.php?tip_id=

I've seen several questions asked in the reflector which is available in the help files.
Yeah, I know the help is huge. But, you can try this command to show a list of related
topics you are trying:
   :he <topic><c-d>
It is "some topic" followed by the key sequence Ctrl-D. For eg:
   :he xterm<c-d>
will show all the help topics matching xterm. Then you can do completion/copy-n-paste
the topic you are searching. Of course you can cycle through all the topics through
repeated <TABS>, but if the number of hits are huge, it is cumbersome.

Enjoy vimming beginners!!!
-Arun

VimTip 230: copy current file to another location from within vim
http://vim.sourceforge.net/tip_view.php?tip_id=

I work on jsp pages in my source tree but I have to copy the jsp files over to the tomcat directory in order to view my changes.The following mapping will copy the file being edited to another location.

command Cpage silent !cp '%:p' "c:/Progra~1/Tomcat/webapps/console/pages/%"

Explanation:

% refers to the current buffer
%:p refers to the path to the file
silent suppresses the command prompt window.

Usage:

:Cpage

VimTip 231: Localized color schemes
http://vim.sourceforge.net/tip_view.php?tip_id=

i frequently like to edit multiple files in the same vim session.  however, if i come into vim from another window i frequently hit 'i' and start typing in whatever buffer is currently being used -- this is often the wrong one (requires <esc>, undo, go the other buffer and . to redo).

one way to work around this for me is to use a different color scheme depending on what file i'm working on:

au BufEnter * if (exists("b:colors_name")) | let b:current_colors=colors_name | execute "colorscheme " . b:colors_name | endif

au BufLeave * if (exists("b:current_colors")) | execute "colorscheme " . b:current_colors | endif

if you define b:colors_name with a particular color scheme name, then the above autocommands will switch to that colorscheme when you enter that window and will return to the original color upon departure.

inside ftplugin/java.vim, for example, i might have b:colors_name set to 'morning', causing all java files to have a distinguishing color scheme.

VimTip 232: Search JDK help for keyword at cursor
http://vim.sourceforge.net/tip_view.php?tip_id=

 If you are using the Win32 version of Vim you can use this tip to search the Jdk help for the keyword under the cursor.
You need the winhlp32 version of the Jdk docs from this URL - http://www.confluent.fr/javadoc/indexe.html.
It is a 16mb D/L and approx 85mb unzipped!

I added a command to the popup menu
:amenu PopUp.JavaHelp	:!start winhlp32 -k <cword> F:\jdk\winhelp\JDK13.HLP <CR

And also made a keymapping
map J :!start winhlp32 -k <cword> F:\jdk\winhelp\JDK13.HLP <CR>

Trivial yes, but I find it quite useful.

VimTip 233: Some tips for using Vim to write Lisp code
http://vim.sourceforge.net/tip_view.php?tip_id=

For some tips on how to use Vim for writing Lisp code, see http://www.lisp-p.org/i000/15-vim.

VimTip 234: Vi(M) Command Line tips & tricks
http://vim.sourceforge.net/tip_view.php?tip_id=

Hi VIMMERs

These tips save me wearing out my delicate little fingers with unnecessary keystrokes.
They assume Unix, but I also use them on a Windows Unix Shell (MKS) as well

# When I know the file i want to edit is the most recent file in a directory

alias -x vew='vi `l\s -t * | head -1 `'

#When I know the file I want to edit contains a unique keyword
#this is actually in a little shell script call ed vg where the keyword is passed as parameter $1
#/bin/sh
#name vg
vi.exe  $(grep -isl $1 *) &

# some variations
alias -x vp='vi `l\s -t *.@(pl|cgi)| head -1 `'

#execute the most recent script (I call this from within VIM with a mapped button)
alias -x xew='`l\s -t *.pl | head -1 `'

Cheers zzapper

VimTip 235: Toggle highlight word under cursor, to find cursor.
http://vim.sourceforge.net/tip_view.php?tip_id=

When the screen has scrolled such as during a search, it may be difficult to find the cursor.  :help %# explains the pattern one can use to highlight the word around the cursor, which gives a bigger target to look for on the screen.  I have this in my .vimrc:

function VIMRCWhere()
    if !exists("s:highlightcursor")
        match Todo /\k*\%#\k*/
        let s:highlightcursor=1
    else
        match None
        unlet s:highlightcursor
    endif
endfunction
map <C-K> :call VIMRCWhere()<CR>

This means that in "normal" mode ctrl-k will toggle the highlight.  Todo is a hightlight group whch is particularly easy to see.
For further information see ":help s:", ":help match",  ":help exists()"  and ":help funtion".

VimTip 236: Menu for inserting special characters
http://vim.sourceforge.net/tip_view.php?tip_id=

First, thanks for the script printascii.vim.

When looking at the ascii table, I found some characters I'd like to have inserted when editing.
Add the following lines in your _gvimrc and you can select them via menu.
(change the names of the menu if you don't have German installed or don't like my titles).
I also made some abbreviations to get separation lines in documentation or code files,
e.g.
abb dotlin ^M
abb cdotlin /**/^M
abb fdotlin ^M
abb cfdotlin /**/^M
abb dlin =======================================================================^M
abb cdlin /*===================================================================*/^M
abb lin -----------------------------------------------------------------------^M
abb clin /*-------------------------------------------------------------------*/^M
abb ulin _______________________________________________________________________^M
abb culin /*___________________________________________________________________*/^M
abb Ulin ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯^M
abb cUlin /*¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯*/^M

(you have to substitute ^M with CTRL_V CTRL_M or delete it)

20imenu Editieren.Sonderzeichen.open\ angle\	«	<C-R>=nr2char(171)<CR>
20nmenu Editieren.Sonderzeichen.open\ angle\	«	a<C-R>=nr2char(171)<CR><ESC>
20imenu Editieren.Sonderzeichen.close\ angle\	»	<C-R>=nr2char(187)<CR>
20nmenu Editieren.Sonderzeichen.close\ angle\	»	a<C-R>=nr2char(187)<CR><ESC>
20imenu Editieren.Sonderzeichen.start\ mark\		<C-R>=nr2char(132)<CR>
20nmenu Editieren.Sonderzeichen.start\ mark\	 	a<C-R>=nr2char(132)<CR><ESC>
20imenu Editieren.Sonderzeichen.end\ mark\	\		<C-R>=nr2char(148)<CR>
20nmenu Editieren.Sonderzeichen.end\ mark\	\	 	a<C-R>=nr2char(148)<CR><ESC>
20imenu Editieren.Sonderzeichen.fat\ dot\	\		<C-R>=nr2char(149)<CR>
20nmenu Editieren.Sonderzeichen.fat\ dot\	\		a<C-R>=nr2char(149)<CR><ESC>
20imenu Editieren.Sonderzeichen.etc\	\	\		<C-R>=nr2char(133)<CR>
20nmenu Editieren.Sonderzeichen.etc\	\	\	 	a<C-R>=nr2char(133)<CR><ESC>
20imenu Editieren.Sonderzeichen.!underscore\	\	¯	<C-R>=nr2char(175)<CR>
20nmenu Editieren.Sonderzeichen.!underscore\	\	¯ 	a<C-R>=nr2char(175)<CR><ESC>
20imenu Editieren.Sonderzeichen.copyright\	\	©	<C-R>=nr2char(169)<CR>
20nmenu Editieren.Sonderzeichen.copyright\	\	©	a<C-R>=nr2char(169)<CR><ESC>
20imenu Editieren.Sonderzeichen.paragraph\	\	§	<C-R>=nr2char(167)<CR>
20nmenu Editieren.Sonderzeichen.paragraph\	\	§	a<C-R>=nr2char(167)<CR><ESC>
20imenu Editieren.Sonderzeichen.noitamalcxe\	¡	<C-R>=nr2char(161)<CR>
20nmenu Editieren.Sonderzeichen.noitamalcxe\	¡	a<C-R>=nr2char(161)<CR><ESC>

VimTip 237: If you prefer vertical splits
http://vim.sourceforge.net/tip_view.php?tip_id=

This is just in case there's somebody else who likes to work in a maximized vim window on a high resolution desktop. If you follow good coding practice and make sure your programs use only 80 characters in each row, have you noticed how much space lies unused on the right?

I find that the following settings keep me from ever seeing another horizontal split, unless I specifically ask for it.

cabbrev split vsplit
cabbrev hsplit split
cabbrev sta vertical sta
cabbrev help vertical help
cabbrev new vnew
cabbrev right botright

; A more heavyweight solution for ^W^]
function! ToggleSplit (dir)
    let currFname = bufname ("%")
    let old = winnr ()

    " Window navigation to ensure the correct window is 'last'.
    if (a:dir == "u")
        wincmd k
        let back="j"
    elseif (a:dir == "d")
        wincmd j
        let back="k"
    elseif (a:dir == "l")
        wincmd h
        let back="l"
    elseif (a:dir == "r")
        wincmd l
        let back="h"
    endif

    if (winnr () == old)
        echo "Ouch"
        return
    endif

    exec "wincmd " . back

    quit

    if (back == "j" || back == "k")
        let orientation = "vsplit"
    else
        let orientation = "split"
    endif

    if (back == "j" || back == "l")
        let dir = "below"
    else
        let dir = "above"
    endif

    exec dir . " " . orientation " " . currFname
endfunction
noremap ^W^] ^W^]:silent call ToggleSplit ("d")<CR>

; Optional.
set splitright
; In which case the above mapping becomes:
noremap ^W^] :set splitbelow<CR>^W^]:silent call ToggleSplit ("u")<CR>:set nosplitbelow<CR>
; Or you could just
set splitbelow
; :-)

; Very elegant and almost perfect, but it screws up if you want to run a command with ranges :-)
;noremap : :vertical<Space>

; EOF

VimTip 238: Very basic session persistence
http://vim.sourceforge.net/tip_view.php?tip_id=

I use the following code in my plugins dir to ease session persistance. If I want my session to persist I use :mks! and then whenever I open the Session.vim file, my session is restored. If I am working from a restored session and I close VIM, the session is saved automatically. Drawback is that it makes editing the Session.vim file a bit cumbersome ;)

  au BufRead Session.vim so %
  au VimLeave * call SaveCurrentSession()

  function! SaveCurrentSession()
    if v:this_session != ""
      exe "mksession! " . v:this_session
    endif
  endfunction

VimTip 239: Scroll using arrow keys like browser: map shift-up and shift-down
http://vim.sourceforge.net/tip_view.php?tip_id=

You can make Vim scroll the text using the shifted up/down arrows, sort of like your browser (except with shifted keys :), by mapping Shift-Up to Ctrl-Y and Shift-Down to Ctrl-E.

    map <s-Down> <C-E>
    map <s-Up> <C-Y>

Shift-Down will then scroll down (like moving a scroll-bar down, or like moving a cursor at the bottom of a window down), and Shift-Up will then scroll up (like moving a scroll-bar up, etc).

If you'd rather think about the text moving down/up instead of the cursor moving up/down, you can of course swap the mappings.

If you normally use j and k for cursor movement, and rarely use the arrow keys, you can map the arrow keys directly, in which case I'd probably map the shifted arrow keys back to cursor movement:

    map <down> <c-e>
    map <up> <c-y>
    map <s-down> j
    map <s-up> k

See :help ctrl-e, :help ctrl-y, and :help key-mapping.

See also :help i_ctrl-o and :help map-modes for how to set up these mappings for use in other modes (like insert mode :).

(Vim by default maps s-Down and s-Up to Ctrl-F and Ctrl-B, for both normal and visual mode.  Keep this in mind if you change some of the above mappings to "nmap", 'cause you'll probably also want to look in to "vmap".)

VimTip 240: Hideall for Vim
http://vim.sourceforge.net/tip_view.php?tip_id=

Xemacs has a hide all function which can make all the function in your C file a fold and close them. And here is something small to achieve similiar under Vim.

func! HideAll()
   syn region myFold start="{" end="}" transparent fold
   syn sync fromstart
   set foldnestmax=1
   set foldmethod=syntax
endfunc

amenu Whatever.Hide\ all :call HideAll()<CR>

VimTip 241: "Hide" Folding Markers
http://vim.sourceforge.net/tip_view.php?tip_id=

I wanted to start using folding without having to get used to
seeing the (default) markers, a.k.a {{{ and }}}. So, here are
2 autocmd's that will make them fade to black....bg=black fg=black

au BufRead,BufNewfile   * syn match fmrkr '"*{{{\|"*}}}'                 |
                        \ syn cluster vimCommentGroup contains=fmrkr     |
                        \ hi fmrkr term=NONE guibg=black   guifg=black
                        \                    ctermbg=black ctermfg=black

au BufRead,BufNewfile   * syn match fmrkr '"*{{{\|"*}}}'
                        \ containedin=vimLineComment contained           |
                        \ hi fmrkr term=NONE guibg=black   guifg=black
                        \                    ctermbg=black ctermfg=black

They both accomplish the same thing, but with different methods, so
simply pick one and see those annoying (at least to me) markers fade away.
I just tried it out with vim files, but you can easily modify it for
any other filetypes.

Thanks to Colin's lead with ':help c-syntax'    for the 1st au.
Thanks to Benji's lead with ':help containedin' for the 2nd au.
Understanding most of the syntax.txt document file would also be helpful.

To figure out what highlighting group the Marker is in, I would suggest
using Chip's vimtip#99.

Happy Vimming!

VimTip 242: The power of "\_" in reg-ex
http://vim.sourceforge.net/tip_view.php?tip_id=

One of the most uncelebrated feature of vim 6.0 is the ability to span a search across multiple lines.

\_^   maps a begining of line anywhere in search pattern.
\_$   ---"----- end           ----------------------"-------------------------.
\_s  ---"------ space                   ------------"------------------------- .

e.g  /{\_s will map all white spaces and new-line chars after a "{"

The \_ can be appended to other objects as well. such as \_U,  \_L,  \_. (this one's risky) .

See :help pattern for more details.
Njoy

VimTip 243: Develop vim modules on Win
http://vim.sourceforge.net/tip_view.php?tip_id=

We're trying to develop txt2pdf.vim http://vim.sourceforge.net/scripts/script.php?script_id=283 on Win.
It's a very simple module to save the current file and convert it to PDF using our txt2pdf tool http://www.sanface.com/txt2pdf.html
On our Windows 2000 we've developed it. It works good.
Today we've tested the module on Linux. Surprise: it doesn't work.
Default Win Vim configure save on Win text in Win way: EOL \r\n.
A Vim module made in this way can't work on Linux (probably on every Unix OS).
If you want to make a Vim module on Win and you want it can work also on Unix (we hope the same rula can work also on different OS) you've to save the Vim module with Unix EOL (\n).

Please send us (sanface@sanface.com) your notes about other OS (e.g. OpenVMS).

VimTip 244: Ask vim where an option was set.
http://vim.sourceforge.net/tip_view.php?tip_id=

     When things go wrong, it is sometimes hard to figure out why.  For example,
an option might be set in the system vimrc file, in a personal vimrc file, in a
plugin (global or local), or interactively.  Vim will tell you where the current
value was set if you ask:

:verbose set history?

will tell you the current value of the 'history' option, and where it was set.

VimTip 245: Working with Unicode (platform-independent)
http://vim.sourceforge.net/tip_view.php?tip_id=

Here are the main options you will want to set if you want to work with Unicode files in (g)vim (see at bottom what help tags to look for)

if has("multi_byte")
     set encoding=utf-8                       " how vim shall represent characters internally
     setglobal fileencoding=utf-8         " empty is also OK (defaults to same as 'encoding'). Or you may want to set one of the ucs encodings (which
                                                          " may use less disk space if you use only "alphabetic" scripts such as Latin, Greek, Cyrillic, Hebrew or Arabic, and
                                                          " not "ideographic" scripts like Chinese, Japanese or Korean. With the ucs encodings it is usually better
     set bomb                                      "  to also set 'bomb' on ('byte-order-mark" option, irrelevant for utf-8 but not for ucs)
     set termencoding=iso-8859-15    " or whatever is appropriate to your locale (iso-8859-15 is Latin1 + Euro currency sign)
     set fileencodings=ucs-bom,iso-8859-15,iso-8859-3,utf-8
         " or whatever is appropriate to the kinds of files you want to edit
         " 'fileencodings' defines the heuristic to set 'fillencoding' (local to buffer) when reading an existing file. The first one that matches will be used.
         " ucs-bom is "ucs with byte-order-mark"; it must not come after ucs-8 if you want it to be used
else
     echoerr "Sorry, this version of (g)vim was not compiled with +multi_byte"
endif

In "replace" mode, one utf character (one or more data bytes) replaces one utf character (which need not use the same number of bytes)
In "normal" mode, ga shows the character under the cursor as text, decimal, octal and hex; g8 shows which byte(s) is/are used to represent it
In "insert" or "replace" mode,
  - any character defined on your keyboard can be entered the usual way (even with dead keys if you have them, e.g. âêîôû  äëïöü)
  - any character which has a "digraph" (there are a huge lot of them, see :dig after setting enc=utf-8) can be entered with a Ctrl-K prefix
  - any utf character at all can be entered with a Ctrl-V prefix, either <Ctrl-V> u aaaa or <Ctrl-V> U bbbbbbbb, with 0 <= aaaa <= FFFF, or 0 <= bbbbbbbb <= 7FFFFFFF

Unicode can be used to create html "body text", at least for Netscape 6 and probably for IE; but on my machine it doesn't display properly as "title text" (i.e., between <title></title> tags in the <head> part).

Gvim will display it properly if you have the fonts for it, provided that you set 'guifont' to some fixed-width font which has the glyphs you want to use (Courier New is OK for French, German, Greek, Russian and more, but I'm not sure about Hebrew or Arabic; its glyphs are of a more "fixed" width than those of, e.g. Lucida Console: the latter can be annoying if you need bold Cyrillic writing).

see:

:h utf8
:h 'enc'
:h 'fenc'
:h 'fencs'
:h 'tenc'
:h 'bomb'
:h 'guifont'
:h ga
:h g8
:h i_Ctrl-V_digit

Happy Vimming !
Tony.

VimTip 246: Working with Unicode (the same, rewritten for legibility)
http://vim.sourceforge.net/tip_view.php?tip_id=

1. Where to look for help
-------------------------
:h utf8
:h encoding-values
:h 'enc'
:h 'fenc'
:h 'fencs'
:h 'tenc'
:h 'bomb'
:h 'guifont'
:h ga
:h g8
:h :dig
:h i_Ctrl-V_digit
:h has()

2. What to do (These are *examples*. Modify them to suit your work environment.)
-------------
if has("multi_byte")
     set encoding=utf-8
     setglobal fileencoding=utf-8
     set bomb
     set termencoding=iso-8859-15
     set fileencodings=ucs-bom,iso-8859-15,iso-8859-3,utf-8
else
     echoerr "Sorry, this version of (g)vim was not compiled with +multi_byte"
endif

3. What the above does
----------------------
* has("multi_byte") checks if you have the right options compiled-in. If you haven't got what it takes, it's no use trying to use Unicode.

* 'encoding' sets how vim shall represent characters internally. Utf-8 is necessary for most flavors of Unicode.

* 'fileencoding' sets the encoding for a particular file (local to buffer); :setglobal sets the default value. An empty value can also be used: it defaults to same as 'encoding'. Or you may want to set one of the ucs encodings, It might make the same disk file bigger or smaller depending on your particular mix of characters. Also, IIUC, utf-8 is always big-endian (high bit first) while ucs can be big-endian or little-endian, so if you use it, you will probably need to set 'bomb" (see below).

* 'bomb' (boolean): if set, vim will put a "byte order mark" at the start of ucs files. This option is irrelevant for most non-ucs files (utf-8, iso-8859, etc.)

* 'termencoding' defines how your keyboard encodes what you type. The value you put there will depend on your locale: iso-8859-15 is Latin1 + Euro currency sign, but you may want something else for, say, an Eastern European keyboard.

* 'fileencodings' defines the heuristic to set 'fileencoding' (local to buffer) when reading an existing file. The first one that matches will be used (and, IIUC, if there is no match, Vim falls back on Latin1). Ucs-bom is "ucs with byte-order-mark"; it must not come after utf-8 if you want it to be used.

4. Additional remarks
---------------------
* In "replace" mode, one utf character (one or more data bytes) replaces one utf character (which need not use the same number of bytes)

* In "normal" mode, ga shows the character under the cursor as text, decimal, octal and hex; g8 shows which byte(s) is/are used to represent it.

* In "insert" or "replace" mode,
  - any character defined on your keyboard can be entered the usual way (even with dead keys if you have them, e.g. French circumflex, German umlaut, etc.);
  - any character which has a "digraph" (there are a huge lot of them, see :dig after setting enc=utf-8) can be entered with a Ctrl-K prefix;
  - any utf character at all can be entered with a Ctrl-V prefix, either <Ctrl-V> u aaaa or <Ctrl-V> U bbbbbbbb, with 0 <= aaaa <= FFFF, or 0 <= bbbbbbbb <= 7FFFFFFF.

* Unicode can be used to create html "body text", at least for Netscape 6 and probably for IE; but on my machine it doesn't display properly as "title text" (i.e., between <title></title> tags in the <head> part).

* Gvim will display it properly if you have the fonts for it, provided that you set 'guifont' to some fixed-width font which has the glyphs you want to use (Courier New is OK for French, German, Greek, Russian and more, but I'm not sure about Hebrew or Arabic; its glyphs are of a more "fixed" width than those of, e.g. Lucida Console: the latter can be awkward if you need bold Cyrillic writing).

Happy Vimming !
Tony.

VimTip 247: Preexisting code indentation
http://vim.sourceforge.net/tip_view.php?tip_id=

Using tabs as elementary unit in your code indentation has two advantages: first, you may modify 'tabstop' and immediately all the indentations depths are modified according to it; second, your file will be smaller.

But how can we change some already-written code in order to convert spaces to tabs. Very simple!
Suppose your old code has an indentation unit of 2 spaces
:ret! 2
:x
will replace every 2-spaces to one tab, independently from your current tabstop value, and will save the modified file.
Then, if you open again the file with tabstop=2, the file will look as before but it will be smaller. If you open the file with tabstop=4, the code vill have a more indented look, and so on...

Cheers!

VimTip 248: Auto-save the current buffer periodically.
http://vim.sourceforge.net/tip_view.php?tip_id=

I have no  idea if this was implemented  in vim 5.3 or not,  but you can
definitely  do the  following  kludge  in 6.x  by  using CursorHold  and
localtime:

- When you  start reading a file,  set a buffer variable  to the current
  time:

  au BufRead,BufNewFile * let b:start_time=localtime()

- Set a  CursorHold event  to check  to see if  enough time  has elapsed
  since the last save and save if not:

  au CursorHold * call UpdateFile()

- Define a function to save the file if needed:

  " only write if needed and update the start time after the save
  function! UpdateFile()
    if ((localtime() - b:start_time) >= 60)
      update
      let b:start_time=localtime()
    else
      echo "Only " . (localtime() - b:start_time) . " seconds have elapsed so far."
    endif
  endfunction

- Reset the start time explicitly after each save.

  au BufWritePre * let b:start_time=localtime()

Obviously, you  should get rid of  the else portion once  you're certain
that this does indeed do what you wanted.

The  thing  to  note  is  that  the  CursorHold  will  only  fire  after
'updatetime' milliseconds  of inactivity have  elapsed. So, if  you type
rapidly for  one and  a half  minutes non-stop,  it won't  actually save
anything until you STOP activity long  enough. This may be what you want
anyway because it won't interrupt your activity with a forced save.

The actual save-delay can be changed from '60' to another number (in seconds) or a variable or anything like that.  This entire functionality can be easily wrapped inside a nice script which enables/disables this on a per-buffer basis (maybe with maps etc.).  If desired, I can provide that also.

VimTip 249: C/C++: Quickly insert #if 0 - #endif around block of code
http://vim.sourceforge.net/tip_view.php?tip_id=

One of my favorite macros that I use in vim (and vi) inserts a #if 0 #endif sandwich
around a block of code.  I always map this to the 2 key sequence ;'  which is the
semi-colon followed by the single quote.  Look at your keyboard, you will notice
these keys are adjacent to one another.  I like this mapping because it's very fast,
my fingers easily roll from one key to the next, obviously YMMV.

To use this mapping, go to the line of code that you want the '#if 0' to be on, type
ma to mark this line with the marker a, then move to the line that should be last line
just above the '#endif' and press ;'

    " insert #if 0 - #endif around block of code
    map ;' mz'aO<Esc>i#if 0<Esc>'zo<Esc>i#endif<Esc>

--
David Thompson
dat1965@yahoo.com

VimTip 250: One big window
http://vim.sourceforge.net/tip_view.php?tip_id=

If you like to see your files in fullscreen, and you have to edit more files, you can do the following.
* Use only one window
* Open further files with :e
* type :nm <A-Up> :bp!<CR>
* type :nm <A-Down> :bn!<CR>
* type :nm <C-F4> :bd!<CR>
You can of course change the keys.
Now to switch between windows, you can press Alt-Up, and Alt-Down
(Just in the GUI, if you use console, don't use Alt key)
Another idea is to map them to Ctrl-Tab, and Ctrl-Shift-Tab
To close the current file you can press Ctrl-F4

VimTip 251: c/c++: align #endif with corresponding #if/#ifdef
http://vim.sourceforge.net/tip_view.php?tip_id=

If you try to impose any sort of alignment on your preprocessor directives, rather than just starting them on column 0, this mapping will align the #endif 'correctly' when you type '#en', start a new line, and bring you back to the correct alignment to edit code.

inoremap <buffer> #en X<BS><Esc>?#if<CR>"zy0^Og0"zpDa#endif<CR>X<BS><Esc>?#end?-1<CR>^"zy0^O0"zpDa

I am reasonably sure this is insensitive to vim options...

VimTip 252: python script to align statements
http://vim.sourceforge.net/tip_view.php?tip_id=

i know there's some awk scripts out there that do the same thing, and if i were a real trooper i would have
written this in vims internal language but...

i wrote a python script to align statements.

i put this in my .vimrc:
map L :!lineUp.py<cr>   " of course lineUp.py is somewhere in my path

and i have this python file somewhere in my path:
http://ophinity.com/res/dotFiles/lineUp.py

so now i can just pipe the offending lines thru my code:
:5, 10 !lineUp.py
or using the mapping above, visually select the lines and press 'L'

VimTip 253: The power of | (v75|r- actually...)
http://vim.sourceforge.net/tip_view.php?tip_id=

'|' as you may well be aware is the goto column motion, and that "75|" will place your cursor on column 75 of the current line.

That in itself is pretty handy at times, but some true power arises when used in conjuction with visual mode and replace. Or you could just say a sneaky trick :)

v75|r-
will repace from the cursor to the end of line with '-'
*breakdown*
v to turn on visual mode
75 for the count
| *bar* to goto column
r to enter repace
- to specify the char to replace.

A handy and quick way to make a noticable section of your code (or whatever).

A handy way to use this (formated to just drop into DrChip's CStubs):
"// -[Feral]---------------------------------------------------------------
"// <cursor>
	elseif wrd == "//"
		exe "norm! a -[AuthorId]\<esc>$lv75|r-$a\<cr>\<esc>$a "

"// -[Feral:146/02@08:31]--------------------------------------------------
"// <cursor>
	elseif wrd == "///"
		exe "norm! s -[AuthorId:\<C-R>=strftime('%j/%y@%H:%M')\<CR>]\<esc>$lv75|r-$a\<cr>\<esc>$a "

"/* -[Feral:146/02@08:31]--------------------------------------------------
" * <cursor>
" * -------------------------------------------------------------------- */
	elseif wrd == "/*"
		exe "norm! a -[AuthorId:\<C-R>=strftime('%j/%y@%H:%M')\<CR>]\<esc>$lv75|r-$a\<cr>\<cr>\<esc>2lv72|r-$a */\<esc>k$a "

Have to love VIM!

VimTip 254: Using \%[] to easily match parts of a word.
http://vim.sourceforge.net/tip_view.php?tip_id=

This code fragment is suitable to drop into DrChip's CStubs.
After much searching I was unable to find a tip nor script number to referance, I believe where I found Dr. Chip's CStubs originally : http://users.erols.com/astronaut/vim/vimscript/drcstubs.vim
Thank you Dr. Chip! (=

If you have ever wanted to match parts of a word you may have considered something like:
if wrd == "re" || wrd == "ret" || wrd == "retu" || wrd == "retur"
   "do something

Althought the above works well enough it is a pain to maintain and add new words (not to mention its just a touch messy ;) )

A more elegant (and easier to use I believe) method would be to use \%[] as part of a pattern.

For instance, "\\<re\\%[tur]\\>" will match "re", "ret", "retu" or "retur"

*breakdown*
\\< = start of word
re = first letters of word we want to require to match
\\%[tur] = optionally match chars bewteen the braces, i.e. 't', 'tu' or 'tur'
\\> = end of word

So, we can use this as a pattern for match like so (In DrChip's CStubs)

elseif match(wrd, "\\<re\\%[tur]\\>") > -1
    exe "norm! bdWireturn\<Esc>"

Which, I think, is a little better than the longer alternative:
"  vs
elseif wrd == "re" || wrd == "ret" || wrd == "retu" || wrd == "retur"
    exe "norm! bdWireturn\<Esc>"

Just another one of those VIM things that made me smile :)

VimTip 255: arbitrary tags for file names
http://vim.sourceforge.net/tip_view.php?tip_id=

This definitely work on linux and there is probably some windows equivalent.
I've started working with tomcat and many many .jsp files.  I find this trick to be very helpful.

find -name '*.jsp' -printf '%f\t%P\t1\n' |sort > jsp.tags

This will create a file called jsp.tags with tag entries for each .jsp file.  Within Vim I use

:set tags+=jsp.tags

Now I can to simple :tag file.jsp to quickly switch b/w the many, many .jsp files.

One important note.  The utility sort will use the value of LC_COLLATE to sort according to your
locale.  This will give Vim issues.  So try "LC_COLLATE=C sort" instead of plain "sort"

VimTip 256: Opening current Vim file in your Windows browser
http://vim.sourceforge.net/tip_view.php?tip_id=

Hi Vimmers

open current file in browser

map ,f   :update<CR>:silent !start c:\progra~1\intern~1\iexplore.exe file://%:p<CR>

open http link under cursor in your browser

map ,i   :update<CR>: !start c:\progra~1\intern~1\iexplore.exe <cWORD><CR>

Note use of cWORD (not cword) meaning OUTER Word

Works for me in XP & 98
(Original came from a posting by Ralf Arens)

zzapper

VimTip 257: fast page up/down.
http://vim.sourceforge.net/tip_view.php?tip_id=

i discovered a cool way to move between pages of the same document in vim 6.1. press a number in -normal mode- and the page up/down. the document will move with that number of pages up/down.if the number is greater that the nr of pages, document will move to begin/end of file.
i didn't test it on other version.

VimTip 258: how long is the current word?
http://vim.sourceforge.net/tip_view.php?tip_id=

ever wondered how long the current word is?  this can be quite useful when editing data files.
simply add the following to your .vimrc

nmap <C-_> :echo 'word' expand("<cword>") '  wordlen =' strlen(expand("<cword>"))<CR>

and it will tell you the word under the cursor, and how long it is.

and for things that arent words, this addition to your .vimrc works on sections of a line that have been hightligted in visual mode

vmap <C-_> "-y:echo 'word' @- '  wordlen =' strlen(@-)<CR>

again you see the "word", and its length
this may also work on vim 5.x, but i havent checked to make sure.

VimTip 259: removing the toolbar (icons) from gvim
http://vim.sourceforge.net/tip_view.php?tip_id=

Change good or bad usually  encounters interia from people in excepting it.
gvim 6.0 is the first version that introduced the icons shortcut in shape of a toolbar under the menu.
when we upgraded to the new and improved vim 6.1 from vim 5.7 some of people in our company encountered some problems with their syntax highlighting
and some of them objected on the new toolbar which displayed icons for some common tasks for people more used to GUI.

I finally figured out how to remove this new feature since I also didn't see much use for it

Here is for all those who haven't figured it out yet

In your .gvimrc include the following two lines

unmenu ToolBar
unmenu! ToolBar

Doing this from an open gvim does not remove them but grays them out but doing from gvimrc does the job

I was also trying to remove the menus at the top and almost succeeded with a similar technique but somehow the Buffer menu item stays there no matter what. IMHO it is a bug but it could very well be a feature ;)

I tried this

unmenu *
unmenu! *

even added this line after the above two but didn't help
unmenu Buffers

I hope this benefits you all as much as I have benefitted from all your tips

VimTip 260: gvim-->mouse-->popup menu
http://vim.sourceforge.net/tip_view.php?tip_id=

This tip is for those who prefer to do some of the common
operations like cut/copy/paste etc using mouse. All u have to do is


 :set mousemodel=popup

by this u get a popup menu on right click of your mouse and u can
do all the common operations like undo, cut, copy, paste, select etc
using mouse.

u can also customise your popup menu by editing $VIMRUNTIME/menu.vim

VimTip 261: Close windows from  Gvim poup menu
http://vim.sourceforge.net/tip_view.php?tip_id=

To close windows from the popup menu add these lines to your .gvimrc

:amenu PopUp.Close.\ Window :confirm close<CR>
:amenu PopUp.Close.\ Other  :confirm only<CR>

You obviously need ':set mousemodel=popup' in your .gvimrc as well :=)

VimTip 262: Bored of ur arrow shapped mouseptr?
http://vim.sourceforge.net/tip_view.php?tip_id=

here is how u can change the shape of ur mouseptr in gvim.

:set mouseshape=n:pencil

this will change the shape of the mouseptr to pencil in normal mode.
u can choose different shapes for different modes. see :h mouseshape

Want more shapes?

Then look for the file cursorfont.h in ur X11/ directory.
This file contains lots of cursor shape #define definitions, like
.
#define XC_heart 62
.
now :set mouseshape=n:62 will set the shape of the mouseptr to heart
in normal mode.

-ncr

VimTip 263: color active line
http://vim.sourceforge.net/tip_view.php?tip_id=

This tip shows how to color the active line, the line in which the cursor is, for better reading.
You should try possibility 2 before 1, IMHO it is mostly usable.

possibility 1:
     :au! CursorHold * let @/ = '\%' . line('.') . 'l.*'
     :set ut=500

explanation:
     After 500 ms of waiting for you to hit a key, vim sets the search register to a pattern that matches the current line.

problem:
     Register / holds the search pattern, so you cannot have color the active line and search.
     Therefore another solution:

possibility 2:
     :highlight CurrentLine guibg=darkgrey guifg=white     (or whatever colors you want)
     :au! Cursorhold * exe 'match CurrentLine /\%' . line('.') . 'l.*/'
     :set ut=100

explanation:
     This solution uses 'match' to highlight a string, it does not interface with the current search pattern.

addition:
     Turning the highlighning off:
          :au! Cursorhold
          :match none
     The order of these commands are important. If :match none is executed first, the autocommand would
     almost immediately execute another match command.

references to vim help:
     :help Cursorhold
     :help 'ut'
     :help /\%l
     :help "/
     :help \%

VimTip 264: F5 Compile and Run, F8 Compile (ala Visual Studio)
http://vim.sourceforge.net/tip_view.php?tip_id=

I love vim, it's my default editor on my Sun, Windows, Linux and *BSD boxen.  That said, I hate having to flip windows to compile while doing the write->compile->debug loop.

If you're used to Visual Studio and the ability it has to just hit F5 to compile and run the current file or F8 to compile or step through the code you'll appreciate this...

This is my Windows version of this scriplet/tiplet.  For other platforms, you'll want to change the IF ELSE loops.  You should actually never see the "Unsuccessful" message from the compile/run loop unless the compiler completely bombs out.   This is from my _vimrc...

map <F5> :call CompileRunGcc()<CR>

map <F8> : call CompileGcc()<CR>

func! CompileRunGcc()
		exec "w"   "Save the file
		exec "!gcc % -o %< && cr 10 && IF EXIST %<.exe (%<) ELSE banner -c = Compile Unsuccessful "
		exec "i" "jump back where we were




endfunc

func! CompileGcc()
		exec "w"
		exec "!gcc % -o %<  && IF EXIST %<.exe (cr 5 && banner -c # Success) ELSE banner -c # Compile Unsuccessful "
		exec "i"


endfunc

VimTip 265: Fast help in full window
http://vim.sourceforge.net/tip_view.php?tip_id=

You can get fast access to help by writing small script

#!/bin/bash
vim -c "help $1" -c only

now name it eg. vih and from cl

$ vih makeprg

VimTip 266: use -S command line switch
http://vim.sourceforge.net/tip_view.php?tip_id=

The -S switch could be used to simplify common idiom: start Vim and source a script file:
gvim -c ":so foobar.vim" got translated into gvim -S foobar.vim

Yes, this tip is trivial but I still see the -c ":so x" way too often. Time to update your mind!

VimTip 267: selectively displaying abbreviations
http://vim.sourceforge.net/tip_view.php?tip_id=

Hi Vimmers,
abbreviations have always been one of the most useful parts of vi(m), trouble is when you've got too many you forgot what you called them.

You can of course list the whole lot with

:ab<cr>

But did you know that you can type the first few letters of your abbreviations and get a list of just thos abs eg

:ab php<cr>
gives me all my php abs
&
:ab perl<cr>
gives me all my perls

also try control-D instrad of <cr>

zzapper

VimTip 268: Get cursor position as byte percentage instead of line percentage
http://vim.sourceforge.net/tip_view.php?tip_id=

On line 300 of a thousand line file, Vim will show you that you're 30% through the file.  But what if most of the lines have one character in them, and some of them have twenty thousand?  Sometimes it comes in handy to know your percentage through the file in terms of current-byte / total-bytes.  I looked through the Vim docs and couldn't find a way to do this, so I wrote a Vim function to show it.

Put this in your .vimrc:

function! Percent()
    let byte = line2byte( line( "." ) ) + col( "." ) - 1
    let size = (line2byte( line( "$" ) + 1 ) - 1)
    " return byte . " " . size . " " . (byte * 100) / size
    return (byte * 100) / size
endfunction

(Uncomment the first return to see intermediate values.)

And put this somewhere in your "set statusline=...":

    %{Percent()}%%

See "help statusline", "help eval".

VimTip 269: Syntax highlighting is "out of sync", seems to correct itself with refresh ??
http://vim.sourceforge.net/tip_view.php?tip_id=

This one has come across the 'vim' users mailing list many times, and probably
comp.editors as well...

Summary:
see :help :syn-sync
and search for 'sync' in your favorite syntax file in $VIMRUNTIME/syntax

Long Version:
The syntax highlight code utilizes a certain synchronization method to efficiently
figure out syntax highlighting, specifically if you aren't at the very beginning or
end of a file.  The specific setting is 'syntax sync'.  For various file types the
method is set by default in this is setup in the syntax file and one can vary
the degree of trouble which VIM goes to to try and figure this out.  As an example
for C, from $VIMRUNTIME/syntax/c.vim:

if exists("c_minlines")
  let b:c_minlines = c_minlines
else
  if !exists("c_no_if0")
    let b:c_minlines = 50	" #if 0 constructs can be long
  else
    let b:c_minlines = 15	" mostly for () constructs
  endif
endif
exec "syn sync ccomment cComment minlines=" . b:c_minlines

Where c_minlines is the minimum number of lines that VIM goes backward
to try to find the start of a comment for syntax highlighting.  If that line which
starts a comment is outside of that range, highlighting will appear wrong.

You can easily set up something like this in your .vimrc:
let c_minlines=500
or even bigger, but realize that it is a performance trade-off and that
syntax highlighting will slow things down.

VimTip 270: Insert a single character
http://vim.sourceforge.net/tip_view.php?tip_id=

Using Insert mode to insert a single character feels clumsy (you need
3 keypresses for one character), so here's a slightly easier way:

:nmap <space> i_<esc>r

Now, when in Normal mode, just press space followed by what
it is you want to insert.

BUG: Repeating the insertion with . doesn't work.

VimTip 271: easy (un)commenting out of source code
http://vim.sourceforge.net/tip_view.php?tip_id=

Something that I do quite alot is comment out blocks of text, only to uncomment that same block later. The following mappings have proven useful to me. They can be applied using visually selected blocks, or with motion keys.

" lhs comments
map ,# :s/^/#/<CR>
map ,/ :s/^/\/\//<CR>
map ,> :s/^/> /<CR>
map ," :s/^/\"/<CR>
map ,% :s/^/%/<CR>
map ,! :s/^/!/<CR>
map ,; :s/^/;/<CR>
map ,- :s/^/--/<CR>
map ,c :s/^\/\/\\|^--\\|^> \\|^[#"%!;]//<CR>

" wrapping comments
map ,* :s/^\(.*\)$/\/\* \1 \*\//<CR>
map ,( :s/^\(.*\)$/\(\* \1 \*\)/<CR>
map ,< :s/^\(.*\)$/<!-- \1 -->/<CR>
map ,d :s/^\([/(]\*\\|<!--\) \(.*\) \(\*[/)]\\|-->\)$/\2/<CR>

The commands to comment a selection of text are as follows, begining with begining-of-line comments:

    ,#    shell, perl, etc
    ,/     c++
    ,>    email quote
    ,"     vim
    ,%    latex, prolog
    ,!      assembly?... add single !
    ,;      scheme
    ,-      don't remember this one... add --
    ,c     clears any of the previous comments

Here are the wrapping comments, each line wrapped individually:

    ,*      c
    ,(       Standard ML
    ,<      html
    ,d      clears any of the wrapping comments

VimTip 272: automaticaly formating pasted text (p=`])
http://vim.sourceforge.net/tip_view.php?tip_id=

In times past I used a nice editor that had the neat feature of automatically setting pasted text to the proper indent level. Recently I've begun to miss this so I went looking in the help and camp up with....

=`]

which will format to the end of the pasted text... Perfect to call right after you past something as the cursor ends up at the top of the pasted text, thus the mapping:

:map <c-p> =`]

" by the by the above may should be nmap and I am pretty sure c-p is unused, your mileage will vary no doubt.

However I wanted the formatting to automatically be done so it was two simple (once I figured out how!) nnoremap:

" [Feral:185/02@14:27] map c-p to what p was (past with no formatting), map p to p and = to end of pasted text.
:nnoremap p p=`]
:nnoremap <c-p> p

This simply (as the comment hints at) maps normal mode p to what p did (paste) then = to `] (last character in the previously changed text). While ctrl+p just does what p did. (just in case you find you don't want a bit of text auto formatted.).

reference:
:h :nnoremap
:h p
:h =
:h `]

Whatever the name of this idea is, tis something I find handy :)

Happy VIMing

VimTip 273: Fast fixing of email quotations (too long lines)
http://vim.sourceforge.net/tip_view.php?tip_id=

When using VIM as your editor of choice, even for email processing - as I do - it is often unpleasing how some MUA's quote the email body produced by mailers such as Outlook. The lines often span across multiple visual lines and its difficult to reply on certain parts of it.

With VIM, you can quickly fix those quotations to maintain a proper 75 char break. For example, when using Mutt, put this line in your .muttrc, or use a custom .vimrc_mail for it:

set editor="vim -c 'set fo=tcrq' -c 'set tw=76'"

For other MUA's this has to be fitted. However, now, when your quoted email is displayed, you can use this VIM sequence to fix it:

1. move cursor to first line of broken paragraph
2. press 'V' and move to the last line of the paragraph you want to fix
3. press 'g' and then 'q'. The marked text will wrap around to your specified textwidth (76 in our case) and the quotations will be preserved across the lines

VimTip 274: Some useful mappings for TeX
http://vim.sourceforge.net/tip_view.php?tip_id=

You know, TeX requires a lot of additional formatting code. I'm tired of opening and closing braces, brakets,
 \beginning and \ending etc. I particularly hate typing \begin and \end.
To help myself and to save a few(not a few) keystrokes I naturaly came up to some solutions, which I wish to share with
other TeXnicians and TeXperts whhich use Vim.
"===============================cut here=========================
"=============== you can put it in ~/.vim/after/ftplugin/tex.vim ===============
"
" Note: i_<C-L>
" This constructs a skeleton of a TeX environment.
" You write a line like this:
" floatingfigure:ht<C-L>
" and after you press <C-L>, you get:
"
" \begin[ht]{floatingfigure}
"
" \end{floatingfigure}
" -- INSERT --
"
" where floatingfigure is the desired environment
" ht are options
" : is delimiter; in fact, you can use whatever delimiter you want
" as long it is not in &iskeyword option.
inoremap <buffer> <C-L> 
			\:s/[^][:alnum:]<bar>]\+/,/eg
			\I\begin{ea}[A]%d%%P
			\:s/\[,/[/e
			\:s/,]/]/e
			\:s/\[]//e
			\0f{y%o\endpO
inoremap <buffer> { {}i
inoremap <buffer> [ []i
inoremap <buffer> ^ ^{}i
inoremap <buffer> _ _{}i
inoremap <buffer> \( \(\)hi
inoremap <buffer> \[ \[\]hi

" Note: v_<C-L>
" For this to work, you have to write on a blank line the name of
" the desired environment and options (see i_<C-L>) and visual select
" (from top to bottom) this and following lines.
" After pressing <C-L> the selected lines will be surrounded
" with begin/end skeleton of the environment.
vnoremap <buffer> <C-L> o
			\:s/[^][:alnum:]<bar>]\+/,/eg
			\I\begin{ea}[A]%d%%P
			\:s/\[,/[/e
			\:s/,]/]/e
			\:s/\[]//e
			\0f{y%gvoo\endp
"	vnoremap <buffer> { di{}P
"	vnoremap <buffer> [ di[]P
vnoremap <buffer>  di^{}P
vnoremap <buffer>  di_{}P
vnoremap <buffer> \( di\(\)hP
vnoremap <buffer> \[ di\[\]hP

" This makes "two spaces after a comma" before every :write
au BufWritePre *.tex %s/,\(\S\)/, \1/ge

"==================== You can put this in your ~/.vimrc ========================
" If cursor is inside braces and not before comma, blank or opening brace,
" exit the brace block and stay in insert mode.
" If cursor is outside braces, it inserts a space or perform an abbreviation
" as normal.
function! CleverSpace()
	let CharOnCursor = strpart( getline('.'), col('.')-2, 1)
	let CharAfterCursor = strpart( getline('.'), col('.'), 1)
	if CharOnCursor !~ ',\|\s\|(' && CharAfterCursor =~ ')\|]\|}'
		normal x
	endif
endfunction
inoremap <Space> <Space>:call CleverSpace()<LF>a

" I use the last function not only for LaTeX but also in C sources.

VimTip 275: Some useful mappings for TeX
http://vim.sourceforge.net/tip_view.php?tip_id=

You know, TeX requires a lot of additional formatting code. I'm tired of opening and closing braces, brakets,
 \beginning and \ending etc. I particularly hate typing \begin and \end.
To help myself and to save a few(not a few) keystrokes I naturaly came up to some solutions, which I wish to share with
other TeXnicians and TeXperts whhich use Vim.
"===============================cut here=========================
"=============== you can put it in ~/.vim/after/ftplugin/tex.vim ===============
"
" Note: i_<C-L>
" This constructs a skeleton of a TeX environment.
" You write a line like this:
" floatingfigure:ht<C-L>
" and after you press <C-L>, you get:
"
" \begin[ht]{floatingfigure}
"
" \end{floatingfigure}
" -- INSERT --
"
" where floatingfigure is the desired environment
" ht are options
" : is delimiter; in fact, you can use whatever delimiter you want
" as long it is not in &iskeyword option.
inoremap <buffer> <C-L> 
			\:s/[^][:alnum:]<bar>]\+/,/eg
			\I\begin{ea}[A]%d%%P
			\:s/\[,/[/e
			\:s/,]/]/e
			\:s/\[]//e
			\0f{y%o\endpO
inoremap <buffer> { {}i
inoremap <buffer> [ []i
inoremap <buffer> ^ ^{}i
inoremap <buffer> _ _{}i
inoremap <buffer> \( \(\)hi
inoremap <buffer> \[ \[\]hi

" Note: v_<C-L>
" For this to work, you have to write on a blank line the name of
" the desired environment and options (see i_<C-L>) and visual select
" (from top to bottom) this and following lines.
" After pressing <C-L> the selected lines will be surrounded
" with begin/end skeleton of the environment.
vnoremap <buffer> <C-L> o
			\:s/[^][:alnum:]<bar>]\+/,/eg
			\I\begin{ea}[A]%d%%P
			\:s/\[,/[/e
			\:s/,]/]/e
			\:s/\[]//e
			\0f{y%gvoo\endp
"	vnoremap <buffer> { di{}P
"	vnoremap <buffer> [ di[]P
vnoremap <buffer>  di^{}P
vnoremap <buffer>  di_{}P
vnoremap <buffer> \( di\(\)hP
vnoremap <buffer> \[ di\[\]hP

" This makes "two spaces after a comma" before every :write
au BufWritePre *.tex %s/,\(\S\)/, \1/ge

"==================== You can put this in your ~/.vimrc ========================
" If cursor is inside braces and not before comma, blank or opening brace,
" exit the brace block and stay in insert mode.
" If cursor is outside braces, it inserts a space or perform an abbreviation
" as normal.
function! CleverSpace()
	let CharOnCursor = strpart( getline('.'), col('.')-2, 1)
	let CharAfterCursor = strpart( getline('.'), col('.'), 1)
	if CharOnCursor !~ ',\|\s\|(' && CharAfterCursor =~ ')\|]\|}'
		normal x
	endif
endfunction
inoremap <Space> <Space>:call CleverSpace()<LF>a

" I use the last function not only for LaTeX but also in C sources.

VimTip 276: Function signature previewer
http://vim.sourceforge.net/tip_view.php?tip_id=

Have you ever tried to call a function which parameters you have forgotten?
Especially those long named and with long parameter list GTK+ functions
like gtk_menu_item_image_from_stock_new(..........) !!!
By accident I saw a function in Vim help. It's name was PreviewWord and it allowed
one to jump in the preview window to the tag for the word cursor is on.
I _slightly_ modified this function not to need tags file, but to search included files instead.
I wrote another function, which uses the above said one, which triggers PreviewWord
when you open the parenthesis after a function name.
Here it is:
" Note:
" This is literally stolen from Vim help. The only changes are:
" (1) if w != ""               becomes       if w =~ "\k"
" (2) exe "silent! ptag " . w  becomes       exe "silent! psearch " . w
" * The first change prevents PreviewWord of searching while cursor is on some
"   non-keyword characters, e.g. braces, asterisks, etc.
function! PreviewWord()
	if &previewwindow			" don't do this in the preview window
		return
	endif
	let w = expand("<cword>")		" get the word under cursor
	if w =~ "\k"				" if there is one ":ptag" to it

		" Delete any existing highlight before showing another tag
		silent! wincmd P			" jump to preview window
		if &previewwindow			" if we really get there...
			match none			" delete existing highlight
			wincmd p			" back to old window
		endif

		" Try displaying a matching tag for the word under the cursor
		let v:errmsg = ""
		exe "silent! psearch " . w
		if v:errmsg =~ "tag not found"
			return
		endif

		silent! wincmd P			" jump to preview window
		if &previewwindow		" if we really get there...
			if has("folding")
				silent! .foldopen		" don't want a closed fold
			endif
			call search("$", "b")		" to end of previous line
			let w = substitute(w, '\\', '\\\\', "")
			call search('\<\V' . w . '\>')	" position cursor on match
			" Add a match highlight to the word at this position
			hi previewWord term=bold ctermbg=green guibg=green
			exe 'match previewWord "\%' . line(".") . 'l\%' . col(".") . 'c\k*"'
			wincmd p			" back to old window
		endif
	endif
endfunction
au! CursorHold *.[ch] nested call PreviewWord()

" Note:
" When you open a parenthesis after a function name, and at the
" line end, that function's definition is previewed through PreviewWord().
" This is inspired from Delphi's CodeInsight technology.
" Something similar (PreviewClassMembers) could be written for
" the C++ users, for previewing the class members when you type
" a dot after an object name.
" If somebody decides to write it, please, mail it to me.
function! PreviewFunctionSignature()
	let CharOnCursor = strpart( getline('.'), col('.')-2, 1)
	if col(".") == col("$")
		call PreviewWord()
	endif
	return "("
endfunction
inoremap <buffer> ( <C-R>=PreviewFunctionSignature()<LF>

VimTip 277: Function signature previewer
http://vim.sourceforge.net/tip_view.php?tip_id=

Have you ever tried to call a function which parameters you have forgotten?
Especially those long named and with long parameter list GTK+ functions
like gtk_menu_item_image_from_stock_new(..........) !!!
By accident I saw a function in Vim help. It's name was PreviewWord and it allowed
one to jump in the preview window to the tag for the word cursor is on.
I _slightly_ modified this function not to need tags file, but to search included files instead.
I wrote another function, which uses the above said one, which triggers PreviewWord
when you open the parenthesis after a function name.
Here it is:
" Note:
" This is literally stolen from Vim help. The only changes are:
" (1) if w != ""               becomes       if w =~ "\k"
" (2) exe "silent! ptag " . w  becomes       exe "silent! psearch " . w
" * The first change prevents PreviewWord of searching while cursor is on some
"   non-keyword characters, e.g. braces, asterisks, etc.
function! PreviewWord()
	if &previewwindow			" don't do this in the preview window
		return
	endif
	let w = expand("<cword>")		" get the word under cursor
	if w =~ "\k"				" if there is one ":ptag" to it

		" Delete any existing highlight before showing another tag
		silent! wincmd P			" jump to preview window
		if &previewwindow			" if we really get there...
			match none			" delete existing highlight
			wincmd p			" back to old window
		endif

		" Try displaying a matching tag for the word under the cursor
		let v:errmsg = ""
		exe "silent! psearch " . w
		if v:errmsg =~ "tag not found"
			return
		endif

		silent! wincmd P			" jump to preview window
		if &previewwindow		" if we really get there...
			if has("folding")
				silent! .foldopen		" don't want a closed fold
			endif
			call search("$", "b")		" to end of previous line
			let w = substitute(w, '\\', '\\\\', "")
			call search('\<\V' . w . '\>')	" position cursor on match
			" Add a match highlight to the word at this position
			hi previewWord term=bold ctermbg=green guibg=green
			exe 'match previewWord "\%' . line(".") . 'l\%' . col(".") . 'c\k*"'
			wincmd p			" back to old window
		endif
	endif
endfunction
au! CursorHold *.[ch] nested call PreviewWord()

" Note:
" When you open a parenthesis after a function name, and at the
" line end, that function's definition is previewed through PreviewWord().
" This is inspired from Delphi's CodeInsight technology.
" Something similar (PreviewClassMembers) could be written for
" the C++ users, for previewing the class members when you type
" a dot after an object name.
" If somebody decides to write it, please, mail it to me.
function! PreviewFunctionSignature()
	let CharOnCursor = strpart( getline('.'), col('.')-2, 1)
	if col(".") == col("$")
		call PreviewWord()
	endif
	return "("
endfunction
inoremap <buffer> ( <C-R>=PreviewFunctionSignature()<LF>

VimTip 278: all the right moves
http://vim.sourceforge.net/tip_view.php?tip_id=

One of the principles of effective text editing is moving around very efficiently.
Following are some pointers which may help u do that.

    h      move one character left
    j       move one row down
   k       move one row up
   l         move one char. right.
   w       move to begining of next word
   b       move to begining of previous word
   e       move to end of word
   W     move to begining of next word after a whitespace
   B      move to begining of pervious word before a whitespace
   E      move to end of word before a whitespace.


(All the above movements can be preceeded by a numeric value . i.e  '4j' will move 4 rows down )

   ^        move to first non blank char of the line.
   g_      move to last non blank char of the line.
   0        moev to begining of line
   $        move to end of line.
   gg      move to first line.
   G        move to last line.
   nG      move to "n"th line.
   H        top of screen.
  M         middle of screen
   L        bottom of screen
    Ctrl-D   move half page down
    Ctrl-U   move half page up.
    Ctrl-B   page-up
    Ctrl-F   page down.

     Ctrl-o  last cursor position.
     '[a-z,0-9,A-Z]    jump to the marker. (u can set a marker on line by :-   m[a-zA-Z,0-9] and then jump back to it by '[a-z,A-Z0-9]

      n   next matching search pattern
      N  previous matching search pattern
      *    next word under cursor
     #    previous word under cursor.
     g*   next matching search pattern under cursor.
     g#  previous matching search pattern under cursor.

VimTip 279: On Windows, make GVim the default action for double-click with "unknown file types"
http://vim.sourceforge.net/tip_view.php?tip_id=

I find myself installing the following registry modification for all my PC's now (even other people's PC's).  It applies to Microsoft Windows machines only.  The following is also for Windows 9x...  NT or XP or 2000 may require modifications (which I don't care to understand!).

The problem: You double-click on a file that doesn't have a 'registered type' and that pesky "What program should I use?" dialog pops up.  Even worse, depending on the installation, the GVim icon may not be listed, and one has to browse to the executable...  and then the type becomes forever bonded to being editted with GVim (if that box is checked).  The standard Vim 6.1 installation does include a "right click to edit" menu item for all files, but a double-click is so much faster!

The solution: What if unregistered types would just automatically open up in GVim?  Well, they can..  with a little registry trickery.

How to Install it:

Step 1. Create a text file called "vimalways.reg" and paste the below text into it.

Step 2.  Important NOTE: You will have to edit the pathname to correspond to the pathname of your GVim.exe.  The text below works fine for a GVim 6.1 default installation.

Step 3: Save the file.

Step 4: Right-click on the file and select "install".  Then you are done!

------ vimalways.reg  ------- cut here ------snip---snip---
REGEDIT4

[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\*\shell]


[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\*\shell\Open with &GVim]
@="Open with &GVim"

[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\*\shell\Open with &GVim\command]
@="\"C:\\vim\\vim61\\gvim.exe\" \"%1\""

----end of file---- cut here----- snip---snip----

Note 1.  This can't be de-installed automatically, and if you want to remove it, you'll have to edit the registry by hand (annoying, but easy).

Note 2.  Keep this file around, so when you upgrade your GVim, all you have to do is modify the pathname (to say, for example, vim62) and then install it again.

Ok, thanks for playing!
And thanks to the author(s) of Vim and GVim.
If it weren't for them, I'd still be using elvis or stevie!



VimTip 280: Integration with PyUnit testing framework
http://vim.sourceforge.net/tip_view.php?tip_id=

Vim has a wonderful ability to integrate with external tools, like compilers, make, ctags etc.
That's one of the reasons we love it.

PyUnit can be seen as a "compiler" for the Python test code.
To understand it, Vim should be told about the language
the PyUnit speaks. This could be done with 'errorformat' option:

setlocal efm=%C\ %.%#,%A\ \ File\ \"%f\"\\,\ line\ %l%.%#,%Z%[%^\ ]%\\@=%m

This magic spell enables Vim to parse unittest.TextRunner's output and to enter quick-fix mode.
To run all your unit tests at once you'll need to setup 'makeprg' option and provide a runner.
I'm using this setup:

setlocal makeprg=./alltests.py

And contents of the alltests.py (for the sake of completeness):

#!/usr/bin/env python2

import unittest
import sys
sys.path.append('unittests')

modules_to_test = (
	'fooTest',
	'barTest',
	'bazTest',
)

def suite():
    alltests = unittest.TestSuite()
    for module in map(__import__, modules_to_test):
        alltests.addTest(unittest.findTestCases(module))
    return alltests

if __name__ == '__main__':
    unittest.main(defaultTest='suite')

============== end of the alltests.py file ========================

While talking about it, I'd also suggest to add a couple of mappings.
In the end, my vim/files/ftplugin/python.vim looks like this:

setlocal makeprg=./alltests.py\ -q
setlocal efm=%C\ %.%#,%A\ \ File\ \"%f\"\\,\ line\ %l%.%#,%Z%[%^\ ]%\\@=%m
iabbr <buffer> sae self.assertEquals
iabbr <buffer> sar self.assertRaises

For details see :help quick-fix,  :help 'efm' and  :help 'makeprg'.
See also:  http://c2.com/cgi/wiki?PythonUnit

Many thanks to Stefan Roemer who patiently spent quite some time to build 'efm' for me.

VimTip 281: Stateful zz
http://vim.sourceforge.net/tip_view.php?tip_id=

Do you find yourself hitting 'zz' all the time in order to see some context of what you're
currently working on? If so, then this tip might be for you. If you add the following line
in your vimrc, you can toggle zz mode by pressing <Leader>zz.

" maintain a constant zz state, second call will toggle it back off
map <Leader>zz	:let &scrolloff=999-&scrolloff<CR>

VimTip 282: Folding with Regular Expression
http://vim.sourceforge.net/tip_view.php?tip_id=

Well, I've tried to understand some of the folding scripts, but life's
too short. Instead, I added the following lines to my vimrc file.

set foldexpr=(getline(v:lnum)=~@/)?0:(getline(v:lnum-1)=~@/)\|\|(getline(v:lnum+1)=~@/)?1:2
map \z :set foldmethod=expr foldlevel=0 foldcolumn=2<CR>

The first line is an extension of foldexpr=(getline(v:lnum)=~@/)?0:1
The second line (re)sets the foldmethod to expr(ession) plus.

First search for /regexp/, then fold everything else with \z
Use zr to reveal more context (before/after) lines.

You could add (getline(v:lnum-2)=~@/)\|\|(getline(v:lnum+2)=~@/)?2:3
but it will take longer as folded lines (the majority) evaluate the full expression.

What could be easier?

VimTip 283: Turn on syntax coloring in Mac OS X
http://vim.sourceforge.net/tip_view.php?tip_id=

This tip is actually for vim 6.1. To turn on syntax coloring in Mac OS X enter the following commands, or place them in your $HOME/.vimrc file.

:set term=builtin_beos-ansi
:syntax on

VimTip 284: Mapping to print syntax highlighted buffer in B&W
http://vim.sourceforge.net/tip_view.php?tip_id=

I use this mapping to print syntax highlighted C++ code in B&W
This tip needs vimscript #233 print_bw.

The mapping is as follows
map <C-p> :color print_bw<CR>:hardcopy<CR>:color sean<CR>:syn on<CR>

Change ":color sean" to whatever is your chosen color scheme.
Need to change line 7 of print_bw from "syntax reset" to "syntax off"
<C-p> on a syntax highlighted buffer turns off syntax highlighting , sets the colors to B&W, prints the buffer, resets the color scheme and turns on syntax highlighting again.

VimTip 285: Don't use the escape key!
http://vim.sourceforge.net/tip_view.php?tip_id=

Vim (any vi really) is a dream for touch typists... Until you want to switch from insert mode to normal mode.  Then you've got to reach way up to whack the escape key.

Or at least that's what I was doing until I realized that (drum roll please)

                    Esc is exactly equivalent to control-[  (that's the control key plus the left square bracket key)

That little bit of knowledge, plus mapping my caps lock to another control key, was what turned my fascination with Vim into true love.  You never have to lose track of the home row again!

For Xfree86 users - you can make the capslock key another control key by adding

Option "XkbOptions" "ctrl:nocaps"

to the InputDevice section of your XF86Config file.

For Windows NT/2000 users  - use the following .reg file to do the same thing:

REGEDIT4

[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Keyboard Layout]
"Scancode Map"=hex:00,00,00,00,00,00,00,00,02,00,00,00,1d,00,3a,00,00,00,00,00

VimTip 286: Recover after doing something... ugly.
http://vim.sourceforge.net/tip_view.php?tip_id=

I was once editing a file and wanted to test something. The test was meant to add a line at the end of the file, from outside vim. All was fine, but instead of >>, I wrote >. You can imagine what happened... :)

If you happen to do something like that, the solution is:

:recover

VimTip 287: Cool trick to change numbers
http://vim.sourceforge.net/tip_view.php?tip_id=

In the gvim if you want to decrement any number just put ur curcor on that number in Esc mode and pres <CTRL> X

VimTip 288: A keymapping to generate Java setters and getters automatically
http://vim.sourceforge.net/tip_view.php?tip_id=

This mapping makes it much simpler to write new java classes by simplifying some of the dull repetative coding (ie setters and getters).

To use, first write a basic class with the following format:

public class MyClass
{

     private <type> <varname> = <initvalue>;
     private <type> <varname> = initvalue>;

     // getters

     // setters

}

Note the getters/setters comment -- they are important as they are used to place the getters and setters.

The mapping is:

map jgs mawv/ <Enter>"ty/ <Enter>wvwh"ny/getters<Enter>$a<Enter><Enter>public <Esc>"tpa<Esc>"npbiget<Esc>l~ea()<Enter>{<Enter><Tab>return <Esc>"npa;<Enter>}<Esc>=<Enter><Esc>/setters<Enter>$a<Enter><Enter>public void <Esc>"npbiset<Esc>l~ea(<Esc>"tpa <Esc>"npa)<Enter>{<Enter><Tab>this.<Esc>"npa=<Esc>"npa;<Enter>}<Esc>=<Enter>`ak

(the above should be one long line with no spaces between the end of the lines above).

To use this to generate a class go to the variable that should have a setter/getter and place the curser at the beginning of the 'private':

   private <type> <variable> = <initvalue>'
   ^

Then type:

jgs

this will create the first getter/setter and then move up to the next variable.  You can just keep typing jgs until all the  getters/setters have been generated.

This should mapping isn't perfect and someone could probably make it a little cleaner.  It could also relatively easily be adapted to C++.  Please feel free to send me any feedback/enhancements as I am trying to compile a list of these.

VimTip 289: Alternative <escape> that allows you to do a "quick and dirty insert" and get out into normal mode
http://vim.sourceforge.net/tip_view.php?tip_id=

This is an alternative key combo for the escape key from the one mentioned by David A. Rogers in vimtip #285.

I do a lot of editting in Vim, and I've always found myself in situations where I had to "do a quick insert" - basically (from normal mode), change into insert mode, type in one quick word, then <esc> out, then navigate elsewhere.

As has been rightly observed by a lot of people, the <esc> key can sometimes be a little bit out of the way. But that's no problem for ViM, is it?

At first, I thought of editting the ViM source code itself, in order to come up with a command that could do things like say "let me jump into insert mode, type a few quick words, then escape out into normal mode when i press something like double <space>".

It was only later when reading through the section in Jesse Goerz's "Beginner's Guide to ViM" on remapping (http://newbiedoc.sourceforge.net/tutorials/vim/mapping-vim.html) that I got inspired to retake a look at using remapping as an alternative instead.

This is what I came up with.. Use whatever is comfortable for you - single or double <Shift-space>

:map! <S-space> <esc>
:map! <S-space><S-space> <esc>

With this quick combo ("Shift", + <space>), one can easily (and might I add, intuitively) "do a quick insert" and exit quickly out into normal mode. I guess I always thought the <space> would be a good way to do this sort of thing, since it is after all, so intuitive in the typing process. So why not make it such that it can "escape" you out into normal mode as well? Just type 'i', to go into insert mode, type in your stuff, and once you're done, hit Shift-space!

VimTip 290: Text Processing With Integrated Spell Checking
http://vim.sourceforge.net/tip_view.php?tip_id=

I have written an HTML document to help others use Vim as a basic text processing application. It discusses how to integrate spell checking, dictionary, and thesaurus applications. It also talks about wrapping lines, indentation, justification, and the vim settings that effect the behavior of these operations. The document can be found at:
   http://www.highley-recommended.com/text-processing.html

Everything has been tested with UNIX, Linux, Windows, and Windows with Cygwin patforms.

VimTip 291: ^P & auto filling of variables and text
http://vim.sourceforge.net/tip_view.php?tip_id=

Do you know you can auto fill the variable and names as you type your code ? This will help most of the programmers, who always try hard to remember the variable names and browse through all the files to find out the variable name.
   Use Ctrl+P and Ctrl+N to autofill the variables names etc. Just practice, you will feel the ease of using vim

VimTip 292: vim + cscope + cygwin
http://vim.sourceforge.net/tip_view.php?tip_id=

I've found that vim + cscope + cygwin does not work. The problem seems to be that in

sprintf(cmd, "exec %s -dl -f %s", prog, csinfo[i].fname);

vim execs cscope with the "-dl" options, causing it to fail. It is probably a cscope bug, but a simple workaround is top build vim without thad "d":

sprintf(cmd, "exec %s -l -f %s", prog, csinfo[i].fname);

seems to work for me!

VimTip 293: remember where you had ended reading help
http://vim.sourceforge.net/tip_view.php?tip_id=

You could jump to the last place you had been while reading Vim help files if you add this to your
.vimrc file:

au BufLeave * if &ft == "help" | mark H | endif

Then use 'H to go to the mark H.

To work between Vim runs 'viminfo' option should be setup to save file marks.
See :help 'viminfo' and :help file-marks for more information.

VimTip 294: Use Ctrl-S to save current or new files.
http://vim.sourceforge.net/tip_view.php?tip_id=

I wanted to have a single key stroke that would save existing files, or call the file browser.
Here's a key map for Ctrl-S to accomplish that (place in vimrc file):

if has("gui_running")
  " If the current buffer has never been saved, it will have no name,
  " call the file browser to save it, otherwise just save it.
  :map <silent> <C-S> :if expand("%") == ""<CR>:browse confirm w<CR>:else<CR>:confirm w<CR>:endif<CR>
endif

Tom Kimpton

VimTip 295: Line/word/file/whatever completion
http://vim.sourceforge.net/tip_view.php?tip_id=

In addition to vimtip #291 you can use whole <C-x> completion mode. It can complete whole lines (<C-x>l, then <C-p>, <C-n>), filenames (<C-f>), keywords, words from custom dictionary and many, many others. During coding it usually saves a LOT of key strokes ;) This mode has many other powerful features, for example when completing word (by <C-x><C-p> or just by <C-p>) you can continue completion with another <C-x><C-p>. For example, after writing such text:

this is first line
second line is here

Placing cursor at third line and pressing <C-x>l will double last line - <C-n>, <C-p> in this moment can be used to manipulate completed line. Or, instead of completing whole line you can press 'f' and then complete by <C-p> which will result in 'first' word. After that you can <C-x><C-p> to get 'line' word (since this is next word after 'first'). Try yourself for other powerful combinations.

VimTip 296: Attach the currently open file to email
http://vim.sourceforge.net/tip_view.php?tip_id=

This is very simple, but most people don't seem to take advantage of this. Often you have some file (source code or other text file) already open in an existing vim session and you need to attach it with an email. It is very simple.
    - First copy the filename into clipboard. For this I put the following mapping in vimrc and press <F2>:
         nnoremap <F2> :let @*=expand("%:p")<cr>
    - Go to your email compose window and use your regular file attachment menu (Insert->File in outlook) and press ^V (or whatever key to paste clipboard) and press Enter.

That is all there to it. If you are on windows and your email client doesn't accept forward-slashes, then you might want to change the map to:

         nnoremap <F2> :let @*=substitute(expand("%:p"), "/", "\\", "g")<cr>

HTH,
Hari

VimTip 297: Start in insert mode without loosing your escape key
http://vim.sourceforge.net/tip_view.php?tip_id=

There are two parts to this, each is fairly simple.

First, I want to start in insert mode.  Well "set im!" in my vimrc did the job, but I lost the escape key.
Second, I have found that often times, when I'm in command mode, I hit escape trying to get back into insert mode.  I am always rewarded with a beep, telling me once again I made that mistake.

So I mapped esc in command mode to set insert mode (":set im") and I mapped esc in insert mode to unset insert mode (<c-o>:set im)  Well then I realized if you hit "i" in command mode, escape woulding work the first time.  So here's the code to add to your vimrc:

set im!                      " start in insert mode
map <esc> :set im!<cr>       " escape in command mode goes to insert mode
map i :set im!<cr>           " i in command mode goes to insert mode
map! <esc> <c-o>:set im!<cr> " escape in insert mode goes to command mode

see :help insert

VimTip 298: Changing case with regular expressions
http://vim.sourceforge.net/tip_view.php?tip_id=

I stumbled across this factoid on a website about vi. I haven't been able to locate it in the Vim documentation, but it works in Vim, and it's very handy.

There are times that you might like to go through a file and change the case of characters that match some arbitrary criteria. If you understand regular expressions well, you can actually do this fairly easily.

It's as simple as placing \U or \L in front of any backreferences in your regular expressions. Vim will make the text in the backreference uppercase or lowercase (respectively).

(A "backreference" is a part of a regular expression that refers to a previous part of a regular expression. The most common backrefernces are &, \1, \2, \3, ... , \9).

Some examples that demonstrate the power of this technique:

Lowercase the entire file -
:%s/.*/\L&/g

(& is a handy backreference that refers to the complete text of the match.)

Uppercase all words that are preceded by a < (i.e. opening HTML tag names):
:%s/<\(\w*\)/<\U\1/g

Please add a note if you know where this is in the documentation. I have done Ctrl-D searches on upper, lower, \U, and \L with no luck.

VimTip 299: Open file under cursor.
http://vim.sourceforge.net/tip_view.php?tip_id=

A little thing that I did and found quite useful:

function! OpenFileUnderCursor()
	let FileName = expand("<cfile>")
	let OldPath = getcwd()
	silent cd %:p:h
	execute "silent sp +e " . FileName
	execute "silent cd " . OldPath
endfunction

map! silent <M-e> :call OpenFileUnderCursor()<CR>

Then use Alt+E on a filename to open it (relative to the directory the current file resides in).

VimTip 300: Making a tags file for IDL (Interactive Data Language)
http://vim.sourceforge.net/tip_view.php?tip_id=

I have recently began using the tags features of vim (:help tags) with my fortran codes and come to appreciate their power.  I also do a lot of coding in IDL (Interactive Data Language), but found that ctags did not have native support for IDL.  If you take the time you can learn how to get ctags to support IDL, but I found, after a search of usenet, that someone else has already done this and written a perl script called idltags.  It is part of an emacs package (is anyone still reading?) that you need to download, called idlwave, which is located at:
                      http://idlwave.org/
and currently (I don't know if this will change) the direct download link is
                      http://idlwave.org/download/idlwave.tar.gz
In the usenet pages the maintainer, JD Smith, was suggesting that idlwave had outgrown idltags and was not sure it was still needed, so I don't know how long it will be available.

VimTip 301: Edit files in path, or related.
http://vim.sourceforge.net/tip_view.php?tip_id=

You can write a little shell function that will let you easily edit any file that is in the path, or which's location can be retrieved with the whereis tool. This is something similar to what I have in /etc/profile:

function vvim() { vim `whereis $1|cut -d: -f2` }
function ggvim() { gvim `whereis $1|cut -d: -f2` }

Then just type, for example, "vvim ls", and you'll start vim with /bin/ls and /usr/share/man/ls.1.gz loaded :)
(it's not very useful to edit /bin/ls, but you get the ideea ;)

VimTip 302: Use gvim in kmail
http://vim.sourceforge.net/tip_view.php?tip_id=

To automatically open gvim to edit in kmail, "-f" command line option must be used .
In kmail configuration go to the composer settings , and write in the "use external editor" field the following
command :
"gvim -f %f"
Without -f option gvim would work in background and editing would not have any effect on kmail.

VimTip 303: Statusline Tab Level Function Ruler TVIM
http://vim.sourceforge.net/tip_view.php?tip_id=

I use this function to let me know if my cursor is on a TAB column.
The t* on the ruler means I am not. But t3 means the cursor is on tablevel 3
~vimrc  ----------------------- My Ruler ------------------------ r4,c13,t3
~vimrc  ----------------------- My Ruler ------------------------ r4,c14,t*
If you want to change a tab level you can drag or push the first character
of a line to a desired tab level. (more on that later)
This ruler replacement will let you know where you are, whether you
like to use space tabs (see vimtip #12 ) or regular tabs.  My function is set
to four space tabs stops and only goes 9 levels but can be easily modified.

Actually I just wanted to learn how to use a function in my _vimrc
and this was my first attempt.  Add this to your _vimrc

"--------------------cut------------------
set laststatus=2
"This makes sure the ruler shows.  See    help laststatus
set statusline=%f\ ---------\ My\ Ruler\ ----------\ r%l,c%c,t%{ShowTab()}
"See help statusline  (I toggle between 12 helpful rulers -- more on that later)
fu ShowTab()
    let TabLev='*'
    let Col=(col("."))
    if Col == 1 | let TabLev='0' | en
    if Col == 5 | let TabLev='1' | en
    if Col == 9 | let TabLev='2' | en
    if Col ==13 | let TabLev='3' | en
    if Col ==17 | let TabLev='4' | en
    if Col ==21 | let TabLev='5' | en
    if Col ==25 | let TabLev='6' | en
    if Col ==29 | let TabLev='7' | en
    if Col ==33 | let TabLev='8' | en
    if Col ==37 | let TabLev='9' | en
return TabLev
endf
"The ruler (statusline) shows a t* unless you are on col 1,5,9,13,...
"-------------------cut-------------------

This function ShowTab() gets called and updates the ruler with every cursor
move but it does not slow things down as I type.  Perhaps a speed typist
may complain :-)
In case I write something else you may search on the key word TVIM
Best Wishes        TVIM Tamed Vim        paradocs@frontiernet.net

VimTip 304: fold braces and javadoc
http://vim.sourceforge.net/tip_view.php?tip_id=

If you'd like to have javadoc folded together with areas in braces try that
<pre>
set foldmethod=syntax
set foldenable
syn region foldBraces start=/{/ end=/}/ transparent fold
syn region foldJavadoc start=,/\*\*, end=,\*/, transparent fold keepend
</pre>
and play a bit with:
<pre>
set foldlevel=0
set foldnestmax=10
</pre>
parameters

VimTip 305: Best of VIM Tips (VIM's best Features)
http://vim.sourceforge.net/tip_view.php?tip_id=

Here's a necessarily cryptic list of "MY" Best Vim Tips that I've gleaned
from http://vim.sf.net/  & comp.editors
http://groups.google.com/groups?safe=off&group=comp.editors

updated version at http://www.rayninfo.co.uk/vimtips.html
------------------------------------------------------------------------------
# Absolutely essential
------------------------------------------------------------------------------
vim.sf.net         : Visit frequently
comp.editors    : "VIM" dominated newsgroup
* # g* g#          : find word under cursor (forwards/backwards)
%                   : match brackets {}[]()
matchit.vim      : % now matches tags <tr><td><script> etc
<C-N> <C-P>   : word completion in insert mode
<C-X><C-L>    : Line complete SUPER USEFUL
/<C-R><C-W>   : Pull <cword> onto search/command line
:set ignorecase # you nearly always want this
:syntax on    : colour syntax in Perl,HTML,PHP etc
:h slash<C-D> : type control-D and get a list all help topics containing
                   slash (plus use TAB for Help completion)
------------------------------------------------------------------------------
# MAKE IT EASY TO UPDATE/RELOAD_vimrc
:nmap ,s :source $VIM/_vimrc
:nmap ,v :e $VIM/_vimrc
------------------------------------------------------------------------------
#VISUAL MODE Mappings
:vmap sb "zdi<b><C-R>z</b><ESC> : wrap <b></b> around VISUALLY selected Text
:vmap st "zdi<?= <C-R>z ?><ESC>  : wrap <?=   ?> around VISUALLY selected Text
------------------------------------------------------------------------------
# Exploring
:Ex                             : file explorer note capital Ex
\be                             : builtin buffer explorer
:ls                             : list of buffers(eg following)
:cd ..                          : move to parent directory
------------------------------------------------------------------------------
# Great
guu                             : lowercase line
gUU                             : uppercase line
gf                              : open file name under cursor (SUPER)
ga                              : display hex,ascii value of character under cursor
ggVGg?                          : rot13 whole file
CTRL-A,CTRL-X                   : increment,decerement number under cursor
                                  win32 users must remap CNTRL-A
CTRL-R=5*5                      : insert 25 into text
------------------------------------------------------------------------------
# Makes all other tips superfluous
:h 42
:h holy-grail
:help!
------------------------------------------------------------------------------
# Markers & moving about
'.               : jump to last modification line (SUPER)
`.               : jump to exact spot in last modification line
<C-O>            : retrace your movements in file (old)
<C-I>            : retrace your movements in file (new)
:ju(mps)
:help jump-motions
:history          : list of all your commands
------------------------------------------------------------------------------
# Abbreviations & maps
:map   <f7>   :'a,'bw! c:/aaa/x
:map   <f8>   :r c:/aaa/x
:map   <f9>   :w<CR>:!c:/php/php.exe %<CR>
:map   <f11>  :.w! c:/aaa/xr<CR>
:map   <f12>  :r c:/aaa/xr<CR>
:ab php           : list of abbreviations beginning php
:map ,            : list of maps beginning ,
# For use in Maps
<CR>             : carriage Return for maps
<ESC>            : Escape
<LEADER>         : normally \
<BAR>            : | pipe
------------------------------------------------------------------------------
# List your Registers
:reg             : display contents of all registers
"1p....          : retrieve numeric buffers
------------------------------------------------------------------------------
# Useful trick
"ayy@a            : execute "Vim command" in a text file
yy@"              : same thing using unnamed register
------------------------------------------------------------------------------
# Get output from other commands
:r!ls.exe        : reads in output of ls
!!date           : same thing
:%!sort -u       : use an external program to filter content
------------------------------------------------------------------------------
# Multiple Files Management
:wn              : write file and move to next (SUPER)
:bd              : remove file from buffer list (SUPER)
:sav php.html    : Save current file as php.html and "move" to php.html
:sp fred.txt     : open fred.txt into a split
:e!              : return to unmodified file
:w c:/aaa/%      : save file elsewhere
:e #                 : edit alternative file
:e %
:rew                : rewwind to first file in ARGS
:bn                 : next file
:bp                 : next file
:brew
------------------------------------------------------------------------------
# Recording (BEST TIP of ALL)
qq  # record to q
your commands
q
@q to execute
@@ to Repeat
# editing a register/recording
"ap
<you can now see register contents, edit as required>
"add
@a
------------------------------------------------------------------------------
# _vimrc essentials
:set incsearch : jumps to search word as you type (annoying but excellent)
:set wildignore=*.o,*.obj,*.bak,*.exe
:set shiftwidth=3
------------------------------------------------------------------------------
# launching Win IE
:nmap ,f :update<CR>:silent !start c:\progra~1\intern~1\iexplore.exe file://%:p<CR>
:nmap ,i :update<CR>: !start c:\progra~1\intern~1\iexplore.exe <cWORD><CR>
------------------------------------------------------------------------------
# FTPing from VIM
cmap ,r  :Nread ftp://209.51.134.122/public_html/index.html
cmap ,w  :Nwrite ftp://209.51.134.122/public_html/index.html
gvim ftp://209.51.134.122/public_html/index.html
------------------------------------------------------------------------------
# appending to registers (use CAPITAL)
# yank 5 lines into "a" then add a further 5
"a5yy
10j
"A5yy
------------------------------------------------------------------------------
[I     : show lines matching word under cursor <cword>
------------------------------------------------------------------------------
#Conventional Shifting
:'a,'b>>
# visual shifting (builtin-repeat)
:vnoremap < <gv
:vnoremap > >gv
------------------------------------------------------------------------------
# searching
/^joe.*fred.*bill/ : normal
/^[A-J]\+/         : search for lines beginning A-J followed by at leat 1 A-J
/forum\(\_.\)*pent   search over possible multiple lines
/fred\_s*joe/i    : any whitespace including newline
/fred\|joe        : Search for FRED OR JOE
------------------------------------------------------------------------------
#substitution
:%s/fred/joe/igc            : general substitute command
:%s/\r//g                   : Delete DOS returns ^M
:'a,'bg/fred/s/dick/joe/gc  : VERY USEFUL
:s/\(.*\):\(.*\)/\2 :  \1/  : reverse fields separated by :
:%s/^.\{-}pdf/new.pdf/  non greedy matching (ie to first pdf)
:s/fred/<c-r>a/g substitute "fred" with contents of register "a"
:%s/^\(.*\)\n\1/\1$/  delete duplicate lines
# non-greedy matching \{-}
:%s/^.\{-}pdf/new.pdf/
:help /\{-}
:s/fred/<c-r>a/g substitute "fred" with contents of register "a"
# multiple commands
:%s/\f\+\.gif\>/\r&\r/g | v/\.gif$/d | %s/gif/jpg/
:%s/suck\|buck/loopy/gc  : ORing
:s/__date__/\=strftime("%c")/ : insert datestring
------------------------------------------------------------------------------
# global command
:g/^\s*$/d       :delete all blank lines
:g!/^dd/d        : delete lines not containing string
:v/^dd/d         : delete lines not containing string
:g/fred/,/joe/d  : not line based
:v/./.,/./-1join : compress empty lines
:'a,'b g/^Error/ . w >> errors.txt
:g/cmap\|form/p  : ORing
------------------------------------------------------------------------------
# Paste register *
:redir @*   : redirect commands to paste
:redir END
"*yy        : yank to paste
"*p         : insert paste buffer
------------------------------------------------------------------------------
# Formatting text
gq<CR>
gqap  (a is motion p paragraph (visual mode))
------------------------------------------------------------------------------
# Operate command over multiple files
:argdo %s/foo/bar/
:bufdo %s/foo/bar/
:windo %s/foo/bar/
------------------------------------------------------------------------------
# Command line tricks
gvim -h
ls | gvim -   : edit a PIPE!!
# vg.ksh (shell script)
# vi all files in directory containing keyword $1 and jump to $1
gvim.exe -c "/$1"  $(grep -isl "$1" *) &
------------------------------------------------------------------------------

VimTip 306: Open a web-browser with the URL in the current line
http://vim.sourceforge.net/tip_view.php?tip_id=

function! Browser ()
    let line = getline (".")
    let line = matchstr (line, "http[^ ]*")
    exec "!netscape ".line
endfunction

map <Leader>w :call Browser ()<CR>

VimTip 307: annoying "Hit any key to close this window..."
http://vim.sourceforge.net/tip_view.php?tip_id=

i use gvim and bash heavily under win98.
i have

let $HOME = substitute($HOME, '\\', '/', 'g')
set shell=bash\ --rcfile\ \"$HOME\"_bashrc\ -i

in my _vimrc, and something like

function br()
{
if [ $1 ]; then
        explorer.exe ${1//\//\\}
    else
        explorer.exe ${PWD//\//\\}
    fi
}

in my _bashrc. when i finish editing one html file,
i simply type :!br %

everything works fine now. but when :!br % executes,
one console window will bump out and wait me to press some
key to contiue. i consider this quiet annoying. i want the console window
to disappear automatically if no fault has happened.
does anyone know how to achieve this?
thanks.

VimTip 308: Move through wrapped lines.
http://vim.sourceforge.net/tip_view.php?tip_id=

If you don't like the fact that when you press Up and Down on a wrapped line, you get to the next phisical line instead of the next line on the screen, you can do something like this:

imap <silent> <Down> <C-o>gj
imap <silent> <Up> <C-o>gk

nmap <silent> <Down> gj
nmap <silent> <Up> gk

VimTip 309: close vim you left open remotely
http://vim.sourceforge.net/tip_view.php?tip_id=

Vim 6 has this cool client-server protocol. I use it all the time to edit a file in an existing gvim, like so
$ gvim --remote [filename]

Today I left myself logged in at the console at work, and when I got home I realized I had left vim running with files  unsaved. I think I even left it in insert mode. I wanted to edit these files at home. So I ssh'd to the machine and started playing with the --remote commands.

:help was a bit cryptic
   --remote-send {keys}         Send {keys} to server and exit.

After a lot of failed attempts, I finally succeeded in getting the remote vim to save its buffers and quit.

$ DISPLAY=:0 vim --servername GVIM --remote-send '<ESC>:wqa<CR>'

A couple of notable things. Then environment variable DISPLAY has to be the display of the remote vim, and you have to be able to open that display. The client-server stuff is done through X.

The <CR> is important. This part eluded me for a long time. The {keys} are just like keys you would press if you were editing at the console, and you have to press enter, or vim won't do anything.

Check your .swp files to make sure vim really closed the files it was editing. Vim provides little feedback as to the success or failure of what you're trying to do remotely. Nonetheless, it's clearly a useful feature to have available.

VimTip 310: showing ascii value of the current character in decimal, hex, and octal
http://vim.sourceforge.net/tip_view.php?tip_id=

dont know if you guys know this or not, but i was trying to make the word "hello" to upper case by trying "gaUw" (=
which didnt work but it showed the decimal, hex, and octal of the char under the cursor... ncie to know.

VimTip 311: Open the folder containing the currently open file
http://vim.sourceforge.net/tip_view.php?tip_id=

Occasionally, on windows, I have files open in gvim, that the folder for that file is not open. This key map opens the folder that contains the currently open file. The expand() is so that we don't try to open the folder of an anonymous buffer, we would get an explorer error dialog in that case.

if has("gui_running")
 if has("win32")
    " Open the folder containing the currently open file. Double <CR> at end
    " is so you don't have to hit return after command. Double quotes are
    " not necessary in the 'explorer.exe %:p:h' section.
    :map <silent> <C-F5> :if expand("%:p:h") != ""<CR>:!start explorer.exe %:p:h<CR>:endif<CR><CR>
  endif
endif

Tom.

VimTip 312: Copy, Cut, and Paste
http://vim.sourceforge.net/tip_view.php?tip_id=

PS: copy, cut, and paste are the words from (usually) gui editor.

Ever try to cut (or copy) some lines and paste to another place?
If you need to count the lines first, then try these to eliminate counting task.

Cut and Paste:

1. Place the cursor at the beginning of the block you want to CUT.
2. Mark it with md
3. Go to the end of the block.
4. Cut it with d'd
5. Go to the new location that you want to PASTE those text.
6. Press P.

Copy and Paste:

1. Place the cursor at the beginning of the block you want to COPY.
2. Mark it with my
3. Go to the end of the block.
4. Cut it with y'y
5. Go to the new location that you want to PASTE those text.
6. Press P.

The name of the mark used is related to the operation (d:delete or y:yank).
I found that those mark names requires minimal movement of my finger. ;)

VimTip 313: printing using kprinter (unix + kde)
http://vim.sourceforge.net/tip_view.php?tip_id=

just add
set printexpr=system('kprinter'\ .\ '\ '\ .\ v:fname_in)\ .\ delete(v:fname_in)\ +\ v:shell_error
to your ~/.vimrc; further on all your printing will be piped through the nice and consistent print-dialog of kde.

lg,
tomte

VimTip 314: Insert and back...
http://vim.sourceforge.net/tip_view.php?tip_id=

this is related to vimtip #289 in terms of programmers (like I) too lazy to move their hands to reach the far far away <esc> key.... joking! :)
  actually the less your hands move around the faster you type, and the fester you type the more time you have on your hands to think of "what" you type...

here is a small snippet from my mappings file, ready to speed things up:
// the key overloading might be a somewhat confusing at first....

--cut---
imap <S-Space> <esc>l
imap <C-CR> <esc>o
imap <S-CR> <esc>O

nmap <S-Space> i
nmap <space><space> i
nnoremap <CR> o
nmap <S-CR> O

---uncut---

Good luck!!

VimTip 315: "Smart <home>"
http://vim.sourceforge.net/tip_view.php?tip_id=

to make it faster to navigate through indented code here is a common way to "go home"...

---cut---
fun! s:SmartHome()
    if col('.') != match(getline('.'), '\S')+1
        norm ^
    else
        :call cursor(line('.'),2)
        norm h
    endif
endfun
inoremap <silent><home> <C-O>:call <SID>SmartHome()<CR>
nnoremap <silent><home> :call <SID>SmartHome()<CR>
vnoremap <silent><home> :call <SID>SmartHome()<CR>

---uncut---

what this snippet does is make the <home> key behave as it does in such IDEs as PythonWin or MSVisualStudio, and that is first go to the first non whitespace, and then to the first char on the line.

VimTip 316: Using /pattern/ search in a script
http://vim.sourceforge.net/tip_view.php?tip_id=

There are a number of ways you can search for a pattern in a script.   The search function is the typical way to search for a pattern.  But, it has limited options.  In particular, there are no options to control the position of the cursor after it matches the pattern.

Instead you can use :normal command.  The secret is to add a <CR> (^M) on the end of the command.   For example, to search for "pattern" and move the cursor to the end of the matching pattern issue the command:

:normal /pattern/e+1^M

where ^M is a real carriage return.  It can be entered with <c-v><c-m>.

Another use is when you want to enter a bunch of normal commands together.  For example, if you were looking to find a '{' to highlight and delete a C block.  The '{' may not be on the same line so you can't use the "f" normal command.

:normal V/{/^M%d

A drawback to using the normal command is that if the pattern does not match then it is difficult to detect.  Also, you can get in trouble with the wrapscan setting.

For more information about these commands look at

:help /
:help normal
:help search()

VimTip 317: Mozilla Vim Keybindings
http://vim.sourceforge.net/tip_view.php?tip_id=

If you use VIM you like the h, j, k, and l movement keys.  I found myself annoyed at not having these movement keys available when browsing web pages.  Moving to the arrow keys on a laptop is annoying to just scroll the page.

Locate your mozilla/res/builtin directory (varies by platform). You could search for htmlBindings.xml to find it. (ie. locate htmlBindings.xml.

On Mac OS X it's inside the Mozilla application bundle.  /Applications/Mozilla/Mozilla.app/Contents/MacOS/res/builtin.

Create a new XML file called userHTMLBindings.xml, making it executable for all users and making sure the CRLF format is the same as htmlBindings.xml.  i.e. on Mac OS X most files use \r but Vim writes \n instead. You can either save the file with Vim as a Mac formatted file or use tr '\n' '\r' < input.xml > output.xml to convert the file.

Place the following XML into the userHTMLBindings.xml file.

<?xml version="1.0"?>

<bindings id="htmlBindings"
   xmlns="http://www.mozilla.org/xbl"
   xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">

  <binding id="browserUser">
    <handlers>
      <handler event="keypress" key="h" command="cmd_scrollLeft"/>
      <handler event="keypress" key="j" command="cmd_scrollLineDown"/>
      <handler event="keypress" key="k" command="cmd_scrollLineUp"/>
      <handler event="keypress" key="l" command="cmd_scrollRight"/>
    </handlers>
  </binding>
    </bindings>

There are many more bindings one could configure to get Vim like keybindings.  You can read http://www.mozilla.org/unix/customizing.html#keys for more information.

PS.  I love the keymaster/gatekeeper xul reference in the xul URL above.  It's from the original GhostBusters movie.  ;-)




VimTip 318: Extended Bracket and Parenthesis + extras for perl
http://vim.sourceforge.net/tip_view.php?tip_id=

This is an extension of vimtip #153
I found this tip useful, but the jump seemed out of place for me, I couldn't enter just one ' or ", and so I created an improvement
Basically, I set it up so that when you're in perl and have a non keyword charcter, (except for @, $ and % for perl) and you type a { you get:
{
       | <- cursor
}
Where as, when I have a keyword I get:
word{}
With the cursor in the middle, for hashes in perl.  I can jump out of any block, except the "" or '' blocks, by typing their closing charcter.  So } jumps me out past the next } in the file.

Warning, this search may wrap around.

Finally, I made it so that, using the alt key,
<Alt-'> inserts a '
<Alt-/> inserts a "
<Alt-[> inserts a [
<Alt-]> inserts a ]
<Alt--> inserts a {
<Alt-=> inserts a }
<Alt-,> inserts a <
<Alt-.> inserts a >

"########################################
" File -		matchMe.vim
" Date -		Wednesday, August 21, 2002
"########################################

" This code fixes my problem with
" does the one format for perl and still keeps hashes
function! InsertBrackets()
	let fileType = &ft

	if fileType == 'perl'
		let col = col('.') - 1
		if !col || getline('.')[col - 1] !~ '\k' && getline('.')[col - 1] !~ '\$' && getline('.')[col - 1] !~ '@' && getline('.')[col - 1] !~ '%'  && getline('.')[col - 1] !~ '#'
			return "{\<cr>\<bs>}\<esc>ko"
		else
			return "{}\<esc>i\<c-o>:echo \<cr>"
		endif
	else
		return "{\<cr>\<bs>}\<esc>ko"
	endif
endfunction

" This code jumps out of the brackets
function! JumpNext(normChar)
	let ret = "\<space>\<esc>ma\<left>/\\".a:normChar."\<cr>mb`ai\<del>\<esc>`bi\<right>"
	return ret
endfunction

" mappings
inoremap " ""<esc>i<c-o>:echo <cr>
inoremap ' ''<esc>i<c-o>:echo <cr>
inoremap < <><esc>i<c-o>:echo <cr>
inoremap ( ()<esc>i<c-o>:echo <cr>
inoremap [ []<esc>i<c-o>:echo <cr>
inoremap { <c-r>=InsertBrackets ()<cr>
inoremap > <c-r>=JumpNext(">")<cr>
inoremap ) <c-r>=JumpNext(")")<cr>
inoremap ] <c-r>=JumpNext("]")<cr>
inoremap } <c-r>=JumpNext("}")<cr>
inoremap <m-[> [
inoremap <m-]> ]
inoremap <m-/> "
inoremap <m--> {
inoremap <m-=> }
inoremap <m-,> <
inoremap <m-.> >
inoremap <m-'> '

"########################################
" End Of File
"########################################

If you have any other suggestions, drop a note...

VimTip 319: text formatting (lining up ='s,('s etc))
http://vim.sourceforge.net/tip_view.php?tip_id=

some time onw would like to reformat text like
a=1;
foo=2;
longstring=1;
c=2

to

a              =1;
foo           =2;
longstring  =1;
c              =2;

Note I am not sure wether the code above is displayed properly in your browsers what  is basically shows is all the ='s are lined up in a single column
and this  is how we achive it
0f=20i<space><esc>020lvf=hx
and this is what it does
0                             goes to first column
f=                             finds next occurance of = on current line
20i<space><esc>         inserts 20 spaces before =
0                               goesback to first column
20l                             forward 20 column
vf=hx                         deletes everything up to the = sign

VimTip 320: Borland pageup/down behavier
http://vim.sourceforge.net/tip_view.php?tip_id=

borlandbehavier = the cursor keeps the same xy position during pageup/down

Im new to VIM scripting, im sure it can be done smarter?
I read vimtip #105 and it gave me a clue of how BorlandPageUp/Down could be done.

" i could'nt find any get_number_of_visible_lines function, so i made my own.
function GetNumberOfVisibleLines()
    let cur_line = line(".")
    let cur_col = virtcol(".")
    normal H
    let top_line = line(".")
    normal L
    let bot_line = line(".")

    execute "normal " . cur_line . "G"
    execute "normal " . cur_col . "|"
    return bot_line - top_line
endfunc

" noremap <PageUp> 39<C-U>:set scroll=0<CR>
function! MyPageUp()
    let visible_lines = GetNumberOfVisibleLines()
    execute "normal " . visible_lines . "\<C-U>:set scroll=0\r"
endfunction

" noremap <PageDown> 39<C-D>:set scroll=0<CR>
function! MyPageDown()
    let visible_lines = GetNumberOfVisibleLines()
    execute "normal " . visible_lines . "\<C-D>:set scroll=0\r"
endfunction

" BorlandPascal pageup/down behavier!
" todo: when hitting top/bottom of file, then restore Y to lastY
noremap <PageUp> :call MyPageUp()<CR>
noremap <PageDown> :call MyPageDown()<CR>

VimTip 321: Centura swap with upper/lower line behavier
http://vim.sourceforge.net/tip_view.php?tip_id=

I was once forced to use a windows development suite called "Centura".
The only good thing i remember was its swap current_line with upper/lower line.

function! MySwapUp()
    let cur_col = virtcol(".")
    normal ddkkp
    execute "normal " . cur_col . "|"
endfunction

function! MySwapDown()
    let cur_col = virtcol(".")
    normal ddp
    execute "normal " . cur_col . "|"
endfunction

" swap lines and preserve cursorx
" todo: in visual mode, perform swap with line before/after the selection
noremap <S-Up> :call MySwapUp()<CR>
noremap <S-Down> :call MySwapDown()<CR>

VimTip 322: text template with placeholders
http://vim.sourceforge.net/tip_view.php?tip_id=

Many scripts/ftplugin provide text or code templates. Sadly none of the marks the places where you are supposed to "fill in the form".
My own code templates for C/C++ insert a triple percent (%%%) where you are supposed to enter something. I mapped ;; to find the next %%% and change them.
All the template mappings are insert-mode only, while the "skip to next placeholder" is both insert and normal mode enabled.

A complete for-loop template for C++ looks like:

:imap <buffer> ;fo <C-O>mzfor( %%%; %%%; %%%)<CR>{ // %%%<CR>%%%<CR>}<CR><C-O>'z;;

The command to go to the next placeholder is this:

:imap <buffer> ;; <C-O>/%%%<CR><C-O>c3l
:nmap <buffer> ;; /%%%<CR>c3l

Every time I need a for-loop ;fo produces this ( _ is the cursor position) :
for( _; %%% ; %%%)
{ // %%%
  %%%
}

Now I enter starting value (i=0):
for( i=0_; %%% ; %%%)
{ // %%%
  %%%
}

and go to the condition using ;;
for( i=0; _ ; %%%)
{ // %%%
  %%%
}

and so forth.

The choice of %%% proved to be almost universal, it even works in MATLAB or LaTeX where % is the comment character.

Even if you forget to replace one %%%, that's not a problem as the compiler flags is as a syntax error (except MATLAB and LaTeX, of course).

It made my life easier, maybe it works for you.

VimTip 323: using folders with latex
http://vim.sourceforge.net/tip_view.php?tip_id=

set foldmarker=\\begin,\\end
set foldmethod=marker

this is useful with big latex document

VimTip 324: Search and replace in files named NAME
http://vim.sourceforge.net/tip_view.php?tip_id=

I'm not sure if there is a simple way to do this from within Vim, but, I wrote this simple script that does it. It basically searches for files named NAMED (whatever name pass) for a given string and replaces that with a given string:
find_replace.sh NAMED "string_to_find" "string_to_replace"

This is all done from the command line without opening Vim.

Of course one could do things like:
                    :let n = 1
                    :while n <= argc()      " loop over all files in arglist
                    :  exe "argument " . n
                    :  " start at the last char in the file and wrap for the
                    :  " first search to find match at start of file
                    :  normal G$
                    :  let flags = "w"
                    :  while search("foo", flags) > 0
                    :    s/foo/bar/g
                    :    let flags = "W"
                    :  endwhile
                    :  update               " write the file if modified
                    :  let n = n + 1
                    :endwhile

As suggested in the Vim help files :-) but, I wanted to go and find only these files... here is the script:
      1 #!/bin/sh
      2 # Luis Mondesi < lemsx1@hotmail.com >
      3 # DESCRIPTION:
      4 #   it uses vim to replace a given string for
      5 #   another in a  number of files
      6 #
      7 # usage:
      8 #   find_replace.sh file "string" "replace"
      9 #
     10 if [ $1 -a $2 -a $3 ]; then
     11     for i in `find . -name "$1" -type f | xargs grep -l $2`; do
     12         # how do search and replace
     13         # the screen might flicker... vim opening and closing...
     14         vim -c ":%s/$2/$3/g" -c ":wq" $i
     15     done
     16     exit 0
     17 fi
     18 # I should never reach here
     19 echo -e "USAGE: find_replace.sh file 'string' 'replace' \n\n"
     20 exit 1

VimTip 325: Errorformat for java/ant/junit/cygwin/bash
http://vim.sourceforge.net/tip_view.php?tip_id=

If you program in Java and use Jakarta ant for builds *and* if you have the
bash shell, this tip will make your development experience a little
smoother.

This tip will result in a working compile/edit/debug system (in Win32
vim/gvim and in Cygwin vim) that takes you to the exact lines where the
build fails, whether the failure is a compilation error or a junit test
failure.  If you use bash on a linux box, you shouldn't have to change very
much to get everything to work.

There are 6 sections:
1. set up your build script
2. set up makeprg
3. set up shell options
4. set up path formatting options
5. set up your errorformat
6. set up key mappings

Set up build script
-------------------
Add the following script to your path (I use /usr/local/bin/):

mymake:
#!/bin/bash
cd /work/
ant -emacs $* 2>&1 | tr '\\' / | tr ^M ' ' | sed -u -n -f /usr/local/bin/testerrors.sed | tee /tmp/errors

Comment: sed -u is non-standard, use the code at:
http://mail.gnu.org/pipermail/bug-gnu-utils/2002-May/000192.html to get
the -u option for sed (this avoids waiting for the build output to get to
the screen)

testerrors.sed:
# This assumes that all your junit test cases are in a com.* package
/^Running com\./ {
    # duplicate the line
    s!\(.*\)!\1\
\1!
    P

    # turn the test package into a directory path for %D errorformat
    s!.*\(com\..*\)\.[A-Za-z_][A-Za-z0-9_]*!\1!
    s!\.!/!g
    s!.*!Entering: /work/src/&!

    # print the line and go on
    p
    n
}

# just pass any unmatched lines through
p

Set up makeprg
--------------
Add the following lines to your vimrc:
  autocmd BufNewFile,BufRead /work/*.java set makeprg=mymake
  autocmd BufNewFile,BufRead ?:/work/*.java set makeprg=mymake

Set up shell options
--------------------
Add the following lines to your vimrc:
  " in order to have bash as the shell for win32 vi.exe and gvim.exe, you have
  " to set these options, and also build vimrun.exe in the cygwin environment
  " so that the system() call is executed via bash, not cmd.exe -- the command
  " to build vimrun.exe is "make -f Make_cyg.mak vimrun.exe"
  set shell=bash.exe
  set shellcmdflag=-c
  set shellslash

Also to use this environment in Win32 gvim, you must recompile vimrun so
that gvim invokes the shell via bash, not via cmd.exe.

Set up path formatting options
------------------------------
Add the following lines to your vimrc:
  " allows DOS file names from UNIX (Cygwin) vim
  set isfname+=\

Set up your errorformat
-----------------------
Add the following lines to your vimrc:
  " the "\%DEntering:\ %f," rule relies on a sed script which generates
  " "Entering: " messages for each test class run (the directory name is
  " generated from the test class package and a hard-coded src root)

  " the "%\\C" at the start of the exception matching line tells to match
  " case-exact (the exception mathching lines rely on the %D rule that sets
  " up the correct directory from the package structure)

  " ant/junit/javac errorformat
  set errorformat=
      \%-G%.%#build.xml:%.%#,
      \%-G%.%#warning:\ %.%#,
      \%-G%\\C%.%#EXPECTED%.%#,
      \%f:%l:\ %#%m,
      \C:%f:%l:\ %m,
      \%DEntering:\ %f\ %\\=,
      \%ECaused\ by:%[%^:]%#:%\\=\ %\\=%m,
      \%ERoot\ cause:%[%^:]%#:%\\=\ %\\=%m,
      \%Ecom.%[%^:]%#:%\\=\ %\\=%m,
      \%Eorg.%[%^:]%#:%\\=\ %\\=%m,
      \%Ejava.%[%^:]%#:%\\=\ %\\=%m,
      \%Ejunit.%[%^:]%#:%\\=\ %\\=%m,
      \%-Z%\\C\	at\ com.mypkg.%.%#.test%[A-Z]%.%#(%f:%l)\ %\\=,
      \%-Z%\\C\	at\ com.mypkg.%.%#.setUp(%f:%l)\ %\\=,
      \%-Z%\\C\	at\ com.mypkg.%.%#.tearDown(%f:%l)\ %\\=,
      \%-Z%^\ %#%$,
      \%-C%.%#,
      \%-G%.%#

NOTE: Make sure that the character before "at" is an actual Tab character in
the three long -Z lines above

Here is an annotated version:
  set errorformat=
      " don't treat the build.xml diagnostic as an error
      \%-G%.%#build.xml:%.%#,

      " don't treat warning lines as errors
      \%-G%.%#warning:\ %.%#,

      " don't treat lines containing "EXPECTED" as errors
      \%-G%\\C%.%#EXPECTED%.%#,

      " look for this standard error format
      \%f:%l:\ %#%m,

      " look for this standard error format (with C: on front)
      \C:%f:%l:\ %m,

      " look for special sed-generated "Entering" lines while running tests
      \%DEntering:\ %f\ %\\=,

      " look for exceptions that were thrown in the tests, use the exception
      " description as the error message (don't know how to also include the
      " exception name in the error message)
      \%ECaused\ by:%[%^:]%#:%\\=\ %\\=%m,
      \%ERoot\ cause:%[%^:]%#:%\\=\ %\\=%m,
      \%Ecom.%[%^:]%#:%\\=\ %\\=%m,
      \%Eorg.%[%^:]%#:%\\=\ %\\=%m,
      \%Ejava.%[%^:]%#:%\\=\ %\\=%m,
      \%Ejunit.%[%^:]%#:%\\=\ %\\=%m,

      " using the "Entering" directory and the filename/line number provided
      " in the exception trace, go to the test method where the exception
      " was thrown
      \%-Z%\\C\	at\ com.mypkg.%.%#.test%[A-Z]%.%#(%f:%l)\ %\\=,
      \%-Z%\\C\	at\ com.mypkg.%.%#.setUp(%f:%l)\ %\\=,
      \%-Z%\\C\	at\ com.mypkg.%.%#.tearDown(%f:%l)\ %\\=,

      " empty lines terminate searching for further exception lines
      \%-Z%^\ %#%$,

      " any line can intervene between the start of an exception printout
      " and the line where it ends (last in list so that it is matched if
      " none of the other exception trace patterns match)
      \%-C%.%#,

      " all other lines are not errors
      \%-G%.%#

Set up key mappings
-------------------
Add the following lines to your vimrc:
  nmap <F10> :clist<CR>
  nmap <F11> :cprev<CR>
  nmap <F12> :cnext<CR>

This allows for quick error navigation.

NOTES
-----
Vim treats the "Entering: /work/src/..." messages in a weird way.  If there
are any actual errors, then these error lines are ignored by the :cnext and
:cprev commands, but if there are no real errors, then :cnext and :cprev
roll through these "Entering:" messages as if they were errors, but since
they don't include any line numbers, the cursor position is never moved.

I thought that this was strange, but even stranger, it is programmed
directly into the vim error handling code to function exactly this way.
There were no comments, and nobody responded on the vim mailing list, so I
just decided to live with it.

The upshot of it all is that if you see an error like "Entering:", chances
are that your build succeeded and all the tests ran without a problem.

Hope this helps...

Mail me with bugs at jdsumsion at earthlink.net.

VimTip 326: Help for VIM Help (VIM QuickRef)
http://vim.sourceforge.net/tip_view.php?tip_id=

Type
:help quickref
or
:h quic

And get a VIM Command Quick Reference Page brilliant for beginners & oldtimers alike

type
:h help to learn how to use help

Other Help Tips

# help for help
:h visual<C-D><tab>     : obtain  list of all visual help topics
                        : Then use tab to step thru them
:h ctrl<C-D>            : list help of all control keys
:h :r                   : help for :ex command
:h CTRL-R               : normal mode
:h \r                   : what's \r in a regexp
:h i_CTRL-R             : help for say <C-R> in insert mode
:h c_CTRL-R             : help for say <C-R> in command mode
:h v_CTRL-V             : visual mode
:h tutor              : VIM Tutor

These are also listed in my Best Of VIM Tips vimtip #305

VimTip 327: key mappings
http://vim.sourceforge.net/tip_view.php?tip_id=

I use my left thumb for the alt key and right for the space. Using this combo, you can get
some useful key maps for which you don't have to move your hands. I find I have to turn
my hand a little to press the left ctrl key.

These are some maps i use for C programming.

map ' `
map <C-f> :w<C-m>:!make<C-m>
map <M-]> <C-]>                                         Tags
map <M-[> <C-t>                                          Tags
map <M-u> :!ctags -R *<C-m>                                          Build Tags
map <M-c> I/*<Esc>A*/<Esc>                                          Comment current line
map <M-d> ^xx$xx                                          Delete comment for a single line
map <M-l> [{zf%                                          Fold upto the enclosing brace level
map <M-o> zo                                           open fold
map <M-i> zc                                          close fold
map <M-.> :cn<C-m>                                          Go to next error in list
map <M-,> :cp<C-m>                                          previous error in list

imap <Tab> <C-p>                                                  Complete word
inoremap <S-Tab> <Tab>                                                  Tab
inoremap { <CR>{<CR>                                                  Brace and line
inoremap } <CR>}                                                  brace and line. saves one enter stroke

imap <M-j> <Esc>                                                  Escape. Don't want to move my hand to esc key.
imap <M-k> <C-y>                                                  Copy line from above.
imap <M-q> /*  */<Esc>hhi                                        Comment selected lines

noremap <M-r> ddko{<C-m>}<Esc>kpko             Convert a simple statement to a compound statement. And place cursor above prev line.
noremap <M-k> ddko{<C-m>}<Esc>kpo             Same as above but place cursor below old line.

vnoremap <M-j> <Esc>
vnoremap <M-c> di/*<C-m>/<C-m><Esc>kkp           Commented selected text

nmap <M-n> :noh<CR>                       No hilight

Bye,
    Nithin.

VimTip 328: Vim in Microsoft Visual Foxpro
http://vim.sourceforge.net/tip_view.php?tip_id=

You can tell MS VFP to use an external
editor for editing project files.
To tell MS VFP to use Vim:

start regedit
locate
[HKEY_CURRENT_USER
 \Software
  \Microsoft
   \VisualFoxPro
    \5.0
     \Options]

and create a new item
TEDIT
with string content
"/N C:\Progra~1\vim\vim61\gvim.exe"
(or whatever your path to Vim happens to be.)

This will not replace the internal VFP
editor for such things as modifying the
"click method" for a button
(unfortunately),
but when you modify a program, VFP will
fire up gvim.

Start MS VFP, start Help and
look for TEDIT. ;-)

VimTip 329: A map for swapping words
http://vim.sourceforge.net/tip_view.php?tip_id=

Put the following map into your <.vimrc>:

  nmap <silent> gw "_yiw:s/\(\%#\w\+\)\(\W\+\)\(\w\+\)/\3\2\1/<cr><c-o><c-l>

Then when you put the cursor on or in a word, press "gw", and
the word will be swapped with the next word.  The words may
even be separated by punctuation (such as "abc = def").

While we're talking swapping, here's a map for swapping characters:

  nmap <silent> gc    xph

This hint was formed in a collaboration between
Chip Campbell - Arun Easi - Benji Fisher

VimTip 330: how to stop auto indenting
http://vim.sourceforge.net/tip_view.php?tip_id=

Since VIM 6.0 the indent has been improved so much.
But sometimes when we are pasting formated text (source code or HTML etc)
into a buffer, VIM indents again so that lines will be padded with too
much spaces.

Setting nocindent, noautoindent, nosmartindent still cannot stop this.
All you need to do is "set paste", then paste your stuff, and then
"set nopaste" again.

Ref: indentexpr

VimTip 331: modline magic...
http://vim.sourceforge.net/tip_view.php?tip_id=

  One  of the  things about  vim that  are both  quite simple  yet very
useful is that you can store  by-file settings... that is each file can
contain settings specific to it. this  thing is called a modline (:help
modline). though this  is limited to only the  'set' command arguments,
you can do allot of local to  file things like the indent type, folding
method and so on.

the syntax is as follows:

// vim:set ts=4 sw=4 nowrap:

or

/* vim:noai:ts=2:sw=4: */

  The modlines can be contained in comments so as to not interfere with
the file  syntax (shown here  for C/C++). these  lines are read  by vim
when it loads the  file, and they can either be in the  first or last 5
lines (by default).

refer to ':help modline'

//and a happy 20th birthday to the good old smiley!! :-)

VimTip 332: make footnotes in vim
http://vim.sourceforge.net/tip_view.php?tip_id=

I found at http://groups.google.com/groups?q=vim+changing+shell+to+zsh&hl=en&lr=&ie=UTF-8&selm=S_Rh9.716%24a5.124150%40news.uchicago.edu&rnum=4
a macro to insert footnotes in vim, but it doesn't work as of vim6.0.
so i wrote my own; this macro requires two differents shortcuts, one for entering the first footnote, the other one for all subsequent footnotes.

when you hit "K0" (first footnote) or "KK" (all other footnotes) in normal mode, your cursor is positionned at the end of the document, in the footnote & in insert mode. The "a" bookmark is set to the place where you entered the footnote in the text. so a "`a" will bring you back to the location of the footnote in the text.

" for now requires entering K0 for the first footnote and then KK                                  nmap K0 i[0]<esc>maG$i<end><enter>[0]
nmap KK maG$?\[[0-9]*\]<enter>yt]G$i<end><enter><esc>p<C-a>i<end>]<esc>`aP<C-a><right>i]<esc>maG$i<end><end>

VimTip 333: Syntax-based folding for c/c++/java
http://vim.sourceforge.net/tip_view.php?tip_id=

Here's a function to toggle the use of syntax-based folding for a c/c++/java file. It also handles folding markers.

function! OutlineToggle()
    if (! exists ("b:outline_mode"))
        let b:outline_mode = 0
    endif

    if (b:outline_mode == 0)
        syn region myFold start="{" end="}" transparent fold
        syn sync fromstart
        set foldmethod=syntax

        silent! exec "%s/{{{/<<</"
        silent! exec "%s/}}}/>>>/"

        let b:outline_mode = 1
    else
        set foldmethod=marker

        silent! exec "%s/<<</{{{/"
        silent! exec "%s/>>>/}}}/"

        let b:outline_mode = 0
    endif
endfunction

VimTip 334: Loading scripts in .vimrc safely
http://vim.sourceforge.net/tip_view.php?tip_id=

If you copy your .vimrc to many places, you might get a problem:
writing a portable .vimrc is sometimes painful.
Maybe in some places you have latest VIM6.1, and in some places
you have VIM 5.x. And maybe you have some favorite scripts in
your own computer while other places does not.

Here're some tips and examples on writing portable .vimrc that will not make error
messages when environment changes:

(1) Check version:
if version >= 600
    set foldcolumn=2
endif

(2) Use environment variables:
source $VIMRUNTIME/vimrc_example.vim

(3) Loading scripts(especially useful for scripts just merged into standard macros):
if filereadable($VIMRUNTIME . "/macros/matchit.vim")
  source $VIMRUNTIME/macros/matchit.vim
endif

VimTip 335: Copy C++ function declaration into implementation file
http://vim.sourceforge.net/tip_view.php?tip_id=

There's a handy plug in for MS Visual Studio called CodeWiz that has a nifty ability to copy a function declaration and deposit it into the implementation file on command.  I actually missed while using vim, so I wrote an approximation of that capability.  This isn't foolproof, but it works alright.

" Copy Function Declaration from a header file into the implementation file.
nmap <F5> "lYml[[kw"cye'l
nmap <F6> ma:let @n=@/<cr>"lp==:s/\<virtual\>/\/\*&\*\//e<cr>:s/\<static\>/\/\*&\*\//e<cr>:s/\s*=\s*0\s*//e<cr>:s/(.\{-}\zs=\s*[^,)]\{-1,}\>\ze\(\*\/\)\@!.*)/\/\*&\*\//e<cr>:s/(.\{-}\zs=\s*[^,)]\{-1,}\>\ze\(\*\/\)\@!.*)/\/\*&\*\//e<cr>:s/(.\{-}\zs=\s*[^,)]\{-1,}\>\ze\(\*\/\)\@!.*)/\/\*&\*\//e<cr>:let @/=@n<cr>'ajf(b"cPa::<esc>f;s<cr>{<cr>}<cr><esc>kk

To use this, source it into vim, for example by placing it in your vimrc, press F5 in normal mode with the cursor on the line in the header file that declares the function you wish to copy.  Then go to your implementation file and hit F6 in normal mode with the cursor where you want the function implementation inserted.

VimTip 336: type the line number and press enter to get there
http://vim.sourceforge.net/tip_view.php?tip_id=

an easy way to  to get to a line (whose number we know)  faster  is to combine some existing ways that are;
:132<ENTER>
or
123G
or
123gg

and the solution is to map in normal mode the enter to G

so with
:nmap <ENTER> G
we can type the line number and then press enter to get there...

it's very small gain ... but it is!!!

VimTip 337: editing remote files via scp in vim
http://vim.sourceforge.net/tip_view.php?tip_id=

VIM 6.x has the netrw plugin installed as a standard plugin. It allows you to edit files via ftp, rcp, scp, or http. If your username differs on the remote host, however, and you're trying to use scp, things can get a little wierd, particularly if you're not editing a document under your user tree.

To get around this, try opening the file as follows:
    vim scp://remoteuser@server.tld//path/to/document
Notice two things: adding the "remoteuser@" syntax, and the use of two slashes (//) between the servername and the path. The first sets the remote user so that scp will not grab the $USERNAME environment variable, the second will appropriately set the absolute path.

VimTip 338: vim + cscope + cygwin
http://vim.sourceforge.net/tip_view.php?tip_id=

Tip #292 doesn't seem to be true, at least not anymore. I am using cscope 15.4 and vim 6.1. With a few hacks, I was able to get cscope to work with vim under cygwin for Windows 2000. I did not need to change the sprintf line. The hacks included

1. Copying if_cscope.? to the src directory and the if_cscope.pro to the src/proto directory. These files do not come standard with the Windows source distribution of vim.  (I think it should - anybody in charge of distribution listening?)

2. Edit if_cscope.c to make the following changes:

Add the following includes:
    #include <sys/unistd.h>
    #include <sys/signal.h>

3. Edit Make_cyg.mak

Add if_cscope.o to OBJ variable.

Add a rule for this at the end

$(OUTDIR)/if_cscope.o: if_cscope.c $(INCL)
$(CC) -c $(CFLAGS) if_cscope.c -o $(OUTDIR)/if_cscope.o

Uncomment the lines following

#>>>>> uncomment this block to build a GUI version

4. Edit feature.h

Force cscope compilation:

# define FEAT_CSCOPE

5. make -f Make_cyg.mak GUI=yes

6. Note that the env variable TMPDIR should be defined in VIM for cscope to work correctly.

That should do it. Somebody in charge of distribution please make this standard. It would save a lot of trouble.

VimTip 339: "tabbed windows"
http://vim.sourceforge.net/tip_view.php?tip_id=

This is what I use to emulate the multi-tab environment of certain editors like EditPlus, and easly switch between multiple files being edited (opened with the :split command):

" put this in your .vimrc file to rotate windows with Alt-K / Alt-J
set winminheight=0
nmap <M-k> <C-W>r<C-W>k:resize<CR>
nmap <M-j> <C-W>j<C-W>R:resize<CR>
imap <M-k> <ESC><M-k>i
imap <M-j> <ESC><M-j>i
" end

The only problem is that after a :split you have to Alt-K-J to keep the new window "maximized".

VimTip 340: Visual Select And Search
http://vim.sourceforge.net/tip_view.php?tip_id=

The following visual select and search map is a combination of information
from Benji's vimrc file (vmap S y/<C-R>=escape(@",'/\')<CR>) and a tip that
mentions the "\n" to "\\\\n" substitution.

It works for special characters and multiple lines.

vmap \s y/\V<C-R>=substitute(escape(@",'/\'),"\n","\\\\n","g")<CR>/<CR>

Quick explanation:

vmap       visual map
\s         your choice
y          yank selected text
/          search delimiter
\V         no magic, just text
<C-R>=     expression
substitute substitute "\n" for "\\\\n"
escape     escape '/' (delimiter) and '\' in yanked text (@")
<CR>       end expression
/<CR>      search

Warning: Folding will not match if the foldexpr expression is using
getline() to match against a search pattern that spans multiple lines.

Enjoy.

VimTip 341: switch color schemes
http://vim.sourceforge.net/tip_view.php?tip_id=

This function is similar to the vimtip #211. I did not recognize that s.o.
already wrote a function for that, but this one has one advantage:
It just takes all possible colorschemes in the given directorys and rotates
them. Just put the following code in your .vimrc file:

let SwitchSchemesFiles = globpath("$VIMRUNTIME,$HOME/.vim","colors/*.vim")
let SwitchSchemesIndex = 0

function! SwitchSchemes()
        let sep="\n"
        if g:SwitchSchemesIndex == -1
                let g:SwitchSchemesIndex=0
        endif

        exe "source " . NextElement(g:SwitchSchemesFiles, sep, g:SwitchSchemesIndex)
        let g:SwitchSchemesIndex = NextIndex(g:SwitchSchemesFiles, sep, g:SwitchSchemesIndex + 1)
endfunction

In addition you need the http://www.vim.org/script.php?script_id=109
Put it in the plugin directory.

If you use e.g. a map to F12, you can easily switch between all
installed themes:
map <f12>  :call SwitchSchemes()<CR>

VimTip 342: Remap <ESC>
http://vim.sourceforge.net/tip_view.php?tip_id=

Tired of hunting down <ESC> at upper-left of your keyboard while using a keyboard with useless Windows keys?

Well, remap them -- use xmodmap. I'm using Debian and my xmodmap config file is in /etc/X11/xinit/xmodmap, ymmv.
You may have to use xmodmap directly (from ~/.xinitrc  in *BSD or whatever).

Anyway, here's my xmodmap:
[ .. other irrelevant mappings skipped ... ]
keycode 115 = braceleft
keycode 116 = Escape
keycode 117 = braceright

Btw, the keys are:
    * 115 - Windows key, between the left-hand Ctrl and Alt keys
    * 116 - Windows key, to the right of the AltGr key
    * 117 - Menu key, to the left of the right-hand Ctrl key

Valid for all environments with X, on *BSD as well as on Linux.
You get the same mappings under ordinary console by modifying the console keymap file (pretty self-explanatory), in my case it's
/usr/share/keymaps/i386/qwerty/et.kmap.gz.

I'm using mapping braces to winkeys because of my Estonian keyboard.

VimTip 343: Faster loading of large files
http://vim.sourceforge.net/tip_view.php?tip_id=

In the past I experienced long loading times for large files ( size > 10MB )
These files are normally generated by SQL tracing, XML message based
protocols tracing etc.
One of the causes of long loading times was syntax parsing, creating swap file etc.
Normally one want to view these files and remove not relevant details by
deleting lines, but do not want to have undo capabilities and auto recalculation of
syntax highlighting.

The code below, I put in my _vimrc to switch off a number of defaults for
large files.

One can modify the g:LargeFile variable and reload a file to test:
:let g:LargeFile=10
:e

It would be interesting to know if others have more or better suggestions.

" Protect large files from sourcing and other overhead.
" Files become read only
if !exists("my_auto_commands_loaded")
        let my_auto_commands_loaded = 1
        " Large files are > 10M
        " Set options:
        " 	    eventignore+=FileType (no syntax highlighting etc
        "            assumes FileType always on)
        "       noswapfile (save copy of file)
        "       bufhidden=unload (save memory when other file is viewed)
        "       buftype=nowritefile (is read-only)
        "       undolevels=-1 (no undo possible)
        let g:LargeFile = 1024 * 1024 * 10
        augroup LargeFile
                autocmd BufReadPre * let f=expand("<afile>") | if getfsize(f) > g:LargeFile | set eventignore+=FileType | setlocal noswapfile bufhidden=unload buftype=nowrite undolevels=-1 | else | set eventignore-=FileType | endif
        augroup END
endif

VimTip 344: Cut / Copy / Delete / Paste Lines without knowing the number of lines
http://vim.sourceforge.net/tip_view.php?tip_id=

If you ever need to cut / copy / delete / paste lines without knowing the actual number of lines, here is what you should do.

1. In the command Mode, Go to the beginning of the first mark (lets say line 50).
2. Type: mk
3. Go to the end of your selection (lets say 100), using j's or Ctrl -F or anything. You don't need to count the lines.
4. Type: "ay'k (i.e. Double Quotes, <reg name from a-z>, <y-yank or d-delete>, single quote, k
5. The above command copies those lines into register a.
6. If you do "ad'k , it will delete them from the current location and copies them into register a.
7. You can paste those lines wherever you want just as you print from registers, i.e. "ap

I use this a lot, since I don't need to count the number of lines.

-Kdr

VimTip 345: Visual Studio + vim Quickfix mode + cygwin + XFree86
http://vim.sourceforge.net/tip_view.php?tip_id=

I run gvim inside a cygwin XFree86 session running WindowMaker.  Because I'm inside cygwin-XFree86, I can't use the useful VisVim plugin to step through Visual Studio compiler errors.  To work around this limitation, I wrote a Bash/Perl script that munges nmake output into something that has cygwin compliant path and is parseable by the default quickfix errorformat setting .

Here's what to do:

1.  install the following from cygwin:

- perl
- cygutils
- bash

2.  Set up Visual Studio to support command line compiles.   Basically this involves adding paths to the PATH, INCLUDE, and LIB environment variables.  See vcvars32.bat in the Visual Studio VC98/bin directory for guidelines.

3.  Export a makefile for your dsp project file via the Visual Studio "Project|Export Makefile..."

4.  Create the cygwin shell script defined below.  Put the script in '/bin/dovcmake'

---begin cut-----

#!/bin/bash
# This script takes output from
# Visual Studio's nmake and reformats
# it so that it can be parsed by
# cygwin's vim default errorformat
# setting
nmake /F $1 2>&1 | perl -n -e \
	'	chomp;
		if(/^([a-z]:[^(]+)\((\d+)\)(.+)$/i) {
			$f = $1; $l = $2; $m = $3;
			$f =~ s/\\/\//g;
			$cyp = `cygpath -au $f`; \
			chomp $cyp;
			print qq{"$cyp",$l:$m\n};}
		elsif(/error/i) {
			print qq{$_\n};
		}'

---end cut -----

5.  Add this map to your vimrc:

set makeprg=/bin/dovcmake
map <f7> :make <c-r>%<cr>

6.  Fire up cygwin vim and open the makefile from step 3.  If you hit F7, you'll automatically start a Visual Studio build and you'll be able to step through compiler errors via the :cp and :cn commands.

VimTip 346: Wrap text in HTML/XML tags after prompting for the tag name
http://vim.sourceforge.net/tip_view.php?tip_id=

Someone else posted this sometime ago on this mailing list, I have enhanced it slightly and made a tip out of it.
I thought it was pretty clever and very generic.

If you have a block of text and you want to wrap it in <TAG_NAME>...</TAG_NAME> then this function will prompt you for the tag name and wrap the text.

If there is no text VISUALLY selected, it will wrap the current word in the tag, otherwise it will wrap the visually selected text.

It will also strip off any leading spaces.
For the end tag, it will use the first word of the tag only.

Consider an ANT build file, which has tags like this:
<target name="init">
...
</target>

When prompted for the tag you would enter:
target name="init"

And it will wrap the text in:
<target name="init">
...
</target>

" Tag Select/Wrapper
" These mappings and TagSelection function will allow you to place " an XML tag around either the current word, or the current selected " text
nmap <Leader>t viw<Leader>t
vnoremap <Leader>t <Esc>:call TagSelection()<CR>

nmap <Leader>t viw<Leader>t
vnoremap <Leader>t <Esc>:call TagSelection()<CR>

function! TagSelection()
  let l:tag = input("Tag name? ")
  " exec "normal `>a</" . l:tag . ">\e"
  " Strip off all but the first work in the tag for the end tag
  exec "normal `>a</" .
              \ substitute( l:tag, '[ \t"]*\(\<\w*\>\).*', '\1>\e', "" )
  exec "normal `<i"
              \ substitute( l:tag, '[ \t"]*\(\<.*\)', '<\1>\e', "" )
endfunction

VimTip 347: Format paragraph without changing the cursor position
http://vim.sourceforge.net/tip_view.php?tip_id=

map <silent> <C-j> :let line=line(".")<CR>:let col=col(".")<CR>gqap:exec ":".line<CR>:exec "normal " . col . "\|"<CR>
imap <silent> <C-j> <Esc>:let line=line(".")<CR>:let col=col(".")<CR>gqap:exec ":".line<CR>:exec "normal " . col . "\|"<CR>a

VimTip 348: Quickly insert a single word
http://vim.sourceforge.net/tip_view.php?tip_id=

I've had something like this for a single character for some time, and this may be something that everyone is already doing, but it's really convenient for me.  These two mappings make it quick and easy to insert a word.

nmap <buffer> <silent> ,w :exec ":imap \<space\> \<space\>\<esc\>,BB"<cr>i
nmap <buffer> <silent> ,BB :exec ":iunmap \<space\>"<cr>

Given the sentence:

The quick fox.

To add the word "brown" you would put your curser on the f in fox and type ",w" (or whatever you decide is a good mapping).  Type the word brown.  As soon as you hit space you are out of insert mode.

If there's an easier way to do this, please feel free to comment.

Thanks.

VimTip 349: Format your xml document using xmllint
http://vim.sourceforge.net/tip_view.php?tip_id=

If you open an xml document that is either totally or partially unindented, you can use the GNU libxml2 libary's xmllint to reformat and align your document.  This is especially good if you want to save your xml documents using as little space as possible (which would be totally unindented).  Just add this under the autocmd section of your .vimrc file

au FileType xml exe ":silent 1,$!xmllint --format --recover - 2>/dev/null"

This instructs vim to take the entire contents of a *.xml file and pass it through xmllint, using the --format and --recover flags and silencing any errors that may occur.  This is generally a very effective process and will only mess up on very poorly typed (a large amout of incorrect syntax) xml documents.  Please note that xmllint only adds and removes structural space.  It does not remove space from regular text nodes (as doing so would be incorrect).

VimTip 350: when 'formatoptions' has o easily enter a non commented line: go/gO mappings
http://vim.sourceforge.net/tip_view.php?tip_id=

This is relevant when your 'formatoptions' has o.
From :h fo-table, "Automatically insert the current comment leader after hitting 'o' or 'O' in Normal mode."
I like this behavior enough to keep the o option, however at times I want to NOT insert the comment chars, and although manually deleting the added chars is not hard I present these simple mappings that delete the added chars automatically.

(from my .vimrc)
nnoremap go o<esc>S
nnoremap gO O<esc>S

This makes go open a new line under the cursor and removes inserted chars, while gO opens a new line above the cursor and removes inserted chars.

Your mileage will vary of course (:
Happy VIMing!

VimTip 351: Using quickfix in a different way
http://vim.sourceforge.net/tip_view.php?tip_id=

I'm a software developer and I find vim's quickfix (:help quickfix) very helpful.
You can also use this while debugging your code, in a slightly different way...

Usually, you will have some print messages in your code, and after the program
runs, you'll look at the output to see the execution trace (e.g which if-constructs
were taken, how many times did a while loop iterate.. ). If you precede these
statements with a <filename>:<linenumber>, then, the program output can be parsed
with a :cfile, and the execution trace becomes very simple.
For instance, in C++

   // fdebug is the pointer to the debug file called, debug.txt say.
   #define DEBUG_MESG( ) fprintf(fdebug, "%0s:%0d\n", __FILE__, __LINE__)

   ...


   function( )
   {
      ...
      if (something)
         DEBUG_MESG( );
      else
         DEBUG_MESG( );
      ...
   }

Open your code in vim and do a ":cfile debug.txt"

VimTip 352: disabling cabbrev
http://vim.sourceforge.net/tip_view.php?tip_id=

Have you ever been annoyed by an over-zealous cabbrev? A simple way to temporarily disable it is to set invpaste. Very convenient in combination with the pastetoggle key.

VimTip 353: Swap caps-lock and control keys using MS Windows Registry
http://vim.sourceforge.net/tip_view.php?tip_id=

This will allow you to use the caps-lock key as a control key. Makes using vim in win32 much nicer in my opinion.

Place the following text into a text file with the extension *.reg and update your registry by double-clicking the file:

REGEDIT4

[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Keyboard Layout]
"Scancode Map"=hex:00,00,00,00,00,00,00,00,02,00,00,00,1d,00,3a,00,00,00,00,00

VimTip 354: Find in files - recursively (NOT :grep!). Only for unix clones.
http://vim.sourceforge.net/tip_view.php?tip_id=

You probably know about the grep command in vim (:help grep)
There is one limitation of this - you can't search for a pattern recursively in files (why doesn't grep have some kind of -R option for searching recursively? Have looked around enough at the man pages for that..). The script below does this. Cut-paste this in to your .vimrc/_vimrc. Type ":Fif" (without arguments) to see usage.

   " Start of script
   " Location where the temporary file (.fif.tmp) would be stored
   let g:Fif_tmp_dir = "/tmp"
   function! Fif_fun(...)
      if a:0 == 0
         " Print usage info and quit
         echo "Usage: Fif <pattern-to-be-searched> <file-pattern>. E.g:"
         echo "Fif struct *.c"
         echo "searches for the word struct in all the c files from the current directory"
         return
      endif
      if a:0 != 2
          echohl Error
          echo "Error! Wrong number of arguments. Type :Fif with no arguments to see usage"
          echohl None
          return
      endif
      let tmp_file = g:Fif_tmp_dir . "/.fif.tmp"
      execute "!touch " . tmp_file . " 2> /dev/null"
      if ! filewritable(tmp_file)
         echohl Error
         echo "No permissions to create " . tmp_file
         echo "Try setting the g:Fif_tmp_dir variable to the right value"
         echohl None
         return
      endif
      " Put quotes around the file pattern
      let com_string = '!find . -name "' . a:2 . '" '
      " Do NOT put quotes around the pattern to be searched - leave it to the user
      let com_string = com_string . '-exec grep -n ' . a:1 . ' /dev/null {} \; > ' . tmp_file
      execute com_string
      if ! filereadable(tmp_file)
         echohl Error
         echo "Can't open " . tmp_file . " for reading"
         echohl None
         return
      endif
      execute "cfile " . tmp_file
      execute '!rm -f ' . tmp_file . ' 2> /dev/null'
   endfunction
   com -nargs=* Fif call Fif_fun(<f-args>)
   " End of script.

No vim magic here, just some shell util usage.
Tested on HPUX.
Should work on Windows with Cygwin. You'll have to
1. Remove those /dev/null's
2. Make sure that the Cygwin's find and grep utils are used, and not the windows ones
3. Change the default value of g:Fif_tmp_dir
4. Cygwin's grep differs from the version I have on HP. For forcing grep to print the filename, you'll have to give it a "-H" option, in addition to "-n"

Some more tinkering can be done with this.. for instance, if you want to search in all the text files, irrespective of the extention, you can consider doing something like this:

   " Find all files.
   let com_string = '!find . -type f -print '
   " Get the file type
   let com_string = com_string . '| xargs file '
   " Filter out the text files
   let com_string = com_string . "| awk '/text/ {print $1}' "
   " Some formatting to remove the trailing ':'
   let com_string = com_string . "| sed 's/://' "
   " grep for the pattern in all the files
   let com_string = com_string . '| xargs grep -n ' . a:1

Cheers!
Karthick.

VimTip 355: Comment Lines according to a given filetype
http://vim.sourceforge.net/tip_view.php?tip_id=

There is probably an easier way to do this, but, if I cannot find an easy solution for a given problem, I just device one that works for the meantime -- which usually becomes permanent :-) .

This function comments out lines according to file type. So if a file is .sh, it uses # to comment lines. And if a file is type .c it will start the comments with /* and end them with */.

Put this lines in your .vimrc file:
" -------- vimrc ---------
" comment out highlighted lines according to file type
" put a line like the following in your ~/.vim/filetype.vim file
" and remember to turn on filetype detection: filetype on
" au! BufRead,BufNewFile *.sh,*.tcl,*.php,*.pl let Comment="#"
" if the comment character for a given filetype happens to be @
" then use let Comment="\@" to avoid problems...
fun CommentLines()
    "let Comment="#" " shell, tcl, php, perl
    exe ":s@^@".g:Comment."@g"
    exe ":s@$@".g:EndComment."@g"
endfun
    " map visual mode keycombo 'co' to this function
vmap co :call CommentLines()<CR>
" ------- end vimrc -------

Now create a ~/.vim/filetype.vim file if you don't have one and add things like these to it (remember to put a line
filetype on, in your vimrc file ... again if you don't already have one. Vim needs to be compiled with filetype detection
support for this to work. You have been warned.):

-------- filetype.vim ---------

if exists("did_load_filetypes")
    finish
endif

augroup filetypedetect

    au! BufRead,BufNewFile *.inc,*.ihtml,*.html,*.tpl,*.class set filetype=php | let Comment="<!-- " | let EndComment=" -->"

    au! BufRead,BufNewFile *.sh,*.pl,*.tcl let Comment="#" | let EndComment=""

    au! BufRead,BufNewFile *.js set filetype=html | let Comment="//" | let EndComment=""

    au! BufRead,BufNewFile *.cc,*.php,*.cxx let Comment="//" | let EndComment=""

    au! BufRead,BufNewFile *.c,*.h let Comment="/*" | let EndComment="*/"

augroup END

------ end filetype.vim -------

All set, now whenever you are editing a file of those you have defined in your filetype.vim script, you can just go into Visual mode, highlight what you want to comment out, and type "co". Simple.

VimTip 356: Quick yank and paste
http://vim.sourceforge.net/tip_view.php?tip_id=

Since I didn't want to interfere with the standard Vim mappings I removed all the <C-c>, <C-v>, etc. mappings found in the default vimrc. But quickly copy-pasting text is a must, so I added the following keymaps. This is very simple, but it works like a charm.

vmap <C-Space> "ay
nmap <C-Space> "aP
imap <C-Space> <C-o>"ap
nmap <C-c> "ayiw

Niels

My vimrc if you're interested: http://home.student.utwente.nl/n.h.m.aandebrugh/_vimrc

VimTip 357: Adding a console to gdbvim
http://vim.sourceforge.net/tip_view.php?tip_id=

This tip shows how to enhance the gdbvim vimscript #84 by
making the outputs from gdb appear in a "console buffer"
inside vim.

"1.a) In gdbvim.vim, one needs to add the following two buffer
"     manipulation functions:

"--------------------------------------------------------
" Buffer manipulation functions {{{1
"
" function! s:GdbFocusBuf(nameref)  {{{2
" move the focus to the buffer nameref -- create
" it if it doesn't exist
" return the number of the currently focused buffer
"
function! s:GdbFocusBuf(nameref)
  let l:oldnr = bufnr("%")
  let l:win_nu = bufwinnr(a:nameref)
  if l:win_nu > 0
    execute l:win_nu "wincmd w"
  else
    if bufexists(a:nameref)
      execute "sbuffer" a:nameref
    else
      execute "new" a:nameref
    endif
  endif
  return l:oldnr
endfunction

" function! s:GdbAppendBuf(nameref, stuff) {{{2
" append stuff to buffer nameref
"
function! s:GdbAppendBuf(nameref, stuff)
   let l:oldnr = s:GdbFocusBuf(a:nameref)
   call append("$", a:stuff)
   execute "normal G\<End>"
   return l:oldnr
endfunction

"1.b) And modify the two source file management functions
"     to be as follows:

"--------------------------------------------------------
" Source file management functions {{{1
" function! Gdb_Bpt(id, file, linenum) {{{2
"
function! Gdb_Bpt(id, file, linenum)
        let s:nowfile = a:file
        let l:curnr = s:GdbFocusBuf(a:file)
        execute "sign unplace ". a:id
        execute "sign place " .  a:id ." name=breakpoint line=".a:linenum." file=".a:file
        execute a:linenum
endfunction

" function! Gdb_CurrFileLine(file, line) {{{2
"
function! Gdb_CurrFileLine(file, line)
        if a:file != 0
           let s:nowfile=a:file
        endif

        let l:curnr = s:GdbFocusBuf(s:nowfile)

        execute "silent! " . a:line . "foldopen"
        execute "sign unplace ". 1
        execute "sign place " .  1 ." name=current line=".a:line." file=".s:nowfile
        execute a:line
endf

"1.c) And add the following console function:

"--------------------------------------------------------
" function! Gdb_Console(stuff, set_prompt) {{{2
"
function! Gdb_Console(stuff, set_prompt)

  let l:fooey = s:GdbAppendBuf("console", a:stuff)

  if a:set_prompt == 1
      " What needs to happen here is to enter command mode
      " with the partial command ":Gdb " typed out.
      " The following line shows what doesn't work
      " call input(":Gdb ")
  endif
endfunction

"1.d) And while we are modifying gdbvim.vim, we could also
"     add a text section to the definitions of the signs:

"--------------------------------------------------------
sign define breakpoint linehl=DebugBreak    text=bb
sign define current    linehl=DebugStop     text=cc

#2) The subroutine worker in the perl script gdbvim needs to
#   be modified as indicated below.  The key points to note
#   are the two calls the vim-script function Gdb_Console().

# this function processes the gdb output, prints it and sends vim commands
sub worker # {{{
{
    vim_call('Gdb_interf_init(\"'.$PIPE.'\", \"'.$ENV{"PWD"}.'\")');
    print GDB_WTR "set prompt (gdb)\\n\n";
    while (<GDB_RDR>)
    {
        if (/^.*?gdb\)/)
        {
            print RL_WTR "READ\n";
            chomp ;
            print $_ . " ";
            vim_call("Gdb_Console(\\\"$_\\\", 1)");
        }
        else
        {
            my $stuff = $_;
            if(
                  s/Breakpoint ([0-9]+) at 0x.*: file ([^,]+), line ([0-9]+)./Gdb_Bpt($1,\\\"$2\\\",$3)/ ||
                  s/Breakpoint ([0-9]+), 0x.*at ([^,]+):([0-9]+)/Gdb_CurrFileLine(\\\"$2\\\",$3)/ ||
                  s/^\s*0x.*\s+at\s+(\S+):([0-9]+)/Gdb_CurrFileLine(\\\"$1\\\",$2)/ ||
                  s/\032\032([^:]*):([0-9]+).*/Gdb_CurrFileLine(\\\"$1\\\", $2)/  ||
                  s/^\s*0x\S+\s*([0-9]+)\s+.*/Gdb_CurrFileLine(0, $1)/
              )
              {
                  chomp;
                  vim_call($_);
              }
              print $stuff;
              chomp($stuff);
              # the next substitution is because I couldn't figure out how to
              # pass (from perl) double quotes inside string arguments to
              # vim-script functions
              $stuff =~ s/"/'/g;
              vim_call("Gdb_Console(\\\"$stuff\\\", 0)");
        }
    }
    vim_call("Gdb_interf_close()");
    close GDB_RDR; close GDB_WTR;
}; # }}}

That's all the modifications -- and now gdbvim will show
the output of gdb inside a vim.  (Errors from gdb won't
show up in the console but still go to the terminal.)

Happy gdbVimming!

Acknowledgment:
   I learnt about functions in vim-scripts by the process of tracking
   down an annoying behavior in cvscommand.vim vimscript #90.
   Also, the author of cvscommand.vim, Bob Hiestand, graciously
   improved my earlier versions of the functions GdbFoucBuf and
   GdbAppendBuf.

VimTip 358: Get a random colorscheme on vim startup
http://vim.sourceforge.net/tip_view.php?tip_id=

This script picks a colorscheme randomly among all available schemes files
when vim starts up.  This is similar to vimtip #341, but differs in that it
is independent of other script liblaries, besides the randomness.

Copy & paste the lines below to somewhere appropriate in your .vimrc.

" Create the comma-separated list of colorscheme files
let s:colors = substitute(globpath(&runtimepath, 'colors/*.vim'), "\n", ',', 'g')
" Make backward slashes forward if necessary
if (has('dos16') || has('dos32') || has('win16') || has('win32') || has('os2')) && !&shellslash
  let s:colors = substitute(s:colors, '\', '/', 'g')
endif

if strlen(s:colors)
  " If there are two or more colorschemes
  if s:colors =~ ','
    let s:rnd = matchstr(localtime(), '..$') + 0
    let s:loop = 0
    " Rotate the list s:rnd times
    while s:loop < s:rnd
      let s:colors = substitute(s:colors, '^\([^,]\+\),\(.*\)$', '\2,\1', '')
      let s:loop = s:loop + 1
    endwhile
  endif
  " Obtain the filename of the first colorscheme in the list.  e.g.:
  "   c:/home/vimfiles/colors/foo.vim
  " Then, trim unecessary parts to get this:
  "   foo
  let s:color = substitute(matchstr(s:colors, '^[^,]\+'), '^.*/\(.*\)\.vim$', '\1', '')
  execute "colorscheme" s:color
endif
unlet! s:colors s:color s:rnd s:loop

Please be noted that adding this script might slightly slow down the startup
time of vim.  Enjoy!

VimTip 359: Download RedHat RPMS of the latest and greatest version of VIM.
http://vim.sourceforge.net/tip_view.php?tip_id=

You can now download RedHat RPMS of the latest and greatest version of VIM.
Here is the annoucement: http://marc.theaimsgroup.com/?l=vim&m=103629270123503&w=2
Here is the download link: http://nirvani.org/software/vim/

VimTip 360: ':e <dir>' enter files and directories
http://vim.sourceforge.net/tip_view.php?tip_id=

You can directly enter files with ':e filename', but did you know you can 'enter' directories that way ?

e.g. ':e ..' opens a buffer window with the entries of the parent directory.
If you then double click on an entry the directory is opened in the same way (if it's a directory)
or the file is opened for editing (if it's a file).

(Don't ask me, if it's normal vim behaviour or the effect of any script.)

VimTip 361: Use xdvi (or kdvi) in conjunction with gvim (or vim) and converse
http://vim.sourceforge.net/tip_view.php?tip_id=

source: the xdvi man page

For recent xdvi versions (>= 22.38), (or recent Unix/Linux versions), xdvi can
interact with any editor provided with a client-server mode. We explain
here how to use xdvi in conjunction with vim (compiled with the client-server
option) or gvim (mostly compiled with this option). I have tested that
with Linux Mandrake 9.0. On that system, gvim is compiled with the
client-server option and vim is not.

0-Check that your xdvi version provides the "source-special" functions,
by typing 'xdvi -version' or 'man xdvi'

1-Configuration of the source file (file.tex)
Put the following line at the beginning of the latex file:
\usepackage[active]{srcltx}
or the following line at the beginning of the tex file
\include{srctex}

2-Configuration of xdvi
xdvi has to be called with the following options
xdvi -editor 'gvim --remote-wait +%l %f' file.dvi &
(or with 'xterm -e vim --remote-wait +%l %f' if vim has
been compiled with the client-server option).

To make it easier to use you can define an environement
variable XEDITOR to set the value of 'editor' or add
the following line in your .Xdefaults
xdvi.editor: gvim --remote-wait +%l %f
Launch 'xrdb -load ~/.Xdefaults' to make sure that
xdvi.editor is set to the good value.
If you have defined such a variable, xdvi will always be launched
with the -editor option. To avoid this unsafe behavior,
launch 'xdvi -safer'.

3-Conversely, if you call xdvi within gvim with the -sourceposition
option, cursor is placed in the dvi file on the corresponding position.
Syntax is:
xdvi -sourceposition l:cfile.tex file.dvi
l is the line number, c is the column number
(Be carefull: there is no space between "c" (column number) and
file.tex).
To make it easier to use, you can do the following
First create a file named for example "xdvi_source.vim"
with following lines
" This script calls xdvi source and puts cursor in xdvi viewer at
" the position corresponding to the position in the source file
"
:exec "silent !xdvi -sourceposition ".line(".").':'.col(".")."%".' '."%:r.dvi"

Then launch the following command within gvim editing the .tex
source file. Pressing simultaneously <CTRL> and -> will open
the dvi file at the right position:
:noremap <buffer> <C-Right> :so xdvi_source.vim<CR>

VimTip 362: matchit.vim and coldfusion (and perhaps others)
http://vim.sourceforge.net/tip_view.php?tip_id=

Hi VIMmites

I couldn't get any tags to match in Coldfusion files *.cfm either HTML Javascript or ColdFusion tags themselves <cfif ..> ... </cfif>

Much pain was gone thru before I realised that the Syntax File for ColdFusion
 (/syntax/cf.vim) was called cf and not cfm

Therefore in matchit.cfm I need to add CF in following line and NOT CFM

au FileType html,jsp,php,cf if !exists("b:match_words") |

zzapper

VimTip 363: Starting up Vim very fast expecially from a telnet session
http://vim.sourceforge.net/tip_view.php?tip_id=

when you telnet to a remote machine and fire Vim on that machine,
sometimes it takes a lot of time for Vim to start.
instead if you use
vim -X
it will start vim almost instantaneously. This is because "-X" options
tells vim not to connect to the local X server, which can save a lot of startup time.

Also
vim -X --noplugin
will not load any plugins in $VIMRUNTIME/plugin directory, this will again speed up the
starting and is very useful especially when running vim from a Disk mounted over NFS.
Njoy

VimTip 364: Automatic file type detection with fully qualified ClearCase names
http://vim.sourceforge.net/tip_view.php?tip_id=

I am using the great plugin from Douglas Potts (vimscript #15).

When you load a specific ClearCase version of a file, vim cannot find the correct file type in the full name (ex. filename.c@@/main/foo/1). To improve that, you can create an autocommand in the filetype.vim file in your user runtime directory.

augroup filetypedetect
  au BufNewFile,BufRead */*@@*
    \ if expand("<afile>") =~ '@@' |
    \   exe "doau filetypedetect BufRead " . expand("<afile>:s?@@.*$??") |
    \ endif
augroup END

The test in the command is for compatibility with path containing '@@' sequence.

VimTip 365: Vim Book Online
http://vim.sourceforge.net/tip_view.php?tip_id=

New Riders has released Steve Oualline book Vi iMproved (VIM) under their Open Publication License (OPL).  View it at http://www.newriders.com/books/opl/ebooks/0735710015.html

VimTip 366: really basic RCS interaction from within vim
http://vim.sourceforge.net/tip_view.php?tip_id=

  I've looked all around and haven't found RCS functions built into vim (which surprises me, really), so I looked more and found some almost working RCS scripts for text-mode.  Key there is almost.  It's still a kludge, but it works without too much hassle.

   I've chosen F1 and F2, because I never use those keys for what they are intended.  I use :help for command reference, not for a tutorial style thing.  So, use some discretion.  Also, the write command could just as easily have been a :write!, but I decided against that in the case of files that weren't checked out.  You should check them out, first, and they should be writable.

map <F1>                :write %<CR>:!ci -l %<CR>:edit!<CR>
map <F2>                :!co -l %<CR>:edit!<CR>

  New RCS files work just fine with the first mapping.

  There would be some use to creating the RCS directory, if it's not already there, but I don't see an "if exists and is directory" function, right now.

  There's a good menu-driven rcs client for graphical vim, but I hate menus and graphical interfaces.

VimTip 367: What is this $VIMRUNTIME ?
http://vim.sourceforge.net/tip_view.php?tip_id=

$VIMRUNTIME points to a directory where most of the files needed by Vim are kept.
As the name suggests these files are needed during "run-time". Though they are not necessary for
Vim to run, but they help in adding extra functionality to the basic Vim.

Here is a brief overview of files and directories in $VIMRUNTIME.

bugreport.vim :- Use this file if you think you have discovered a bug in VIM. see "help bugreport"
colors :- Contains various clorschemes. see ":help :colorscheme"
compiler :- Contains compilation scripts for various languages. see ":help :compiler"
delmenu.vim :- Deletes all Menu's
doc :- Contains Documentation :-)
evim.vim :- script for easy vim. see :help evim"
filetype.vim :- Detects filetype of files based on their extensions. see "help filetype"
ftoff.vim :- SOurce this to disable ditection of filetypes.
ftplugin :- Contains plugins that are loaded based on the filetype.
ftplugin.vim :- Enables flietype plugins
ftplugof.vim :- Disables filetype plugins
gvimrc_example.vim :- The name says it all, right :-)
indent :- contains indentaion scripts for various languages
indent.vim :- Enables indentation based on filetype.
indoff.vim :- Disables indentation based on filetype.
keymap :-  Contains keymap files for various encodings. see ":help keymap"
lang :- Contains Message files in different language. see ":help language"
macros :- Contains variuos cool stuff. read "macros/README.txt"
menu.vim :- Default Menus
mswin.vim :- sets options for Vim to behave like Windows.
optwin.vim :- commands to create option window.
plugin :- Contains plugins. All .vim files in this directory are automatically sourced.
scripts.vim :- helps detect filetype in Vim scripts.
syntax :- Contains Syntax defination files for various programming languages.see ":help syntax"
tools :- Some useful tools. like blink to blink the cursor in xterm.
tutor :- Contains tutor.vim. see ":help tutor"
vim32x32.xpm :- Vim Logo.
vimrc_example.vim :- again name says it all.
~

VimTip 368: Use gvim in VS.Net
http://vim.sourceforge.net/tip_view.php?tip_id=

This tip presumes you have both VS.Net (Developer Studio.Net) and gvim installed, and know where gvim is located on your system.

- Create a solution in VS.Net, any project type will do.
- In the solution explorer (View->Solution or Ctrl + R) you should see a list of files (click on the "Solution Explorer" tab if you do not see the file list).
- Right click on any of the files and choose "Open With...", this brings up the Open With dialog.
- Click on "Add..." this brings up the Add Program dialog.
- Click on "Browse..." and point the Browse dialog to your gvim location.
- You have now added gvim to the list of editors, you may also select gvim to be the default editor for that file type.

You may need to do this for all file types you wish to edit with gvim. And yes you still have VS.Net open the file in its own editor.
Of course if you want to reverse changes simply remove gvim from the list of editors and why would you want to do that? :)

Enjoy!

VimTip 369: Comment/UnComment visually selected text
http://vim.sourceforge.net/tip_view.php?tip_id=

Comment/UnComment visually selected code
========================================

Visually selected code can be easily Commented out and uncommented by using
the following functions. The functions insert/delete C/C++/Java style
comments. The comment characters can be modified by editing the functions.

Add the following to your .vimrc file. It will add two menu items under
the "Edit" menu in gVim. The function calls can be mapped to keystrokes
if desired.

------------------------------------------------------------------------------
"Menu items for Commenting and Un-Commenting code
amenu 20.435 &Edit.-SEP4-			:
amenu Edit.Comment <ESC>`<:let fl=line(".")<CR>`>:let ll=line(".")<CR>:call Comment(fl, ll)<CR>
amenu Edit.UnComment <ESC>`<:let fl=line(".")<CR>`>:let ll=line(".")<CR>:call UnComment(fl, ll)<CR>

"Function for commenting a block of Visually selected text
function Comment(fl, ll)
    let i=a:fl
	let comment="//"
	while i<=a:ll
	    let cl=getline(i)
		let cl2=comment.cl
		call setline(i, cl2)
		let i=i+1
	endwhile
endfunction

"Function for Un-Commenting a block of Visually selected text
function UnComment(fl, ll)
    let i=a:fl
	let comment="//"
	while i<=a:ll
	    let cl=getline(i)
		let cl2=substitute(cl, "//", "", "")
		call setline(i, cl2)
		let i=i+1
	endwhile
endfunction
------------------------------------------------------------------------------

VimTip 370: always cd to the current file's directory
http://vim.sourceforge.net/tip_view.php?tip_id=

When I have several or more files from various directories opened and am going to open another, I find it counter-intuitive to specify the file path from Vim's current directory.  I think it's more natural to specify it from current file's directory (though this is not the traditional vi way).  If you feel similarly, this simple tip may help you.

My solution is to have Vim always cd to the current file's directory.  Put this in your .vimrc:

function AlwaysCD()
        if bufname("") !~ "^ftp://"
                lcd %:p:h
        endif
endfunction
autocmd BufEnter * call AlwaysCD()

Note that Vim doesn't cd to a remote machine's directory.  If you never open a file through network, just use this instead:

autocmd BufEnter * lcd %:p:h

VimTip 371: Encrypting a file within vim session and not leaving behind traces.
http://vim.sourceforge.net/tip_view.php?tip_id=

I was desperately looking for a simple way to encrypt files.
(I find this very useful. Despite all the user permissions you set, it's easy for someone/admin
to do sudo and read your personal files..Many work environments provide users the permission
to sudo or become super user)

Vim let's you encrypt file within the edit session.

:X

Will prompt for encryption key. Enter the encryption key and REMEMBER to save
it using :w. That will encrypt the file.

Try
:help  :X
for more info.

If you don't want to leave behind traces of your edits:
By default, once you finish your vim session, ~/.viminfo will be written with
the  files you edited (marks), commands you entered and possibly what you wrote
(the registers you copied or pasted...). If you don't want such trace to be left behind,
then place the following file in in your .vimrc

set viminfo='0,\"0,\/0,:0,f0

VimTip 372: Remove unwanted empty or blank lines for english and chinese
http://vim.sourceforge.net/tip_view.php?tip_id=

This tip is inspired by tip #72 which titled 'Remove unwanted empty lines'.
:g/^$/d
==================
Well, if the line contains <Space> and <Tab>
:g/^\s*$/d
==================
If the line contains <Space> and <Tab> and chinese character <Space>, which takes two bytes, and the ASCII is 0xA1 0xA1.

:g/^\(\s\|&#12288;\)*$/d

Herein after the | I paste the `<Space> as a chinese character'.

:g/^[ \t|?]*$/d

Note the `|?' represents a single character which ascii is 0xA1, and inputed by
CTRL-VxA1

VimTip 373: Run find/replace/search on multiple files and subdirectories
http://vim.sourceforge.net/tip_view.php?tip_id=

I wanted to recursively edit all html files in a folder/subfolders and run a search and replace command (substitute) in each one, then save the files when finished.

Vim 6.1.255

This is what my batch (WinXP) file does:
Note, since this is running in a windows batch/command file, I had to
escape the % sign.

First start a new instance of gvim, so it doesn't use one that I am already using.
Give it a specific name so the commands are contained to it.
start gvim --servername BEAD

Using the FOR statement recursively edit all htm files and send them to the gvim session I just started:
FOR /R %%i IN (*.htm) DO gvim --servername BEAD --remote-silent "%%i"

Now, send the bufo command to that server that will run a substitute command.
Note, I had to double up the % signs since I am in a batch/cmd file.
I also used the ge options so that no error was reported if the search string was not found.
gvim --servername BEAD --remote-send "<ESC>:bufdo %%s/Tweety Bird/Road
Runner/ge<CR>"

Now save all files and exit
gvim --servername BEAD --remote-send "<ESC>:xall<CR>"

Complete batch/cmd file (minus the ***'s)
***********************
start gvim --servername BEAD
FOR /R %%i IN (*.htm) DO gvim --servername BEAD --remote-silent "%%i"
gvim --servername BEAD --remote-send "<ESC>:bufdo %%s/Tweety Bird/Road
Runner/ge<CR>"
gvim --servername BEAD --remote-send "<ESC>:bufdo
%%s/\(^File:.*JPG\).*/\1/ge<CR>"
rem Write all files and exit
gvim --servername BEAD --remote-send "<ESC>:xall<CR>"
***********************

VimTip 374: VIM's Filtering Commands Summary
http://vim.sourceforge.net/tip_view.php?tip_id=

Vim's Filtering Commands or how to get text into or out of a file

# Redirection to Paste register * (or any other a-z)
:redir @*                    : start redirect commands to paste buffer
:history
:g/fred/
etc etc
:redir END                   : end redirect

# Redirection to a file
:redir >> out.txt            : redirect to a file
blahblah
:redir END                   : end redirect

# Storing glob results in register a (note must use APPEND)
:g/fred/y A                  : append all lines fred to register a
# to a file (must use >>)
:'a,'b g/^Error/ . w >> errors.txt

# Get output from external commands
:r!ls.exe                    : reads in output of ls
!!date                       : same thing

# Filtering current file using an external command
:%!sort -u                   : use an external program to sort current file
:'a,'b!sort -u               : use an external program to sort current file

These tips are "filtered" from vimtip #353

VimTip 375: autocmd for skeleton html file (BufFileNew)
http://vim.sourceforge.net/tip_view.php?tip_id=

How about starting your new html document with a nice shiny skeleton!

Add this in your autocmd section in your .vimrc file

  " Start with an html skeleton docuement when opening a new *.html file
  au BufNewFile *.html | execute "normal :set ai!\<kEnter>i<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transiti onal//EN\">\<kEnter><html>\<kEnter>  <head>\<kEnter>    <style>\<kEnter>    </style>\<kEnter>    <script>\<kEnte r>    </script>\<kEnter>  </head>\<kEnter>  <body>\<kEnter>  </body>\<kEnter></html>\<ESC>:set ai\<kEnter>gg"

VimTip 376: A totally useless tip...or is it ?
http://vim.sourceforge.net/tip_view.php?tip_id=

Would it not be cool to have your Name listed as part of a Vim command.
Well If you build your VIM from source , you can do that.
CD to the source directory and do
./configure --with-compiledby="<Your Name>" <other-options>

After building and installing Vim,
Whenever you issue
 :version <enter>
 You will see your Name in the "compiled by" line.
NJoy.

VimTip 377: Microsoft Natural Multimedia Keyboard Scancodes
http://vim.sourceforge.net/tip_view.php?tip_id=

I have collected most of the special keys' scancodes on the Microsoft Natural Multimedia Keyboard.  This might be helpful for those of you that do lots of key-bindings.

http://nirvani.org/docs/Microsoft_natural_multimedia_keyboard_scancodes.html

--
Jeremy Brand <jeremy@nirvani.net>
http://nirvani.org/software/vim/

VimTip 378: Auto insert Java class template when editing a new Java file
http://vim.sourceforge.net/tip_view.php?tip_id=

If you are lazy like me, tend to use lengthy and verbose Java class names, then this tip is for you.  When creating a new Java class file, the first thing that I do after creating it is to add the following block of text:

public class ClassName
{
}

Rather than have to type the ClassName twice (once when you first opened the new file, and then again for this block), you can use this autocmd to insert that text for you automatically:

  autocmd BufNewFile *.java
    \ exe "normal Opublic class " .  expand('%:t:r') . "\n{\n}\<Esc>1G"

VimTip 379: 1,$ s/^M//g  gets rid of control-Ms (windows carriage returns)
http://vim.sourceforge.net/tip_view.php?tip_id=

This has got to be in the tips somewhere else, but darned if I could find it.  I had been bothered by the pesky ^M characters that appeared at the end of lines in files that were generated in MS Windows -- particulary appserver log files for me.  My new best friend showed me this regex substitution that gets rid of them:

:1,$ s/^M//g

Note - If I don't have this in the command buffer, I usually wind up copying and pasting the ^M into the regex if I'm in windows, since I'm not sure how to type it from the keyboard (shift 6 followed by capital M doesn't work).  In unix, I can ususally type ctrl-V followed by Enter to get the ^M.

VimTip 380: Using gvim as frontend for dbx
http://vim.sourceforge.net/tip_view.php?tip_id=

There is a easy, fast way to use gvim as somewhat like a frontend for the solaris dbx - debugger. Add the following to your .dbxrc:

alias sc=" gvim --remote +$vlineno $vfile"
when stop { gvim --remote +$vlineno $vfile ;}

Allways the debugger stops it shows you the current positon in the gvim. My gvim does'nt take the focus, I dont know why, but so I just can walk through the code.

The sc alias shows the current position and is helpful after loading the executable to show the start (we have'nt stopped at this point).

Unfortunately it doesn't work at the first stop after attaching to a process.

VimTip 381: Running the win32-version of Vim from cygwin
http://vim.sourceforge.net/tip_view.php?tip_id=

This tip does not only concern Vim, but any native win32 application (NWA) we may want to run from cygwin.

Note: I call a "native win32 application", any program that has not been specifically compiled to run on cygwin.
Typical examples are internet explorer, yap, acrobat reader, ... and of course the win32 version of Vim available on this site or on http://cream.sourceforge.net.

The problem with running NWAs from cygwin comes from the fact that paths in cygwin can be expressed in ways that NWAs can't understand. Indeed from cygwin, we can also:
- express paths as *nix-like paths ; e.g.  /etc/profile
- use paths that, as a matter of fact, are symbolic links.

So, to come around this issue, here is a shell script that can be used to define aliases:
    http://hermitte.free.fr/cygwin/cyg-wrapper.sh
[More help available on: http://hermitte.free.fr/cygwin#Win32]

All you have to do is to drop it into one directory from your $PATH, and define into your .profile something like:
    alias gvim='cyg-wrapper.sh "C:/Progra~1/Edition/vim/vim61/gvim.exe" -c'

Notes:
- under MsWindows 9x, I had to writte the path to gvim.exe in the windows short form
- the '-c' is here to tell cyg-wrapper.sh that: when calling VIM, the parameter following '-c' is not a path.
  This enables to write:
         gvim -c '/^$/' foo.xxx

Regarding the use of *nix-like paths from win32-VIM, check Johannes Zellner's plugin (cygwin.vim) that will convert *nix paths into MsWindows paths on file-opening -- there are different autocommand to add, but it will give you the main idea.
Last point, the win32 version of Vim can not expand paths expressed in the *nix way ;
e.g. ':sp /etc/pr<tab>' won't expand.

VimTip 382: Search and replace in all open buffers
http://vim.sourceforge.net/tip_view.php?tip_id=

Useful for doing simple refactoring i.e. changing a method or variable name. Prompts for a word and then replaces all instances of <cword> in open buffers with the word.

"---------------------------------------------------------------------------
" Search for <cword> and replace with input() in all open buffers
"---------------------------------------------------------------------------

fun! Replace()
    let s:word = input("Replace " . expand('<cword>') . " with:")
    :exe 'bufdo! %s/' . expand('<cword>') . '/' . s:word . '/ge'
    :unlet! s:word
endfun

map \r :call Replace()<CR>

Thanks to Jurgen Kraemer for showing me how to use the :exe command :)

Sean

VimTip 383: a Map to jump to a subroutine/function from where it is called
http://vim.sourceforge.net/tip_view.php?tip_id=

Hi
When writing/debugging code you often want to jump from where a subroutine/function is called to where it actually  is . Hitting the "*" key is frustrating if the sub/func is called many times. The following mapping solves the problem. (Notice how it can be altered for other lanaguages)

nmap gx yiw/^\(sub\<bar>function\)\s\+<C-R>"<CR>

Instructions: place cursor over called function (normal mode) and type gx

How it works:
yiw : Yank inner work to un-named register
/^\(sub\<bar>function\)\s\+  : search for sub or function followed by 1 or more spaces
<C-R>" : Retrieve un-named register
<CR> : Start Search

(also included in vimtip #305 )

VimTip 384: Easily switch between source and header file
http://vim.sourceforge.net/tip_view.php?tip_id=

To switch between header and source files very quickly, all you need to do is add a few key mappings in your filetype plugin files. Let me explain with an example:

Let's say that you're editing C files, so all you would have to do is edit your ftplugin/c_extra.vim file and include

nmap ,s :find %:t:r.c<cr>
nmap ,S :sf %:t:r.c<cr>

to switch to the corresponding source file, and

nmap ,h :find %:t:r.h<cr>
nmap ,H :sf %:t:r.h<cr>

to switch to the corresponding header file.

The built-in 'find' command will search (recursively or not) for the specified file anywhere in your vim 'path' setting. The 'sf' is short for split-find, meaning that if vim finds your file it will open it in a split window. Simply add the 'vert' keyword before 'sf' if you want a vertical split.

See these help pages for a full description of these built-in features:
help expand   # for a description of the %, :t, :r expansion
help find   # for a description of the 'find' and 'sf' features
help ftplugin   # for a description of how filetype plugins work
help path   # for a description of how the path setting works

This method is also highly configurable. All you have to do is change the 'path' setting when switching to different projects, and modify the corresponding filetype plugin to support other languages.

This tip is very similar to vimscript #31 by Mike Sharpe, however this method only takes a few lines, and his script spans several pages!

VimTip 385: some java & vim tips
http://vim.sourceforge.net/tip_view.php?tip_id=

i started to aggregate some java & vim tips (in part because i easily forget stuff).  they're the kind of tips that are a little elusive but deliver a big bang for their effort; like actually getting quickfix to work with java, using ctags with java, etc....

http://www.ophinity.com/papers/jim/index.html

...on that note, i wonder if vim.org should start organizing tips and scripts into areas of interest or perhaps cross-indexing?  some things that come to mind are document generation (tex/ latex), oracle/ db integration, java development, c/ c++ coding, win32 issues, etc...

VimTip 386: Cut/copy and paste using visual selection
http://vim.sourceforge.net/tip_view.php?tip_id=

Visual selection, although common in applications today, is a key feature that differentiates vim from traditional vi.

To cut (or copy) and paste using visual selection:
1. Position the cursor at the beginning of the text you want to cut/copy.
2. Press v to begin character-based visual selection (or upper case V to select whole lines, or Ctrl-V for a vertical block).
3. Move the cursor to the end of the text to be cut/copied. (While selecting text, you can perform searches and other advanced movement, a feature that sets vim apart from most other editors.)
4. Press d (as in "delete") to cut, or y (as in "yank", which I imagine meaning "yank so hard and fast that it leaves a copy behind") to copy.
5. Move the cursor to the desired paste location.
6. Press p to paste after the cursor, or P to paste before.

In gvim, visual marking (steps 1-3) can be replaced by selecting text using a mouse or similar pointing device, although I strongly prefer to navigate using the keyboard.

Bonus tip: To replace the selected text with new text (to be entered by you), press 'c' instead of 'd' or 'p' on step 4.  This deletes the selection and leaves you in insert mode.  Then, instead of (or prior to) steps 5-6, type your replacement text.

VimTip 387: A way to quickly prefix a char(or chars) to a parameter list, via :s
http://vim.sourceforge.net/tip_view.php?tip_id=

This is a way to quickly prefix a char(or chars) to a parameter list, via :s

In the thought that others may like the same preferred style as I, here is an
easy way to prefix each param with an underscore.

The command:
:s/\<\(\I\i*\s\{-}[,)]\)/_\1/g

A sample menu entry:
amenu  Fe&ral's.Prefix\ underscores\ to\ params        <Esc><Esc>:s/\<\(\I\i*\s\{-}[,)]\)/_\1/g <bar> :noh<CR>

An Example:
Before:
BOOL CSomeView::Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID)

After:
BOOL CSomeView::Create(DWORD _dwStyle, const RECT& _rect, CWnd* _pParentWnd, UINT _nID)

Happy VIMing :)

VimTip 388: Insert C++, LaTeX, and other comments easily
http://vim.sourceforge.net/tip_view.php?tip_id=

Visual selection combined with powerful replace (:s) command can be used for fast inserting C++ (//), LaTeX (%), and other comments at the beginning of a block of lines.

If you have, for example, paragraph in a LaTeX file and you want to comment it (so that it does not appear in the output anymore), then you have to insert the percent sign '%' at the beginning of every line. An easy way to do this is to select visually the block of text, press ':' for entering a vim command (which automatically expands to :'<,'>) and to use substitute

s/^/%/

The whole command then looks like

:'<,'>s/^/<your comment here>/

So just press enter and the comment will be inserted at the beginning of all the selected lines.

If you want to delete it later, just use column blocks (Control-V starts blockwise visual selection) to select first column(s) and d to delete them.

VimTip 389: search only in unfold text(intend to work with diff)
http://vim.sourceforge.net/tip_view.php?tip_id=

hi,

sometimes I would like to search/replace the code in the latest version. That is when I show diff between two version of code, I would like to only search the unfold. The following function may do the replace job:

function Foldrepl(spattern, tpattern)
    normal gg            "go to top of the file
    if &diff             "need to change fold option for diff
        exec "set diffopt=context:0"
    endif
    "echo a:spattern
    "echo a:tpattern
    let mycount =0
    while search(a:spattern, "W") > 0  "find the search pattern
       if foldlevel(line(".")) < 1     "not in flod
           exec "s/".a:spattern."/".a:tpattern."/g"
           let mycount = mycount + 1
       endif
    endwhile

    if &diff            "need to restore fold option, mine is 4
        set diffopt=context:4
    endif
    echo mycount ." lines are changed"
endfunction

It can be changed to do the search job or both

Demai

VimTip 390: combining vimdiff with cvs diff
http://vim.sourceforge.net/tip_view.php?tip_id=

i like using vim's diff mode for comparing different revisions of source code files. usually older versions do not live in the directory structure with the current versions, but in a cvs repository. the command below, CVSdiff, can compare the current file to any given revision number in the cvs repository. please note that in case a revision number does not exist, empty files will be displayed, as the below script does not do any error checking (yep, i'm lazy, and this works for me). a vertical split is performed on the current file and its given previous revision.

command -nargs=1 CVSdiff silent call CVSdiff("%", "<args>")
function! CVSdiff(filename, cvsversion)
    " append a:filename to keep extension and therefore highlighting mode
    let patchname = tempname() . a:filename
    let tempname  = tempname() . a:filename
    let newname   = tempname() . a:filename
    execute "!cvs diff -a -r " . a:cvsversion . " " . a:filename . " > " . patch
    execute "!cp " . a:filename . " " . tempname
    execute "!patch -R -o " . newname . " " . tempname . " < " . patchname
    execute "vertical diffsplit " . newname
    call delete(patchname)
    call delete(tempname)
    call delete(newname)
endfunction

VimTip 391: Simple programmers TODO list using grep and quickfix
http://vim.sourceforge.net/tip_view.php?tip_id=

I use this to maintain a TODO list for projects I am working on. All my projects are pretty small scale with each project stored in it's own directory so this tip was writtten with that in mind.  Basically it is two keymappings one which inserts
//TODO_ITEM
leaving Vim in insert mode so you can add a note to help you remember what you wanted to do ;)
The other mapping uses :grep to search for all occurrences of TODO_ITEM in files in the current directory excluding ~ files and then opens the error window displaying the list of TODO_ITEMs.

imap \q <ESC>i//TODO_ITEM<SPACE>
map \q i//TODO_ITEM<SPACE>
imap \w <ESC>:grep --exclude=*~ TODO_ITEM * <CR> :copen <CR>
map \w :grep --exclude=*~ TODO_ITEM * <CR> :copen <CR>

Change the comment style to suit your language and the lame keymappings to something better.

Sean

VimTip 393: PCRE search and replace (Perl Compatible Regular Expressions)
http://vim.sourceforge.net/tip_view.php?tip_id=

1. Verify in :ver that +perl or +perl/dyn is compiled in.
2. Install Perl if necessary. On Windows, ActivePerl is required.
3. Type  :perldo s/searchme/replaceme/g

VimTip 394: pop up menu for checking the meaning of the word from internet
http://vim.sourceforge.net/tip_view.php?tip_id=

 To check the meaning of the word under the cursor, right click
 mouse, and choose Dic. Either IE or mozilla will be opened
 and dictionary service offered by www.m-w.com will be ready.

 Following is the map:

 To open mozilla

 nme <silent> PopUp.&Dic :sil! !start C:/Progra~1/mozilla.org/Mozilla/mozilla -nosplash "http://www.m-w.com/cgi-bin/dictionary?book=Dictionary&va=<cword>"<CR>

 To open internet explorer:

 nme <silent> PopUp.&Dic :sil! !start iexplore -nohome "http://www.m-w.com/cgi-bin/dictionary?book=Dictionary&va=<cword>"<CR>

 This is tested for gvim.exe on windows 2000 professional.



VimTip 395: visual marks
http://vim.sourceforge.net/tip_view.php?tip_id=

Hi,

Setting visual bookmarks in a file / buffer can be done in a simple way by using VIM's 'sign' feature.
This solution just sets the background of the current line to light blue.

Also see ':help sign'.

Add these lines to your gvimrc:

" define a highlight colour group for bookmarks
hi default BookmarkCol ctermfg=blue ctermbg=lightblue cterm=bold guifg=DarkBlue guibg=#d0d0ff gui=bold

" define a bookmark / sign: just highlight the line
sign define MyBookmark linehl=BookmarkCol

" add something to the context menue (right mouse)
amenu 1.200 PopUp.-SEP3-			:
amenu 1.200 PopUp.&mark.set\ bookmark		:exe 'sign place 1000 name=MyBookmark line='.line(".").' buffer='.winbufnr(0)<CR>
amenu 1.200 PopUp.&mark.del\ bookmarks		:sign unplace 1000 <CR>
amenu 1.200 PopUp.&mark.list\ bookmarks		:sign list<CR>

Happy VIMming

Thomas

VimTip 396: Highlighting whitespaces at end of line
http://vim.sourceforge.net/tip_view.php?tip_id=

Whitespace characters (tabs, spaces, etc) at end of line are rarely meant to be there; they are usually there by accident.  If you don't want them, maybe it pays to highlight them with an alarming color.  (After all, GNU Emacs has it (show-trailing-whitespace), so why not in vim :-) )

Put this in your ~/.vimrc to highlight the whitespace characters at end of line:

highlight WhitespaceEOL ctermbg=red guibg=red
match WhitespaceEOL /\s\+$/

VimTip 397: mapping for better browsing of :help docs
http://vim.sourceforge.net/tip_view.php?tip_id=

I personally find it very akward and un-intuitive to browse the documentation
using Ctrl-] for following the link and Ctrl-Shift-t to go back.

I have had an idea to to remap those commands to Enter and Backspace, since
I do not use those keys in help in normal mode.

The command :nnoremap <buffer> can remap the key only in the given buffer
without affecting the other buffers.

just create file
$VIMRUNTIME/ftplugin/help.vim

with following contens
""""""""""""""""""""""""""""""""""""""""""""""""
"""" begining of the file

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

" map ctrl-] to enter in normal mode only for this buffer
nnoremap <buffer><cr> <c-]>

" map ctrl-T to backspace in normal mode only for this buffer
nnoremap <buffer><bs> <c-T>

"""" End of the file
""""""""""""""""""""""""""""""""""""""""""""""""

VimTip 398: Mapping for quicker access to macros
http://vim.sourceforge.net/tip_view.php?tip_id=

:nnoremap <space> @q

Start recording keystrokes by hitting 'qq'.
End recording with 'q'  (<esc> q if you're in insert mode).
Play keystrokes by hitting space.
---
Refs:
    :help register
    :help record






VimTip 399: fold away empty lines
http://vim.sourceforge.net/tip_view.php?tip_id=

You can fold sequences of at least two empty lines (may contain blanks) with these settings:

" fold empty lines with white spaces:
syn match MyEmptyLines "\(^[ ^I]*\n\)\+"  fold

You probably can substitute '[ ^I]' with '\s'.
If you have set 'foldcolumn' to more than 0 you can just open/close these empty lines block
by clicking the '+' or '-' with the mouse in the folder column.

VimTip 400: Fast scroll mappings (incl. insert mode)
http://vim.sourceforge.net/tip_view.php?tip_id=

" allow Alt-[movement keys] to scroll window
if !has("gui_running")
    nmap ^[l <A-l>
    nmap ^[h <A-h>
    nmap ^[k <A-k>
    nmap ^[j <A-j>
    vmap ^[l <A-l>
    vmap ^[h <A-h>
    vmap ^[k <A-k>
    vmap ^[j <A-j>
    imap ^[l <A-l>
    imap ^[h <A-h>
    imap ^[k <A-k>
    imap ^[j <A-j>
endif

" To have <A-h> available for the mappings below, search menu.vim for the
" first instance of &Help and change it to Hel&p so that <Alt-H> isn't used
" for the GUI Help menu
nmap <A-l> 4zl
nmap <A-h> 4zh
nmap <A-k> <C-y>
nmap <A-j> <C-e>
vmap <A-l> 4zl
vmap <A-h> 4zh
vmap <A-k> <C-y>
vmap <A-j> <C-e>
imap <A-l> <C-o>4zl
imap <A-h> <C-o>4zh
imap <A-k> <C-x><C-y>
imap <A-j> <C-x><C-e>

VimTip 401: A mapping for easy switching between buffers
http://vim.sourceforge.net/tip_view.php?tip_id=

Instead of using a buffer-explorer I looked for a simpler method for fast switching between buffers. So on a rainy day I invented a simple mapping:

map  <C-Up> :bn<Return>
map  <C-Down> :bp<Return>

This works very well for an intermediate amount of buffers. Of course you can take other keys (instead of the up and down arrows) for the mapping.

Chris.

VimTip 402: Just using space-bar: jump between splitted windows and open them wide
http://vim.sourceforge.net/tip_view.php?tip_id=

Jump between splitted windows and open them wide.
Use only the space-bar for this.
Press space-bar once and you jump to the next window.
Press it twice and the window opens wide for better reading - this works
for horizontal and vertically open windows.

Put this in your vimrc:

"Jump between windows
map <space> <c-W>w
"Open window wide
map <space><space> :call OpenSplittedWindowWide()<cr>

function OpenSplittedWindowWide()
	normal ^W|
	normal ^W20+
endfunction

Note:
^W must be generated by vim (must be one character).
-------------------------------
The first tip is not new I know it - to jump between windows using the space-bar.
But the combination jumping and opening wide with just using the space-bar this is new.
If not, please apologize, I cannot know all the tips and possibilites published.

VimTip 403: Request for tip - interleaving '.' and '@:'
http://vim.sourceforge.net/tip_view.php?tip_id=

I'm looking for a way to repeat the last command, whether it is an ex command or not. '.' repeats the last non-ex command, while '@:' repeats the last ex command. Can anyone think of a way to interleave the two? It may not seem very useful, but since you can map a keystroke to an ex command (or a sequence of them), isn't it reasonable to expect a uniform way to repeat the last keystroke, without having to remember how it's implemented?

As a random note, it occurs to me that the undo command probably maintains sufficient information to do this - if only we could get at it.

VimTip 404: Tags for Mixed Assembly and C
http://vim.sourceforge.net/tip_view.php?tip_id=

Probably this is a no-brainer, but thought would share it just the same. While accessing C functions/variables from assembly (esp for those DSP/low level guys out there) the usual exhuberant ctags doesn't work.
The solution
a) Make a copy of 'tags' file
b) Search and replace all variables & functions of C files with _variables & _functions in the copy file, say 'Tags'
    (ex in Vim ":g/\.c\>/s/^\(\l.\)/_\1/")
c) In Vim :set tags=tags,Tags
d) Use Ctrl-] to sail through.

Tried to find an elegant (read complicated) solution, but then gave up :). Of course if you need to be doing ctags all the time write a perl scripts or something to do this.

Cheers

VimTip 405: ShowBlockName one-liner equivalent for one coding style
http://vim.sourceforge.net/tip_view.php?tip_id=

I use [[ and its look-alikes a lot for browsing my C++ code.  You can use ShowLine() and the following mapping to obtain something close to ShowBlockName (and it's pretty fast):

map <silent> z[ [[k:call ShowLine()<CR>``

Thanks for your scripts, Gary Holloway.  I look forward to using z[ heavily!

Cheers,

William

VimTip 406: Alternate delimiters for the replace command
http://vim.sourceforge.net/tip_view.php?tip_id=

This text is from http://www.troubleshooters.com/lpm/200212/200212.htm

-- pasted text --

In many VI implementations you don't need to use the slash character as the expression delimiter. You can use most non-alphanumeric characters (but not \, " or |). This is very handy when working with UNIX filenames, as in the following example:

:s+/usr/local/+/opt/+Whatever character follows the :s is defined to be the delimiter character. If your implementation doesn't support this, you can represent slashes in search and replace expressions by escaping them with backslashes, as follows:

:s/\/usr\/local\//\/opt\//As you can see, the escaping method is much less readable, so if you can use alternative delimiter characters, it's a good idea.

VimTip 407: PHPdoc: Use JCommenter.vim for php-scripts
http://vim.sourceforge.net/tip_view.php?tip_id=

Use JCommenter.vim for php-scripts:

jcommenter.vim : A script for automatically generating JavaDoc comments
http://vim.sourceforge.net/script.php?script_id=20

PHPdoc is an imitation of JAVAdoc.
The syntax between the two languages is very close,
see the examples below:

Example 1:
You have the PHP-function:
function serialize_it($something) {
  $person = serialize($something);
  return $person;
}

Put the cursor on the first line and call :call JCommentWriter()<CR>

You get
/**
 *
 *
 * @param $something
 * @return
 */
function serialize_it($something) {
  $personen = serialize($something);
  return $personen;
}

Example 2:
You have the PHP-class:
class submenu {
	...
}

Put the cursor on the first line and call :call JCommentWriter()<CR>

You get
/**
 *
 *
 * @author
 * @version
 */
class submenu {
	...
}

Example 3:
For a class-variable you get:
/**
*
*/
var $urls;

Note:
It does not work if you have = '' like in
function serialize_it($something = '') {}

But I think jscript.vim can be adapted for the use with PHP.

Klaus

VimTip 408: Enhance Calendar (script 52) with special dates
http://vim.sourceforge.net/tip_view.php?tip_id=



To enhance Calendar (vimscript #52) with display of special dates:

Step 1) Create a file called "holidays" in the directory assigned to g:calendar_diary
            (Default value for g:calendar_diary is ~/diary).
            This file will contain the special dates.  Essence of contents of the
             holidays file is the special dates encoded as (10000+(month*100)+day).

____example_contents_of_file_g:calendar_diary/holidays_________
List of holidays:  ^(10000 + ((month * 100)+day))

Encoded   Sign   Color   Description
 Date

10101     n      blue    Jan 01   (Wed)      - New Year's Day
10217     p      blue    Feb 17   (Mon)      - President's Day
10214     v      red     Feb 14   (Fri)      - Valentine's Day
10414     s      green   Apr 14   (Mon)      - Spring Break
10526     m      blue    May 26   (Mon)      - Memorial Day
10703     i      gold
10704     i      gold    Jul 3&4  (Thu & Fri)- Independence Day + 1 day
10901     l      blue    Sep 01   (Mon)      - Labor Day
11127     t      blue    Nov 27&28(Thu & Fri)- Thanksgiving Day + 1 day
11128     t      blue
11225     c      silver  Dec 25&26(Thu & Fri)- Christmas Day + 1 day
11226     c      silver  Dec 25&26(Thu & Fri)- Christmas Day + 1 day

Step 2)  Add the following to your vimrc file:

let calendar_sign = 'MyGetSpecialDay'
function! MyGetSpecialDay(day, month, year)
  let l:m100d = 10000 + (a:month * 100 ) + a:day
  let l:holidays = expand(g:calendar_diary) . "/holidays"
  exe "split " . l:holidays
  let l:found = search(l:m100d)
  if l:found
    let l:found = 'h'
  endif
  quit
  return l:found
endfunction

That's all.

Note:  The preceding constitutes basic support for display of special dates.
          With this basic support, all special dates are shown with the same
          sign (viz. +) and the same highlight color.  An enhancement would
          be to pick up the sign and the highlight color from the holidays file.
          (Also, I suspect management of buffer for the holidays file can be
           speeded up, perhaps by opening it only once, keeping it in the
           background and searching with warp-around flag ('w').)





VimTip 409: Using selected text as part of a command?
http://vim.sourceforge.net/tip_view.php?tip_id=

I wish to use selected text as part of a command  - say, to substitute instances of a very long variable with a shorter name:

:%s/<selected text>/ShorterName/g

How would I do this? (Hope its OK to ask a question, as opposed to presenting an answer).

VimTip 410: Allow Inform header files to be distinguished from C headers
http://vim.sourceforge.net/tip_view.php?tip_id=

Inform is an Interactive Fiction authoring language.  It's header files often use a '.h' extension, which causes VIM to think they are
C files, or do not have any extension at all, leaving VIM unable to determine what kind of file they are.  This is irritating to Inform
developers using VIM with syntax highlighting.

The solution is to use a custom 'filetype.vim' and 'scripts.vim'.  Create a '$HOME/.vim/filetype.vim':

    if exists("did_load_filetypes")
      finish
    endif
    augroup filetypedetect
      au BufNewFile,BufRead *.h             call FTCheck_inform()
    augroup END

    " function to detect inform code (any extension)
    fun! FTCheck_inform()
        if getline(1) =~ "^!"
           setfiletype inform
        elseif getline(2) =~ "^!"
           setfiletype inform
        else
            let s:colnum = col('.')
            let s:linenum = line('.')
            call cursor(500, 1)
            if search('\[\(\s*\I\i*\)*\s*;', 'bW') > 0
                setfiletype inform
            endif
            call cursor(s:linenum, s:colnum)
        endif
    endfun

On loading a file with a '.h' extension, a function is called to examine the file for certain Inform-specific constructs.  If it finds any, it sets the filetype as inform, otherwise it leaves the filetype unset, allowing the global 'filetype.vim' to determine the filetype.

For files with no extension, create a '$HOME/.vim/scripts.vim':

   " local scripts.vim gets called when
   " all autocommands have failed to identify file type,
   " but before global scripts.vim
   "
   call FTCheck_inform()

See also the site http://www.stephenthomas.uklinux.net/informvim

VimTip 411: How to initialize plugins
http://vim.sourceforge.net/tip_view.php?tip_id=

Plugins have two basic ways of being initialized:

    a) via some variable that the plugin script uses;
       the initialization here is obvious -- set the
       desired variables in your <.vimrc> (or use
       an appropriate autocmd to do so).

    b) via a map or function call.  The problem here
       is that <.vimrc> is sourced prior to plugin
       sourcing, so the map or function call isn't
       available yet.

       Solution: put in .vim/after/plugin a file
       of the same name as the plugin you're initializing.
       In that file put

            call TheInitializationFunction()

            -or-

            norm TheInitializationMap

For example, the <HiMtchBrkt.vim> script which supports the
highlighting of matching brackets as you move onto a
bracket is not on by default.  Normally it requires one to
type "\[i" to start it.  However, if you'd like to have the
script to start enabled, then put

            norm \[i

into the file <.vim/after/plugin/HiMtchBrkt.vim> (see tip
vimtip#177).

(Windows users: mentally change .vim to _vimfiles and / to \
in the tip above)

VimTip 412: Easy menu-style switch between files with a simple map
http://vim.sourceforge.net/tip_view.php?tip_id=

When there are several files opened in a vim session, it becomes difficult to keep track of the files and their respective buffer numbers.

Switching to a different file is made easier using a simple map:

:map <F5> :buffers<CR>:e #

When F5 is pressed, a numbered list of file names is printed, and the user needs to type a single number based on the "menu".
Another good thing is that the "menu" disappears after choosing the number and hitting enter. So it appears only when you need it.

VimTip 413: Drag and Drop file names into VIM's command line
http://vim.sourceforge.net/tip_view.php?tip_id=

You can open files in VIM by Drag&Drop of selected file names from Windows Explorer. (not very surprising).
This also works by dropping into the VIM command line, so you can e.g. type
 ':split '
 then drag&drop a selected file to VIM window
 and hit <CR>

The complete path and filename is transferred to commandline and the file is opened in a new VIM buffer/window.

VimTip 414: Change guifont to see more of your file.
http://vim.sourceforge.net/tip_view.php?tip_id=

Sometimes, its nice to be able to quickly jump to a smaller font to
see more of the file you're editing at once, and jump back again to
make the text more readable. I use these mapping:

:map <f9> :set guifont=Lucida_Console:h9:cANSI<Cr>
:map <f11> :set guifont=Lucida_Console:h11:cANSI<Cr>
:map <S-f9> :set guifont=Courier_New:h9:cANSI<Cr>
:map <S-f11> :set guifont=Courier_New:h11:cANSI<Cr>

9 and 11 are my mnemonics for the font size. <f10> wouldn't work for me
because it activates the menu. Of course, this only works in gvim.

Ben

VimTip 415: easy way to edit two files using split window
http://vim.sourceforge.net/tip_view.php?tip_id=

In my rc ($HOME/.exrc) file, I have the following lines:

map K ESC:split
map k ^K ^W^W

where the 'ESC', '^K', and '^W^W' are escape sequences.

This allows the user to split the screen using 'K', then switch between the two screens using 'k'.  This in conjuction with the :e to edit a different file can be powerful.  Useful for pulling lines (or blocks) from one file into another without having to cut/paste or use the :r command.  Personally I use this alot so I find it useful.  I got the syntax from the O'Reilly book 'Learning the vi editor' in the section about 'ex commands'.

VimTip 416: Fix error "E97: Cannot create diffs" on VIM for Windows
http://vim.sourceforge.net/tip_view.php?tip_id=

I read a couple postings of people having this issue, even if they have a diff program in their path when running on Windows platforms.
Check out your _vimrc file, function "MyDiff". If the path to the diff file contains ANY spaces, enclose the path in double quotes. Alternatively you can remove the path and just leave the diff file and check.

This is the line that if fixed in my _vimrc:

Changed

  silent execute '!C:\Program Files\Vim\vim61\diff -a ' . opt . v:fname_in . ' ' . v:fname_new . ' > ' . v:fname_out

To be:

  silent execute '!"C:\Program Files\Vim\vim61\diff" -a ' . opt . v:fname_in . ' ' . v:fname_new . ' > ' . v:fname_out

I am running the diff program that comes with CygWin and it works just fine.

VimTip 417: combining move and scroll [IMPROVED]
http://vim.sourceforge.net/tip_view.php?tip_id=

A long time ago, I entered vimtip #105.  I used that mapping for a long time, but it always had a couple problems.  One, it reset the scroll parameter.  Two, it didn't work in visual mode, because :set scroll exits visual mode.  I was reviewing my vim configuration and learning some new tricks, and in the process I improved this mapping.

Now, Ctrl-J and Ctrl-K will move the cursor one line down or up, and scroll one line down or up--so the cursor remains on the same screen line (except near the beginning and end of the file)--in both normal and visual modes.  And the scroll parameter is unaffected.

    " N<C-D> and N<C-U> idiotically change the scroll setting
    function! s:Saving_scroll(cmd)
        let save_scroll = &scroll
        execute "normal" a:cmd
        let &scroll = save_scroll
    endfunction

    " move and scroll
    nmap <C-J>      :call <SID>Saving_scroll("1<C-V><C-D>")<CR>
    vmap <C-J> <Esc>:call <SID>Saving_scroll("gv1<C-V><C-D>")<CR>
    nmap <C-K>      :call <SID>Saving_scroll("1<C-V><C-U>")<CR>
    vmap <C-K> <Esc>:call <SID>Saving_scroll("gv1<C-V><C-U>")<CR>

This is an example of several terrible vim hacks, to boot.

VimTip 418: Stop the beeping in gvim.
http://vim.sourceforge.net/tip_view.php?tip_id=

How do you stop gvim from beeping on error?

VimTip 419: Auto-fold perl subs (and possibly other languages)
http://vim.sourceforge.net/tip_view.php?tip_id=

Add this to your .vimrc file and it'll automatically fold perl functions (and possibly other languages that define a subroutine with "sub ...")
Once you open a perl file, you'll see all functions are folded. You can then move to a function and (space) or "zo" to open it, "zc" to close it, "zR" to open all folds (normal file) and "zM" to re-fold all folds.  It makes skimming over a file a breeze. See ":help folding" for more info on folding in general.

function GetPerlFold()
   if getline(v:lnum) =~ '^\s*sub'
      return ">1"
   elseif getline(v:lnum + 2) =~ '^\s*sub' && getline(v:lnum + 1) =~ '^\s*$'
      return "<1"
   else
      return "="
   endif
endfunction
setlocal foldexpr=GetPerlFold()
setlocal foldmethod=expr

VimTip 420: get rid of annoying menu/tool bar
http://vim.sourceforge.net/tip_view.php?tip_id=

if you also get annoyed by the menu bar and/or tool bar in the gui version of vim, you can get rid
of them with the following:

set guioptions-=m            " to get rid of the menu bar
set go-=T                       " to get rid of the tool bar

and then you're back to the look and feel of how vim should always be =]

-your friendly neighbourhood garbage man.

VimTip 421: the simplest map to highlight the current line
http://vim.sourceforge.net/tip_view.php?tip_id=

This is the simplest map to highlight the current line

nn <silent> K mk:exe 'match Search /\\%'.line(".").'l/'<CR>

Note: abstract from
http://vim.sourceforge.net/tips/tip.php?tip_id=411
http://vim.sourceforge.net/tips/tip.php?tip_id=177

To turn off highlight, type :match<CR>

VimTip 422: A Quick Reference
http://vim.sourceforge.net/tip_view.php?tip_id=

After using vi and similar for a few years, I have accumulated a list of commands I use most often, and pass it on to people starting with vi.  The available quick reference tends to be verbose, but is useful for people with more vi experience (type ":help quickref" or go to  http://vim.sourceforge.net/htmldoc/quickref.html).  For beginners, here is my file:

VI is a text editor.  Its idea is that you manipulate text (as opposed to enter it all the time).  Almost all commands can be "repeated" a number of times, which you specify before typing the command itself (to delete a line, type dd; to repeat the deletion of a line 55 times, type 55dd).

At almost any time, "u" means "undo", and "Esc" stops all command or text entering.  For help, type :help<enter>.  There is a difference between what I call direct and indirect commands: "u" is a direct command, ":h" is an indirect one (it uses an underlying program).

:q to quit, :q! to quit without saving

Entering and manipulating text:

  Command           Interpretation

  .                 repeat the last command
  i<text>Esc        enter <text> on current line, at current position
  I<text>Esc        enter <text> on current line, at beginning of line
  a<text>Esc        enter <text> on current line, at next character position
  A<text>Esc        enter <text> on current line, at the end of the line
  o<text>Esc        enter <text> on a new line below
  O<text>Esc        enter <text> on a new line above
  r<character>      replace  characters by <character> repeated  times,
                    starting from cursor towards end of line
  s<text>Esc        substitute characters by <text>, starting from cursor
                    towards end of line
  R<text>Esc        substitute characters by <text>, starting from cursor
                    towards end of line
  ~                 change the case
  d                 delete (combine with a movement: dl deletes to the
                    right, d0 deletes to beginning of line, 5dw deletes 5
                    words forward)
  dd                delete line
  D                 delete to the end of the line (like d$)
  c                 change (same combinations as with d)
  cc                change line
  C                 change to the end of the line (like c$)
  S                 change line, like cc
  x                 delete the character at the current position
  X                 delete the character at the left (backspace)
  J                 join the next line to the current line
  y                 yank (copy, same combinations as with d)
  p, ]p             paste the result of the last deletion or yanking command
                    after the cursor
  P, [p             paste the result of the last deletion or yanking command
                    before the cursor
  /, ?              find forward, backward (then, n means next in the same
                    direction, N means next in the opposite direction)
  Ctrl-a, Ctrl-x    increase, decrease by 1 the number under the cursor (5Ctrl-a
                    increases by 5)
  :<number1>,<number2>g/<pattern>/<command>
                    on all lines within <number1>,<number2> range and matching
                    <pattern>, execute <command>.
                    :3,$g/^  table/d
                        deletes all lines from 3 to end of buffer that start
                        with "  table"
                    :%g/[a-z0-9]$/s/boo/table/
                        on all lines in buffer that end with a lowercase letter
                        or a digit, replace "boo" with "table"
                    :%g/[^RT]umble.*cran[0-6]/m'a
                        move all lines in buffer of the kind "Aumble...cran4"
                        or "Gumble...cran6" (NOT Tumble or Rumble) underneath
                        line marked as a.
  :<number1>,<number2>v/<pattern>/<command>
                    on all lines within <number1>,<number2> range and not
                    matching <pattern>, execute <command>.
  :<number1>,<number2>!<command>
                    execute shell <command> on lines <number1> to <number2>

Moving around:

  Command           Interpretation

  0, $              jump to the beginning, end of the line
  h, j, k, l        left, down, up, right (you can also use the arrow keys)
  H, M, L           jump to the highest, middle, lowest line on screen
  {, }              move up, down to the next empty line
  %                 jump to the corresponding parenthesis, square bracket or
                    curly brace
  [[, ]]            jump to the beginning, end of the file
  :1, :$            jump to the beginning, end of the file
  <number>G         jump to line <number> (without the number, jumps to the
                    end of the file)
  Ctrl-f, Ctrl-b    next page down, up
  Ctrl-d, Ctrl-u    next half-page down, up
  Ctrl-e, Ctrl-y    shift all the text by one line down, up
  w, b              go forward, backward to the next word
  e, ge             go to the end of the word, backwared to the end of the previous word
  f<char>           goes to the next <char> in the current line
  t<char>           goes to the character just before the next <char>
  m<character>, '<character>
                    set mark <character>, go to mark <character>
  ''                go to the line that was last modified

Manipulating files:

  Command           Interpretation

  :r <file>         read file in
  :w <file>         write current buffer to <file> (default: write current
                    buffer to current file, if defined)
  :w! <file>        same as write file, overriding permissions
  :wq, ZZ           write to file and quit
  :wq!              write to file and quit, no matter what
  :sp <file>        split window and edit file
  :e <file>         edit <file>
  :n                edit next file in list
  :ls               list buffers
  :buf <number>     edit buffer number <number>

Executing a command easily several times:

  Mapped keys:

    To map a key to a command to execute, type:

      :map <key> <command>

    Then, type <key> to execute <command>.

  Macros:

    To enter a macro, type:

      q<character><commands>q

    To execute the macro <number> (default: 1) times, type:

      <number>@<character>

    Important note: macros can contain calls to mapped keys.

  Registers:

    To use a register named <character>, type "<character> before your command.

      Example: copying the word under the cursor and saving into register z:

        "zyw

      Example: pasting the result of register c before this word or line:

        "cP

    Important note 1: register characters are independent of marks ('a is not affected by "a)
    Important note 2: a macro named <character> is actually stored in the register of same name.  To edit the macro f, just create a new line (o<Esc>), paste the contents of register f ("fp), edit the commands (...), go to the beginning of the line and delete/store the line into register f (0"fD), and remove the temporary line (dd).

Additions to this file are welcome, but make sure it's concise...

William

VimTip 423: Finding more available keys to map
http://vim.sourceforge.net/tip_view.php?tip_id=

One of my ongoing problem with VIM is finding more keys on my keyboard onto which I can map functions without losing some other functionality.  I finally went on a search of terminal emulations that maximize the programability of the keyboard when accessing Linux servers from a Windows 2000 client.

 I am in no way associated with the author or the company, but I wanted to give other VIM users a pointer to check out the ZOC terminal emulator from Emtec at http://www.emtec.com/zoc.  Not only does this support full use of the Alt key, but it also supports compete remapping based on the NumLock and ScrollLock keys.  Keys can be mapped to send any string including binary codings.  ZOC also supports a Linux console terminal mode.

Again I'm not advertising for a particular product; I'm just passing on my solution to a particularly onerous problem when attempting to use the full potential of VIM.

VimTip 424: Copy, cut, and paste macros that also work in old vi
http://vim.sourceforge.net/tip_view.php?tip_id=

The following three mappings implement a useful, quick line-oriented copy, cut, and paste scheme that not only works in VIM but also standard old vi.  These macros use yank or delete commands to either copy or delete lines to named register m where those lines are defined by the motion command to mark m.  The put command is then used to insert the contents of register m at the desired location.

There's nothing special about mark m or register m, thery're just somewhere in the middle.  Meta-g is mnemonic for "get".  Meta-v looks like an insertion mark.  Meta-q looks like Meta-g but with a twist. Of course any other keys, registers, or marks could be used.

map <M-g> mn"my'm`n
map <M-q> "md'm
map <M-v> "mp

To copy some lines ( only in command mode ):
1. Put the cursor on the first or last line and press "mm"
2. Move to the other end of the line range, last or first, and press meta-g
3. Move to the line above where you wish to insert the lines and press meta-v

To cut some lines and move them to a new location use the same procedure but replace meta-g in step 2 with meta-q.

I find that in programming I constantly use these simple functions to position code in the proper place.  I started using this scheme years ago and find it useful now because not all systems have vim, and because it is so quick and easy that it has become part of my finger habits.  Some day I will have to learn the visual mode of VIM better.

VimTip 425: Forcing Syntax Coloring for files with odd extensions
http://vim.sourceforge.net/tip_view.php?tip_id=

If you are editting a file containing PHP script (for example) but the file doesn't have the extension .php

you can force the desired syntax coloring with

:set syntax=php

similarly
:set syntax=perl
:set syntax=html

Alternatively if the extension causes an undesired coloring, switch off coloring with
:set syntax=off

look in the directory *vim/vim61/colors/ for supported languages

VimTip 426: Protecting a file you're referencing
http://vim.sourceforge.net/tip_view.php?tip_id=

A common programmimg situation, you are comparing two versions of the same file.

One is the "reference file" which you DONT WANT to update.

However they look so similar that you can get confused.

Solution:
:set ro   (readonly) in the master file
additionally change it's color scheme (peachpuff is quite a benign one!)

:colorscheme peachpuff

look in vim/vim61/colors for available colorschemes

VimTip 427: Fast window resizing with +/- keys
http://vim.sourceforge.net/tip_view.php?tip_id=

Depending on your willingness to occasionally consume the + and - keys, here's a fast way to resize the active window if you have more than one window open:

if bufwinnr(1)
  map + <C-W>+
  map - <C-W>-
endif

I normally use the scrollpad + and - keys.

The map eliminates the need for time-consuming chording and if you liked chording, you'd be using Emacs instead of Vim anyway...

VimTip 428: Wordwise Ctrl-Y in insert mode
http://vim.sourceforge.net/tip_view.php?tip_id=

Ctrl-Y in insert mode is one of Vim's handy extensions that inserts character which is above cursor (see :help i_CTRL-Y).  However, sometimes this is not very useful when a user wants to insert many characters.  In this case it's better to get a *word* above cursor.

Put this in ~/.vimrc:

" Wordwise Ctrl-Y in insert mode
noremap! <C-Y> <Esc>klyWjpa

You might want to substitute 'W' with 'w', 'E', or 'e'.  Try them and choose one that works best for you.

Unfortunately, this simple map doesn't work at the beginning or end of line.  Improvements are welcome.

VimTip 429: Using '< and '> marks
http://vim.sourceforge.net/tip_view.php?tip_id=

Today I discovered that '< and '> persists even after the selection is gone.
Thus, to repeat an Ex command over a previously selected (via V command) block
just use : history -- no need to reselect block again.

VimTip 430: Fast switching between buffers
http://vim.sourceforge.net/tip_view.php?tip_id=

This is one for Tab key fans. I use these mapping to quickly cycle between buffers using Tab and
Shift-Tab. I use them in normal more as I use tab for word completion when in editing more. Put these in your
.vimrc or gvimrc. The buffer will be written before switching to the next one. The test makes sure that the file can be written to and is modified.

nmap <tab> :if &modifiable && !&readonly && &modified <cr> :w<cr> :endif<cr> :bn<cr>
nmap <s-tab> :if &modifiable && !&readonly && &modified <cr> :w<cr> :endif<cr> :bp<cr>

VimTip 431:
map to toggle between backslash and forwardslash
http://vim.sourceforge.net/tip_view.php?tip_id=

Microsoft is backward, ie, using C:\Progra~1\Outloo~1\
To get it back forward, we can do
:s#\\#/#g<CR>
Now, life turns back to normal: C:/Progra~1/Outloo~1/
However, to copy and paste this normal path to Windows' applications,
we have to substitute slash to backslash:
:s#/#\\#g<CR>

Here came a small map to toggle between "/" and "\" within one line.

Usage:

Put the cursor on "/", and type v\, all "/" becomes "\".
Put the cursor on "\", and type v\, all "\" becomes "/".

Map:

vn <silent><Bslash> y:let c=getline(line("."))[col(".")-1]
   \<CR>:if(c=='/')<Bar>s#/#\\<CR><Bar>elseif(c=='\\')
   \<Bar>s#\\\\#/<CR><Bar>endif<CR>`<

VimTip 432: Putting the current file on the Windows clipboard
http://vim.sourceforge.net/tip_view.php?tip_id=

Sometimes I want to use the file I'm editing in Vim (on Windows) in another application; I created the following command:

com! Copyfile let @*=substitute(expand("%:p"), '/', '\\', 'g')

This simply copies the entire path and filename of the current file -- substituting backslashes for slashes (in case there are any) -- onto the Windows clipboard.  I can then just go and paste the value wherever I want (such as a File -> Open dialog).

For example, for my _vimrc file, I get c:\vim\_vimrc in the clipboard.

VimTip 433: a rough mapping to spellcheck the buffer
http://vim.sourceforge.net/tip_view.php?tip_id=

well, certainly

well, certainly there are plugins to do this much better, but, if you
like to have most of the stuff placed on your vimrc file, the
following must help:


 map ,SS :exec system("ispell -l -t -d br < ".expand("%")." \| sort -u \| sed 's/\\(.*\\)/syntax match Underlined \"\\\\<\\1\\\\>\" contains=TOP /'")


basically, i use 'ispell' to collect all misspelled words, and assign
each one to the 'Underlined' syntax group (seems better than 'Error')
=]

improvements aren't so hard to do; actually, I use another mappings
for another 'spell' functions, but the essential can fit in just one
line;

leorosa

VimTip 434: Autogroup commands for C/C++ editing - inserting skeletons etc (long post!)
http://vim.sourceforge.net/tip_view.php?tip_id=

Hi all,

When you start editing a *.h file, you'd need some format like this:
CODE STARTS:
/*****************************************************************
* Filename: abc.h
* Description:
* Created: Mar 5 03 09:00:00
* Last modified: Mar 6 03 09:00:00
* <some more stuff like author, copyright, blah-blah>
*
* Revision History
*   Date                  Author            Remarks
*   Mar 5 2003         KG                 File Created
*******************************************************************/
#ifndef _ABC_H_
#define _ABC_H_

#endif
// vim:ts=3:sw=3:ft=c
CODE ENDS
I wanted my gvim to do the following things at various stages of editing a abc.h file:
1. Upon opening a new file, insert the skeleton like the one above, and leave me in insert mode after "Description"
2. When writing a file, update the "Last Modified" timestamp
3. On opening a existing file, modify the "Revision History" to add a new line, and leave me in insert mode below "Remarks"

The following autogroup (:help au) commands let you do these (put these in your .vimrc):
CODE STARTS:
if !exists("autocommands_loaded")
  let autocommands_loaded = 1
  au BufNewFile *.h call InsertCHHeader()
  au BufWrite *.h call ModifyTime()
  " You might want to comment-out the line below - see note 6 at the end of the post.
  au BufReadPost *.h call ModifyHeader()
endif

function! InsertCHHeader()
   call InsertSkeleton("skeleton.h")  " CHANGE this!
   call InsertFname()
   1
   " Search for Description
   call search("Description:")
   normal $
   startinsert
endfunction

function! InsertSkeleton(fname)
   let path_to_skeletons = $HOME . "/etc/skeletons/"  " CHANGE this!
   " Save cpoptions
   let cpoptions = &cpoptions
   " Remove the 'a' option - prevents the name of the
   " alternate file being overwritten with a :read command
   exe "set cpoptions=" . substitute(cpoptions, "a", "", "g")
   exe "read " . path_to_skeletons . a:fname
   " Restore cpoptions
   exe "set cpoptions=" . cpoptions
   " Delete the first line into the black-hole register
   1, 1 delete _
   " Search for Filename:
   call search("Filename:")
   exe "normal A " . expand("%:t")
   " Search for Created:
   let current_time = strftime("%b %d %Y %T") "CHANGE this!
   call search("Created:")
   exe "normal A " . current_time
   " Search for Last modified:
   call search("Last modified:")
   exe "normal A " . current_time

   " Search for Date
   let date_line_no = search("Date")
   let rev_history = getline(line("."))
   let rev_history = substitute(rev_history, "Date       ", strftime("%b %d %Y"), "")  " CHANGE this!
   let rev_history = substitute(rev_history, "Author", "KG    ", "")  "CHANGE this!
   let rev_history = substitute(rev_history, "Remarks", "File created.", "")
   call append(date_line_no, rev_history)
endfunction

function! InsertFname()
   " Convert newname.h to _NEWNAME_H_
   let fname = expand("%:t")
   let fname = toupper(fname)
   let fname = substitute(fname, "\\.", "_", "g")
   " Search for #ifndef
   call search("#ifndef")
   exe "normal A " . "_" . fname . "_"
   " Search for #define
   call search("#define")
   exe "normal A " . "_" . fname . "_"
endfunction

function! ModifyHeader()
   " Modify header only if we have write permissions
   if &readonly == 0
      " Search for Date
      let date_line_no = search("Date")
      if date_line_no != 0
         let rev_history = getline(line("."))
         " Substitute Date, and Author fields
         let rev_history = substitute(rev_history, "Date       ", strftime("%b %d %Y"), "")  " CHANGE this!
         let rev_history = substitute(rev_history, "Author", "KG    ", "")  " CHANGE this!
         let rev_history = substitute(rev_history, "Remarks", "", "")
         " echo "Modified = " . rev_history
         call append(date_line_no, rev_history)
         normal j$
         startinsert
      endif
   endif
endfunction

function! ModifyTime()
   " Do the updation only if the current buffer is modified
   if &modified == 1
      let current_time = strftime("%b %d %Y %X")  " CHANGE this!
      " Save current position at mark i
      normal mi
      " Search for Last modified:
      let modified_line_no = search("Last modified:")
      if modified_line_no != 0 && modified_line_no < 10
         " There is a match in first 10 lines
         " Go to the : in modified:
         exe "normal f:2l" . strlen(current_time) . "s" . current_time
         echo "Modified date stamp to " . current_time
         sleep 500m
         " Restore position
         normal `i
      endif
   endif
endfunction
CODE ENDS

Notes:
1. The strftime( ) function is not-portable. You might need to change the format specifier for your system
2. The autogroup commands assumes that there is a file called skeleton.h at the location ~/etc/skeletons.
    You might have to modify the path and file name. In my case, the skeleton.h file looks like:
   /******************************************************************************
    *  Filename:
    *  Description:
    *
    *  Version: 1.0
    *  Created:
    *  Last modified:
    *  Revision: None
    *
    *  Author:    Karthick Gururaj
    *  Company: [Removed]
    *  e-mail: [Removed]
    *
    *  Revision history
    *  Date           Author       Remarks
    *
    ******************************************************************************/
   #ifndef
   #define


   #endif
   // vim:sw=3:ts=3
Search the script for the pattern "CHANGE" to see where you might have to make changes..
3. I have not tried to make the script super-portable (that looks obvious eh?). The reasoning is, any changes are a one time effort.
4. The scripts don't modify search history or register values. I have used one letter for marking thou'
5. If you open a new header file, and quit it without writing, no file is created.
6. I found having an autogroup command for modifing the revision history everytime the file is opened to be irritating. So I have disabled this in my system. Note on note: I also had some problems when trying to open the file thro' the quickfix window.
7. You can define more such skeletons for other extentions.
8. Feedback is welcome!

Cheers!

VimTip 435: remarks to script c.vim : statement oriented editing of  C / C++ programs
http://vim.sourceforge.net/tip_view.php?tip_id=

Seems to be a nice, powerful addition for C-programmers.

The screenshots show a really dangerous C++ trap:
     NEVER add C++ comments after a '#define' statement !
The Preprocessor will substitute the defined text literally,
so all of your code behind the defined text will be commented out.

I used abbreviations for C-constructs like 'cfor' for empty for loops, 'cif' for if then elses, etc.,
so typing in insert mode has not to be interupted. The cursor will be positioned for entering the following code.

Another thing is standard C-comments for file/function headers. I used a command line tool (perl script)
to get a personalized version from a standard template and read in the output with ':r !<mytool> <options>'.
This is a solution for workgroups where no one HAS to use VIM.
I had autocommands for automatically read in the comment headers when opening new header or source files.

Thomas

VimTip 436: Accidently typed control-u and lost your input?
http://vim.sourceforge.net/tip_view.php?tip_id=

If you've accidently typed control-U to delete a line then accidently typed ESC straight after that because you've been using web forms and ESC in IE forms is like undo and basically you really didn't want to do that then you should do this:

:let @a = @.
"aP

The . register is basically everything you've just typed in input mode including the control-U.  When you paste this buffer it acts like you're typing it again and deletes the line.  You need to reassign it to another register with the let command before you can paste it properly and get at your nice input.

VimTip 437: extending keywords
http://vim.sourceforge.net/tip_view.php?tip_id=

sometime when you are working with an extended language (such as uC++) there exist
keywords that are not included as keywords in the vim release, so you can easily update
keywords in two ways.

1. edit your c.vim file [if you are coding c/c++] try 'vim61/runtime/syntax/' for location of these files,
    and add the keywords in the correct groups,

2. the second way is you can put them all in a separate file, and source it, eg:
   say i had some new c types, called uTask or uMutex i could get them highlighted as types
   using the following command:
	:syn keyword type uTask uMutex uNoMutex [etc..]

enjoy.
.. hzp.

VimTip 438: Search/replace "within selection" in gvim using '< '>
http://vim.sourceforge.net/tip_view.php?tip_id=

In other editors I've always used the search/replace "within selection" features a lot but never knew how to do that in gvim. I finally found the '< and '> marks

'< goes to the start of the last graphical selection (in gvim)
'> goes to the end of the last graphical selection

so you can use these to simulate the search "within selection" option that other programs have. eg:

:'<,'>s/fred/joe/g

will replace fred with joe in the last graphical selection

VimTip 439: Replace text in highlighted search
http://vim.sourceforge.net/tip_view.php?tip_id=

you can search for text and highlight it, using  /pattern
usually you want to replace the exact found occourences with another string, because the common trick to e.g. repeadetly pressing:
1. cw = change till end of word, or ct(  = change till first occourence of character (
2. n = next found pattern
3. . = do command 1. again
3. goto 2.
is too cumbersome, besides, you already specified what you want to replace with /pattern.

solution:

use c//e as 1. (it replaces till end of highlight).
you will NEED to bind:
nnoremap n //<CR>
nnoremap N ??<CR>
in your vimrc, or step 2. will end up with the cursorposition on the last character of your match, because it will remember the pseudo-search-command in step 1.

VimTip 440: Automatic formatting of paragraphs
http://vim.sourceforge.net/tip_view.php?tip_id=

When I use Vim to create plain-text files (like mail
messages) I like the feature that automatically makes lines
XY characters long. I simply type ':set tw=60' on the
command line, and as I type lines are broken (autorwapped)
before they reach 60 characters length.  The problem is,
when I latter decide to edit the paragraph. When I delete or
add some words, the paragraph looks broken.

The solution is to type '<Esc>gqap' to format a paragraph  or
make a mapping for this command. However, it annoys me to do
it repeatedly.

There is a better solution.

1. Go to http://cream.sourceforge.net/vim.html
and download the latest patched Vim

2. Install the program.

3. See :help auto-format.

I will not repeat the docs here. For the impatient, set
fotmatoptions to aw2tq ':set fo=aw2tq' and start typing.
The text flows automagically between lines as you type
text inside the paragraph.
GREAT!!!

VimTip 441: Toggle auto-wrap using txtwidth in INSERT mode
http://vim.sourceforge.net/tip_view.php?tip_id=

In INSERT mode, I would like to

1. keep tying without auto-wrap (good for editing vimrc and c)
2. wrap long line at will (good for email and text)

Following is the map I figured out, using <C-B> in this example:

set sr fo=roqm1 tw=64
im <C-B> <C-O>:setl sr! fo<C-R>=strpart("-+",&sr,1)<CR>=tc<CR>_<BS><Right>

By default, it goes without auto-wrap. If I want, I can type
<C-B> to triggle auto-wrap. Another <C-B> toggles back.

Basically it toggles two settings:

a) :set fo+=tc<CR>
b) :set fo-=tc<CR>

strpart() is used for toggling; "sr" is choosing for no good
reason; "_" can be any char; <BS><Right> is needed to *triggle"
this action.

It works for me on W2K. Please tell me if you have better ideas
to get this job done.

Note:  We may use 'linebreak', but that still leaves a really
long line. I would like to keep my &tw.

Thanks

VimTip 442: Show all lines that contain keyword under cursor
http://vim.sourceforge.net/tip_view.php?tip_id=

Started finding this one pretty useful.

If you want to view a list of all the lines in the current buffer that contain a word, place your cursor over the word and press [I

Handy to see where you last used variables, functions, etc.

VimTip 443: A better interfacing of (La)TeX with the quickfix mode
http://vim.sourceforge.net/tip_view.php?tip_id=

VIM's quickfix mode is a very nice feature. Nevertheless, I was not
completely satisfied when I used it together with (La)TeX. Here are the
main reasons:

* The default error format pattern is able to extract the line number
  and the error message, but not the column number.

* This pattern is of course unable to deal with BibTeX's or MakeIndex's
  error messages.

* TeX's messages are quite verbose. Having them displayed at each run,
  even when no error occurs is sometimes annoying.

Thus I implemented TeXwrapper, a small program which silently runs TeX
and optionally some associated tool like BibTeX, MakeIndex, eukleides or
Dvips. When an error occurs, TeXwrapper scans the transcript files and
prints to stderr "compiler style" error messages, i.e.:

		<filename>:<line>:<column>:<message>

This allows very simple settings on VIM's side, that is:

	set makeprg=texwrapper
	set errorformat=%f:%l:%c:%m

Someone writing an article with LaTeX containing cross references and a
bibliography may then use: "make -lb2 %". Option -l stands for "run
LaTeX" (instead of TeX), -b for "run BibTeX", -2 for "run twice" (to get
correct cross references).

Another feature is the --window option (short: -w). When something goes
wrong, a GTK+ window pops up, displaying a summary of the encountered
errors. Hence, one may use: "silent make -w %" which enables to avoid
the "Hit ENTER or type command to continue" message at each run.

TeXwrapper has been developed on a GNU/Linux system, but it should build
on any system where flex has been ported. The pop up window is opened by
a separate program, named texwrapper_window, which of course requires
the GTK+ library.

TeXwrapper has been released under the GPL and is available at:

	http://perso.wanadoo.fr/obrecht/texwrapper

Happy Vimming & TeXing!
Christian Obrecht

VimTip 444: quickfix show entire contents of multiline error in cwindow on cn, cp and cc
http://vim.sourceforge.net/tip_view.php?tip_id=

put this in your .vimrc if you use the cwindow

" \cc
map <Leader>cc :cwindow<cr>:cc<cr><c-w>b<cr>
" \cn
map <Leader>cn :cwindow<cr>:cn<cr><c-w>b<cr>
" \cp
map <Leader>cp :cwindow<cr>:cp<cr><c-w>b<cr>

and when you use \cc (or whatever your leader character is + cc), \cn or \cp, it will do what :cc, :cn and :cp usually did, with the added bonus of showing the entire contents of multiline errors.  this is especially useful for javac via ant, and it's obnoxious to keep typing <c-w>b<cr> every time i do a :cn, so i mapped this.

detailed explaination:
":cwindow<cr>" ensures that the quickfix window is show.
":cc" (:cn, and :cp) actually do the operation
"<c-w>b" go to the bottom window (which cwindow will be if it's shown) which will magically center on the error
"<cr>" carriage-return on the error line, taking you back to the code with the error

i know it probably seems superfluous if you haven't been personally affected by this particular annoyance.
thanks to freenode #vim for inspiration.

VimTip 445: Formatting stuff
http://vim.sourceforge.net/tip_view.php?tip_id=

Hello all, Im new to VIM, but I wanted to post some of my ideas for everyone here. Mark T, a friend of mine, just reciently got me in to VIM and I havent looked back yet! I really like this program, and I feel it's a valuable tool.

Mark and I program in Lisp and Visual lisp for AutoCAD. (Its a program for drafting) and I have been adding stuff to my 'rc' file for lisp programing for abbout a month now. Mark has convinced me to post some tips here. So here they are:

**********************************************************************
imap <Backspace> <left><del>
" this will allow me to always use the backspace key in insert mode

imap <C-j> <Esc>Ji
" this will allow me to join a line while still in insert mode

map .f v%zf
" fold an entire block of code

nnmap ,y <S-v>y
" This will select a whole line of text or it will select
" everything in a fold.

map .; v%:s/^/;;;/<CR>:noh<CR>
" comments out and entire block of code from paren to paren

:au BufRead *.lsp :loadview 1<cr>
:au BufRead *.LSP :loadview 1<cr>
" load the first fold view file for the current file

map st :set tw=70<cr>v<S-}>gq<End>
" this will allow you to format an entire block of text
**********************************************************************

John

VimTip 446: Quick and dirty Postgres query
http://vim.sourceforge.net/tip_view.php?tip_id=

Here is a simple and usefull mapping for anyone who can't stand developing queries on the psql prompt or messing around with the single \e psql edit buffer.

map <F9> :!psql -d yourdb < % <BAR> less

VimTip 447: Use the upper-lower case ~, also on Windows (ita)
http://vim.sourceforge.net/tip_view.php?tip_id=

For who know to change the case of key typed, otherwise see before the Tip #49 :^)

I had find usefull use ~ ( on linux :^) to change the case of word, but  also a my friend want this option on windows.
So i told him to use the ~ for this.
But italian keyboard have not the ~ on board.
So i have mapped this to a key, let read the code:

map <the key that you want> ~

Thats all.

I have used this on windows and italian keyboard, but i believe that is possible also on other keyboard yhat not have the tilde like us-keyboard.

NOTE:
Make attention to key that you use for mapping ~, some key ar used by vim, so for this don't work.

Have a nice day :^)

VimTip 448: Yank (copy) decimal numbers from hex numbers.
http://vim.sourceforge.net/tip_view.php?tip_id=

Here is a mapping that will copy a hexadecimal number in a register after converting it to the decimal equivalent.  The tip is pretty useful if you are a programmer.

:map \y g*<esc>:let @*=@/ + 0<enter>

Usage:
1.  Place the cursor on any hexadecimal number (eg 0xff, 0xfefe, 0x3434) and press \y.
2.  Place the cursor at the location where you want to paste the number in decimal and press "*p
3.  The number is also copied to the clipboard (windows) so you can paste it in other applications.

Example:
If the hexadecimal number is 0xff, then 255 will be copied to the clipboard.

Configuring the tip.
If you do not like the above key combinations or the register being used, you can configure the tip to use other mappings as explained below:
1.  Change \y in the above mapping to any key combination of your choice.
2.  Change @* to @<any_other_lower_case_letter> to copy the contents to another register.  If you do this, pasting will require the command "<that_same_lower_case_letter>p

Side effects:
1.  The tip uses the search register for the conversion.  Therefore any last search will be lost.
2.  The tip also uses a register to yank the result.  The earlier contents of that register (in our case the * register) will be lost.

-mohit

VimTip 449: FORTRAN highlighting problems
http://vim.sourceforge.net/tip_view.php?tip_id=

Sometimes the FORTRAN syntax file doesn't set the correct source form.

So if you want to choose it by yourself, add the following line in your vimrc file:

au BufNew *.for let b:fortran_fixed_source=1    " set the correct value

The other way to do this is to change the file extension (F77/F90/F95), but it might be a long and/or hazardous work for big projects...

VimTip 450: Working with multiple sessions
http://vim.sourceforge.net/tip_view.php?tip_id=

The problem I'm trying to solve:
I usually need to work on different projects (let us call them: PROJ1 and PROJ2). These are in different directories, have
different files.. etc. It would be nice if I can instruct my editor to take me back to the exact session (see :help sessions)
for each of these projects - open the required files and buffers, window layout etc...

Solution
1. Append the following code to your .vimrc
    - Change the variable g:PathToSessions to your desired place, if needed (make sure that this directory exists and is writable)
2. Open all/some files in a particular project (as if you are working on that) in gvim. Say I open all my PROJ1 related files.
    You can split windows etc.. and make it look as if you are really working! :-) Do a

    :SetSession PROJ1

3. Quit gvim
4. Restart gvim without any filenames at the command line.
5. You ought to get a popup-entry asking you which session to restore. Choose PROJ1.vim to see the effect.
6. Repeat with other projects.

Note:
1. You don't have to :SetSession everytime you open gvim as in step 5. Only once.
2. If you start vim with no files at the command line, you have an option of going back to the last saved session (this
    is available in the gui if you choose LastSession.vim)

CODE STARTS
au VimLeave * call VimLeave()
au VimEnter * call VimEnter()

let g:PathToSessions = $HOME . "/.vim/sessions/"

function! VimEnter()
   if argc() == 0
      " gvim started with no files
      if has("browse") == 1
         let g:SessionFileName = browse(0, "Select Session", g:PathToSessions, g:PathToSessions . "LastSession.vim")
         if g:SessionFileName != ""
            exe "source " . g:SessionFileName
         endif
      else
         " For non-gui vim
         let LoadLastSession = confirm("Restore last session?", "&Yes\n&No")
         if LoadLastSession == 1
            exe "source " . g:PathToSessions . "LastSession.vim"
         endif
      endif
   endif
endfunction

function! VimLeave()
   exe "mksession! " . g:PathToSessions . "LastSession.vim"
   if exists("g:SessionFileName") == 1
      if g:SessionFileName != ""
         exe "mksession! " . g:SessionFileName
      endif
   endif
endfunction

" A command for setting the session name
com -nargs=1 SetSession :let g:SessionFileName = g:PathToSessions . <args> . ".vim"
" .. and a command to unset it
com -nargs=0 UnsetSession :let g:SessionFileName = ""
CODE ENDS

VimTip 451: KDE Konsole renameSession to edited file name
http://vim.sourceforge.net/tip_view.php?tip_id=

In Kde the renameSession will set the Konsole name. Add this to your
.vimrc file to name the session after the edited file.

autocmd BufReadPost * :silent !dcop $KONSOLE_DCOP_SESSION renameSession %

VimTip 452: Unix: Editing multiple files, listed in a file, one per line, from the command-line
http://vim.sourceforge.net/tip_view.php?tip_id=

I needed to edit about 300 files in a directory tree that all contained a specific line.  I used -w {scriptout} on the first file to write my macro, and then used this command line to execute the rest:

     vim -s scriptin `cat file-containing-files`

This cats the file containing the multiple files, one per line, to the command line, allowing you to edit tens, hundreds or even thousands of files using the same script.  Of course, I had to use a recursive macro to get it done.  Here's what I used:

     qq/\.\.\.\.\.\.Complete^Mdd:wn^M^M@qq@q

Basically recording the macro, searching for my string, deleting that line, writing the file and going to the next, then executing itself (@q), ending the macro and then executing itself.  This way one script could be used to edit all 300 of my files.

VimTip 453: Use Taglist with LaTeX files
http://vim.sourceforge.net/tip_view.php?tip_id=

First, you have to add a new language to ctags
in ~/.ctags add :
<.ctags>
--langdef=tex
--langmap=tex:.tex
--regex-tex=/\\subsubsection[ \t]*\*?\{[ \t]*([^}]*)\}/- \1/s,subsubsection/
--regex-tex=/\\subsection[ \t]*\*?\{[ \t]*([^}]*)\}/+\1/s,subsection/
--regex-tex=/\\section[ \t]*\*?\{[ \t]*([^}]*)\}/\1/s,section/
--regex-tex=/\\chapter[ \t]*\*?\{[ \t]*([^}]*)\}/\1/c,chapter/
--regex-tex=/\\label[ \t]*\*?\{[ \t]*([^}]*)\}/\1/l,label/
--regex-tex=/\\ref[ \t]*\*?\{[ \t]*([^}]*)\}/\1/r,ref/
</.ctags>

I think this good for me but if someone found something better, i will be happy :)

Edit taglist.vim (my patch for version 2.4) :
--- taglist.vim 2003-04-14 16:47:25.000000000 +0200
+++ .vim/plugin/taglist.vim     2003-04-14 15:00:04.000000000 +0200
@@ -509,6 +509,9 @@
 " vim language
 let s:tlist_def_vim_settings = 'vim;a:autocmds;v:variable;f:function'


+" tex language
+let s:tlist_def_tex_settings = 'tex;s:section;c:chapter;l:label;r:ref'
+
 " yacc language
 let s:tlist_def_yacc_settings = 'yacc;l:label'

in vim, type :
:Tlist

or see taglist doc

references :
Taglist : http://www.vim.org/scripts/script.php?script_id=273
ctags : http://ctags.sourceforge.net
Vim-LaTeX : http://vim-latex.sf.net/

VimTip 454: Syntax Highlighting Keeps Breaking (and how to fix it!)
http://vim.sourceforge.net/tip_view.php?tip_id=

If you vim syntax highlight keeps breaking as you move around your document this is the tip for you!   :)

First of all, how to fix it:
    put the following in your .vimrc (_vimrc on windows):
        "autocmd BufEnter * :syntax sync fromstart"

now, you might say, "Robert, I already put 'syntax sync fromstart' in my .vimrc, and it doesn't work!" -- and in saying that, you would be correct, because of a few factors coming together to cause you pain.

Factors:
    1. Vim syntax files should define the best syntax sync method for that langauge
    2. Many vim syntax files do not do #1
    3. Almost all syntax files do a :syntax clear which removes _your_ sync setting

Notes:
    The syntax files that tend to have the most trouble keeping sane highlighting are multilangauge files (html/javascript -- html/php/javascript ...), yet the all work perfectly with :syntax sync fromstart.  This is not a vim bug, but a problem with the syntax files, yet, it has been argued that maybe vim should NOT clear out the sync setting when doing a syntax clear -- and just wait for it to be overwritten... like everything else -- that is debatable  :)

Hope this helps you... join #vim on irc.freenode.net for all your vim help needs :)

VimTip 455: Map a function key to toggle line wrapping
http://vim.sourceforge.net/tip_view.php?tip_id=

Most of the time I want to have line wrapping on. But, there are some times that I want to toggle it off, to check structures or something... here's a function key for toggling line wrapping:

:set wrap
:let g:toggleWrap = 0
map <silent> <F6> :if g:toggleWrap == 1<CR>:set wrap<CR>:let g:toggleWrap = 0<CR>:else<CR>:set nowrap<CR>:let g:toggleWrap = 1<CR>:endif<CR>

Tom.

VimTip 456: escape  select mode in a map command (used to map indent in select mode)
http://vim.sourceforge.net/tip_view.php?tip_id=

When using mswin behaviour, the select mode is activated each time you select some text with shit+arrows or with the mouse. Then entering '>' to ident the text will just replace selected text with >. To offer a behaviour similar to visual text editor, I use the following mappings :

vmap    <Tab>         ^0   >
vmap    <S-Tab>     ^0   <

then in select mode, tab will go to to visual mode, shift one block  and then return to select mode ! Shit-Tab will just do the same thing, going backward.

VimTip 457: Follow tag in new window
http://vim.sourceforge.net/tip_view.php?tip_id=

If you use tags, you might want to follow a tag, but leave the current window open.  The following mapping allows you to do this easily with Ctrl-\.
:map <C-\> :sp<CR><C-]><C-w>_

VimTip 458: How to use quickfix mode to see all errors in one window (:cwindow).
http://vim.sourceforge.net/tip_view.php?tip_id=

Uptil vim 5.8, I was using the cfile, clist...etc for quickfix mode.
In vim6.x, I found out that :cw will boost my productivity as  a programmer.

To make,
type :make as we do in older versions of vim (<6.0).
Instead of clist,cfile...etc, type
:cw<enter>
you get one split window, in which errors are listsed. Current error line will be highlighted and cursor will move to the corresponding source file line.
Doing an <enter> on any error line in the error window will take the cursor to the corresponding source line.
This eliminates the need for the process described in vimtip #345.(Now you can get rid of Visual studio altogether !)

Details:
Help is available in vim 6.x onwards by entering :help cw

VimTip 459: Use Ctrl-O instead of Esc in insert mode mappings
http://vim.sourceforge.net/tip_view.php?tip_id=

Theory: Ctrl-O in insert mode switches to normal mode for one command and then switches back to insert mode.

Practice: Mappings like

:imap <f5> <esc>:set number!<cr>a

move the cursor one character right when it's in the first column. Use

:imap <f5> <c-o>:set number!<cr>

instead, it has no side-effects. If you have <f5> mapped in normal mode too (to do the same thing),

:imap <f5> <c-o><f5>

is even better.

When you need to do more than one thing in the mapping, you can
- use more Ctrl-O, one before each command, or
- use | to run more commands at once, or
- define a command (or function) doing everything and map <f5> to it.
- ... (TMTOWTDI)

VimTip 460: how to implement vertical lines showing tab groups..
http://vim.sourceforge.net/tip_view.php?tip_id=

When browsing the jEdit screenshots page, I saw a feature I wanted and didn't have in vim.  It was a vertical line showing tab groups.

if (this) {
|   if (that) {
|   |   do stuff;
|   }
}

http://www.jedit.org/index.php?page=screenshot&image=10 <-- show a much better example that my little example did...

I was wondering how todo this in vim.. turns out it is simple
    :set list
    :set listchars=tab:\|\

    :h listchars for help

Hope this helps you... join #vim on irc.freenode.net for all your vim help needs :)

VimTip 461: Open a Perl module based on it's module name
http://vim.sourceforge.net/tip_view.php?tip_id=

This may be of interest to Perl programmers using vim. Sometimes I want to open up the source code of a system Perl module that's installed. Here's one way to do that:

:e `perldoc -l Module::Name`

I find that useful.

VimTip 462: G's of Vim
http://vim.sourceforge.net/tip_view.php?tip_id=

Hi Guys !!

You can play with THE "g" in VIM editor.

Try this

Place the cursor on any variable in your program.

gd          will take you to the local declaration
gD          will take you to the global declaration.
g*           search for the word under the cursor. It's just like * but don't put < or > around words
              so here you can search word which contains word under your cursor
              Confused ???? try it NOW :-)
g#           same as g* but in backward direction

Now time for gssssss


ggdG       takes out all your hard work ;-) I mean deletes the content of the file ..

Happy viming ...

VimTip 463: XSLT Mappings I use to speed up developing XSLT files.
http://vim.sourceforge.net/tip_view.php?tip_id=

I recently added these mapping to speed up typing XSLT elements. As this is my first tip, I hope these might be useful to someone else. I added these mappings to my copy of Devin Weaver's xmledit script.

imap <Leader>pi <?xml version="1.0" ?>^M
imap <Leader>ap <xsl:apply-templates/>
imap <Leader>ap`s <xsl:apply-templates select=""/>^[F"i
imap <Leader>ap`sm <xsl:apply-templates select="" mode=""/>^[3F"i
imap <Leader>at <xsl:attribute name="">^[F"i
imap <Leader>el <xsl:element name="">^[F"i
imap <Leader>if <xsl:if test="">>^[kf"a
imap <Leader>im <xsl:import href=""/>^[F"i
imap <Leader>in <xsl:include href=""/>^[F"i
imap <Leader>ou <xsl:output method=""/>^[F"i
imap <Leader>pa <xsl:param name=""/>^[F"i
imap <Leader>pa`ns <xsl:param name="" select=""/>^[3F"i
imap <Leader>st <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">>
imap <Leader>te <xsl:template match="">>^[kf"a
imap <Leader>te`n <xsl:template name="">>^[kf"a
imap <Leader>te`mm <xsl:template match="" mode="">>^[kf"a
imap <Leader>va <xsl:value-of select=""/>^[F"i
imap <Leader>wi <xsl:with-param name=""/>^[F"i
imap <Leader>wi`ns <xsl:with-param name="" select=""/>^[3F"

For more information:
vimscript #301
help: imap

VimTip 464: search & replace the word under the cursor
http://vim.sourceforge.net/tip_view.php?tip_id=

I have this usefull mapping in my vimrc:

nmap ; :%s/\<<c-r>=expand("<cword>")<cr>\>/

Now, if you see a word 'foo' which should be replaced, you only have to put the cursor on it and type ';'.
Then the command-prompt has already the annoying :%s/\<foo\>/ and you just have to enter your new word.

For information:

:help <c-r>
:help expand

VimTip 465: generic xml imap to make an element of any word you type
http://vim.sourceforge.net/tip_view.php?tip_id=

Hi all.

We're doing a lot of xml work, in docbook and custom xml files.

I'd just like to share one macro I've developed, that I really can't live without.

imap ,,, <esc>bdwa<<esc>pa><cr></<esc>pa><esc>kA

If in isert mode I type programlisting,,,
the text immediately get's modified to
<programlisting>
</programlisting>
with the cursor in between, still in Insert mode.

The same happens with any other word i type followed by three commas.
<tryit>
</tryit>

It saves me a lot of work, and I'd like to share it. Hope you can use it

Bart van Deenen. (bart@vandeenensupport.com)

VimTip 466: Insert one character only
http://vim.sourceforge.net/tip_view.php?tip_id=

I have not yet seen this idea yet.  But early in my use and love of Vim, I got frustrated in command mode when I wanted to insert just one character of text.  So I put this in _vimrc:

"insert one character
noremap <somekey>  i<Space><Esc>r

I think it has been one of the most time saving mappings -- and I have remapped most of my keyboard.

VimTip 467: vim windows displaying output inside vim window
http://vim.sourceforge.net/tip_view.php?tip_id=

In vim for *nix or cygwin, the command

:!cmd

displays the output inside vim windows,
but for vim windows, the output is displayed in the console window.
To make the output displayed inside vim or gvim window,
can use

:echo system("command")

references:
:help system()
:help echo

VimTip 468: display date-and-time on status line
http://vim.sourceforge.net/tip_view.php?tip_id=

It didn't seem like an existing tip mentioned this, so:

The following lines in .vimrc or a plugin file will display
the time of day and calender date (some of us need that reminder)
on the editor status line:

set ruler
set rulerformat=%55(%{strftime('%a\ %b\ %e\ %I:%M\ %p')}\ %5l,%-6(%c%V%)\ %P%)

It doesn't update time if you issue no keystrokes, but as soon as you
do anything at all in the editor, you will get the current time.

VimTip 469: The use of  %< instead of %
http://vim.sourceforge.net/tip_view.php?tip_id=

This tips is for vim or gvim user. We know the following map

map! /' ^[:w^M:! latex %^Mi

is doing the following. By typing "/'" in insert mode, this
will save the current tex file, and compile it.
The reader understand that one can change "/'" by anything he want,
as long as it does not bug its own configuration, I like this map 'cause
on an english keyboard both / and  ' are close to eachother.

We may wonder
what to do if we wish to open the associated dvi file?!
Indeed one has to replace % by %<.dvi and then we get

map! <F4> ^[:! xdvi %<.dvi ^Mi
or
map! <F4> ^[:! kdvi %<.dvi ^M
if you are using K environement.

The same thing apply indeed for any other extension i.e.,
the map
map! <F5> ^[:! gv %<.ps ^Mi
will open the associated ps file with gv.

VimTip 470: Map to quickly swap/exchange arbitrary text
http://vim.sourceforge.net/tip_view.php?tip_id=

When editing text, it's not uncommon to need to swap two bits of text.  In
Vim, it's easy to swap adjacent characters, words and lines (see vimtip #47),
but to swap non-adjacent text (such as comma-separated words, variable
assignments, and function parameters), you usually have to resort to a tedious
delete/move/put/delete/move/put sequence.

Mappings such as the one in vimtip #329 can help in some cases, but for a more
general solution, try this mapping:

	vnoremap <C-X> <Esc>`.``gvP``P

To use it:  First, delete some text (using any normal Vim command, such as
daw, {Visual}x, or dt,).  Then, visually select some other text, and press
CTRL-X.  The two pieces of text should now be swapped.

For example, to swap "apple" and "orange" in the line below:

        int apple, lemon, orange;

1. Delete "apple", using (for example) diw or <double-click>d
2. Visually select "orange"
3. Press CTRL-X

The mapping is not limited to single words, though, and will work with
anything you can delete/select (even lines and blockwise selections).

VimTip 471: Bridging the worlds: putting your rodent to work for vim in xterms
http://vim.sourceforge.net/tip_view.php?tip_id=

If, like me, you don't want to use the GUI vim because you work in an xterm most of the time anyway, you may be annoyed at the shortcomings this presents. For example, during my webbrowsing, I'll often fire up vim in one of the already lying around xterms to conveniently write a long text (such as this one), and then paste from vim into a textfield on a HTML form in the browser.

The first problem is caused by line numbering, which I keep enabled at all times.

:set number
:help number

Normally, if you try to copy text out of the xterm that vim is running in, you'll get the text as well as the numbers. The GUI version gets this right: it only selects the text, keeping the line numbers out of the picture. But I don't want the GUI version. So instead, I added this to my vimrc:

:set mouse=a

Much better. You can also selectively enable mouse support for specific modes only by using something other than 'a' (for 'all').

:help mouse

Now although I'm more of a keyboarder, when I juggle text between X apps (or maybe between xterms), it's just more convenient and efficient to keep my hands on my mouse, since they're there anyway. Now, if you own a moderately recent model, you'll know this lovely little wheel they have (which usually also doubles as mouse button 2). Rolling it scrolls the window in GUI vim, which simplifies life when selecting several, distant passages to paste one after the other. But I don't want to use the GUI vim - you can imagine my delight when I ran across this in the vim documentation:

:help wheel

It involves adding a couple mappings to your vimrc and corresponding VT100 translations to your .Xresources file as a prerequisite. Don't forget

$ xrdb -load .Xresources

after you edit the file. The running xterm will not heed the changes; you need to open a new one to see the effect.

The wheel may not work with the mappings as described in the helpfile. They worked without a hitch for me at first (using Xfree 4.1 then), but broke after I upgraded my distro. Whether it was the switch to 4.3 on this binary has been built with different options, I don't know. At any rate, I had to experiment a bit with the list from

:help keycodes

After a bit of trial and error, I finally fixed them by substituting <xCSI> for <M-Esc>:

:map  <xCSI>[62~ <MouseDown>
" etc
" ...

Done. Load a large text file and marvel at mousewheel scrolling.

VimTip 472: Handy option flag toggler
http://vim.sourceforge.net/tip_view.php?tip_id=

Here's a little function I put together to make some of my mappings easier to read, understand and change.

function ToggleFlag(option,flag)
    exec ('let lopt = &' . a:option)
    if lopt =~ (".*" . a:flag . ".*")
	exec ('set ' . a:option . '-=' . a:flag)
    else
	exec ('set ' . a:option . '+=' . a:flag)
    endif
endfunction

Examples of use:

map <silent> <F8> :call ToggleFlag("guioptions","m")<CR>
map <silent> <F9> :call ToggleFlag("guioptions","T")<CR>

Can anyone see anyway to improve it?
e.g. remove the leading exec... "if &{a:option}..." doesn't work.
e.g. a regex match doesn't seem the cleanest of checks, though I prefer it to setting a variable for each possible flag.

VimTip 473: "compiler" for perl
http://vim.sourceforge.net/tip_view.php?tip_id=

At on stage I was writing a lot of perl scripts/modules with Vim and found it useful to be able
to run the perl syntax-checker (perl -c) from within Vim via the "make" function. To be able
to do this you'll need to add the following Module (VimCompile.pm) to your @INC
---------------<cut here>---------------
#!/usr/bin/perl -w
#$Id: VimCompile.pm,v 1.2 2002/02/16 01:07:03 forkin Exp $
# reformat "perl -c" syntax-check error-/warning-messages for Vim
package VimCompile;

use strict;

sub _die {
    my ($msg)=@_;
    $msg=~s/^((.* at )((.*) line )([0-9]+)(\.|, near .*))$/$4:$5: $1/mg;
    die qq/$msg/;
}
sub _warn {
    my ($msg)=@_;
    $msg=~s/^((.* at )((.*) line )([0-9]+)(\.|, near .*))$/$4:$5: $1/mg;
    warn qq/$msg/;
}
$SIG{'__DIE__'}=\&_die;
$SIG{'__WARN__'}=\&_warn;
# return OK
1;
__END__
------------<cut here>---------------
This Module will reformat the warnings/errors so that Vim can parse them (to allow you to
jump to the location/source-code of the error). You will also need to deposit the following
(perl.vim) in your ~/.vim/runtime/compiler directory.
------------<cut here>---------------
" Vim compiler file
" Compiler:     perl (output of "die" massaged)
" Maintainer:   Chris Forkin, chris@forkin.com

if exists("current_compiler")
  finish
endif
let current_compiler = "perl"

" A workable errorformat for "perl -c"
setlocal errorformat=%f:%l:\ %m

" default make
setlocal makeprg=perl\ -MVimCompile\ -c\ %
------------<cut here>---------------

VimTip 474: have . restore the cursor position a la emacs in viper mode
http://vim.sourceforge.net/tip_view.php?tip_id=

Before making the switch to vim, I spent time in limbo using EMACS in viper mode (which is EMACS with vi emulation).  Despite the vast improvements in most areas, there were a few things I missed from EMACS.  One thing I really missed was the behavior of the . command, which always restored the cursor position.

For example, let's say I had the following:

foo.some_method.each do { |x| puts x }
foo.some_other_method(Time.now)
foo.close()

and I wanted to change foo to bar.  I would always use a cw and then the . command:
cwbar<cr>j.j.

rather than making a substitute command which would make me worry about the range over which it should take place etc.

When making the switch to vim, I was disconcerted because after the first . my cursor was at the end of the second 'bar'.

In fact I pretty much always wanted this behavior from '.', so this mapping helped me out:

"make . not move the cursor
noremap . mz.`z

I've since noticed this is just a special case of the tip *restore-position* in the help manual, but it took me a while to find out how to do this.  One other former emacs/viper user also was searching for this.  Hopefully this tip makes it easier for the next person to find who finally finds their way out of EMACS.

VimTip 475: wrap visual selection with fold markers
http://vim.sourceforge.net/tip_view.php?tip_id=

Use this vmap to enclose a block with fold markers:

vmap    <leader>fold mz:<esc>'<O// {{{<esc>'>o// }}}<esc>`z?{{{<cr>A<space>

VimTip 476: multime errorformat & makeprgs
http://vim.sourceforge.net/tip_view.php?tip_id=

I was fiddling around with the errorformat and makeprg opts, and as I code in different languages, i was wondering if there was a way of specifiing a special makeprg and errorformat parameter for each language.... and THERE IS!!

just edit the $VIM/ftplugin/[syntaxfile].vim

i.e.: perl.vim
added at the end :
set makeprg=$HOME/bin/vimparse.pl\ -c\ %\ $*
set errorformat=%f:%l:%m

c.vim
set makeprg=g++\ %

well, and you get the pattern.

It works delightfully with the :Make tip vimtip #203

Ah! I mapped F-5 to :Make, and made it go back to the main window:
map <F5> :Make<cr><C-w><Up>

VimTip 477: How to put the indentation level on the status line
http://vim.sourceforge.net/tip_view.php?tip_id=

related to vimtip #303

in .vimrc

set statusline=<Whaterever your status is>\t%{ShowTab()}\ %P

fu ShowTab()
   let TabLevel = (indent('.') / &ts )
   if TabLevel == 0
      let TabLevel='*'
   endif
   return TabLevel
endf

VimTip 478: Copy the search results into clipboard
http://vim.sourceforge.net/tip_view.php?tip_id=

" previous clear the clipboard with this command :normal "*y0
" Usage: :g/<pattern>/call CopyPattern()
function CopyPattern()
	let idx = 0
	let xEnd = 0

	while idx >= 0
		let @* = @* . matchstr(getline("."), '' . histget("/", -1), idx) . "\n"
		let xEnd = matchend(getline("."), '' . histget("/", -1), idx)
		let idx = match(getline("."), '' . histget("/", -1), xEnd)
	endwhile

	unlet idx
	unlet xEnd
endfunction

VimTip 479: Replace with NO Typing
http://vim.sourceforge.net/tip_view.php?tip_id=

Often I replace one word with another.  This is much faster than the substitute command and requires no typing.

For example, to change badName(...) to goodName(...) (with the mappings below):

1.  Put the cursor anywhere on goodName and type:  gy

2.  Move the cursor to badName and type:  gp

That's it!

If there are more than one badNames, type *N before typing go, then n gp to change the next one.

I mapped go to put a space after the word, but someone clever might be able to combine them.

Here is how I mapped the commands:

"replace word with register b WITH SPACE AFTER word
noremap go lb"bPldwi <Esc>hbye

"replace word with reg b WITHOUT SPACE after word
"(lb so no move to previous word, but gives error at end of line)
noremap gp lb"bPldwhbyw

"copy this word to register b for replacing with go and gp
noremap gy lb"bye

VimTip 480: editing files on an ftp server listening  on a non-standard port
http://vim.sourceforge.net/tip_view.php?tip_id=

Vim will edit files on an FTP server with the command:

e ftp://ftp.server/path/to/file/filename

But if you are using a virtual FTP server as in Bricolage to edit templates, the FTP server is listening on a non-standard port (typically 2121, but it can be something different).

In that case, the command would be

e ftp://ftp.server\#2121/path/to/file/filename.

Note the "\#".  The standard syntax for specifying a port number is to append #2121 to the server name, where "2121" is the port to connect to. But Vim treats an unescaped "#2121" as an alternate file reference and fails with the message "No alternate file name to substitue for '#'".  Escaping the "#" causes Vim to treat is an another character in the string, and the connection works.

help edit and then search for "count" to find the syntax for editing alternate files

This works on Red Hat and on WindowsNT.

VimTip 481: abbreviations only on shortcut
http://vim.sourceforge.net/tip_view.php?tip_id=

Actually, this is just a more flexible completion.

I made the following (example) to have a unique abbreviation:

  iabbrev date^A  <c-r>=strftime("%F")<cr>

Note that ^A is Control-A (insert with <c-v><c-a>).
This is to avoid the completion if you really want to write 'date'.

And now this mapping:

  inoremap <c-b> <c-v><c-a><c-[>a

Now type date<c-b> in insert-mode and you will get the date.

VimTip 482: Use VIM as an organizer of Memos, bookmarks, todo, etc.
http://vim.sourceforge.net/tip_view.php?tip_id=

No one has perfect memory. I know this when I saw clever person often key in notes in his computer.
He uses a number of small files with ".txt" extension and "grep" through them. To me this is not good
because you still need to give a different name to different things and as time goes by, you will useup
common words and starts "name1", "name2", ... to enumerate.

Have you ever thought of having one single Memo at hand that can put things down as normal
editor, still very easy to search and navigate through? HTML would be perfect for hypertext
navigation, but it is not as perfect for writting notes. Who knows what <H3> means level 3 headings
when i just want to use to highlight my text, ... A lot inconvenience.

I use VIM! For many years it helps me remember almost everything and still enjoy it. Let me share
the experience with you. Of course I expect you be a VIMMER as me first.

VIM as an organizing tool? The help system of VIM is so well organized that we can think
of reusing the same for our everyday purpose. For example, here is my own Memo (abridged):
<<cut here>>
*memo.txt*      My Memo   - extending my poor memories                |guide|
-------------------------------------------------------------------------------------------------------------
*subjects*                                                                                     *toc*
|cmd|  command tips    |def|   definitions
|dev|   developments     |ed|    editors              |friends|  friends
|lang|  languages          |misc|    others
|private|  personal info   |sys|   system
-------------------------------------------------------------------------------------------------------------
Commands                                                               *cmd*
*General
        http://www.cslab.vt.edu/manuals
         ......
|doskey|    DOS key utility
        <F8>: expand history
|man|        Unix manual
                man foo
                nroff -man foo.1 | less
                nroff -man foo.1 | a2ps -m
|unix|
    http://gd.tuwien.ac.at/linuxcommand.org/
|winhelp|
.....
-------------------------------------------------------------------------------------------------------------
Development                                                        *develop*            *dev*
...
-------------------------------------------------------------------------------------------------------------
vim:tw=78:fo=tcq2:isk=!-~,^*,^\|,^\":ts=8:ft=help:norl:
<<cut here>>
Some explainations:
1) The last line instructs VIM with a number of editing settings. The most
important one here is "ft=help", which says file-type is "help"! So the VIM
will highlight thing for us.
2) You can use *foo* to indicate an anchor to the "help" system of VIM.
If you press Ctrl + ] on a word "foo", the cursor will jump to the first *foo*.
You can also see |foo| as a way to highlight it as implicit keywords.
3) This is not magic. The mechanism behind is the tag system. VIM needs
to have the following tag file to go to where you want it to go:
===================================
%userprofile%   memo.txt   /*%userprofile%*
.htaccess   meo.txt   /*.htaccess*
access  memo.txt   /*access*
access.conf memo.txt   /*access.conf*
addressbook memo.txt   /*addressbook*
anchor_keyword  memo.txt   /*anchor_keyword*
apache  memo.txt   /*apache*
as  index.txt   /*as*
at  index.txt   /*at*
awk index.txt   /*awk*
===================================
Each line defines a tag, the first element is the keyword,
the second is the file where the tag belongs (yes, you can use
multiple files as long as you know what they are), and the last
element is the command which as VIM to perform at the keyword (you
can as well do something wield here, but that's your own business).
4) But that's tedious! How to write these tags? God save you and thanks
VIM, you can find this utility to do it:
    cc doctags.c -o doctags
    doctags memo.txt | sort -f | awk -f cases.awk >tags
    uniq -d -2 tags
------------------------------------------------------------------------------
<<cut here>> doctags.c

/* vim:set ts=4 sw=4:
 * this program makes a tags file for vim_ref.txt
 *
 * Usage: doctags vim_ref.txt vim_win.txt ... >tags
 *
 * A tag in this context is an identifier between stars, e.g. *c_files*
 */

#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <stdlib.h>

#define LINELEN 200

	int
main(argc, argv)
	int		argc;
	char	**argv;
{
	char	line[LINELEN];
	char	*p1, *p2;
	char	*p;
	FILE	*fd;

	if (argc <= 1)
	{
		fprintf(stderr, "Usage: doctags docfile ... >tags\n");
		exit(1);
	}
	printf("help-tags\ttags\t1\n");
	while (--argc > 0)
	{
		++argv;
		fd = fopen(argv[0], "r");
		if (fd == NULL)
		{
			fprintf(stderr, "Unable to open %s for reading\n", argv[0]);
			continue;
		}
		while (fgets(line, LINELEN, fd) != NULL)
		{
			p1 = strchr(line, '*');				/* find first '*' */
			while (p1 != NULL)
			{
				p2 = strchr(p1 + 1, '*');		/* find second '*' */
				if (p2 != NULL && p2 > p1 + 1)	/* skip "*" and "**" */
				{
					for (p = p1 + 1; p < p2; ++p)
						if (*p == ' ' || *p == '\t' || *p == '|')
							break;
					/*
					 * Only accept a *tag* when it consists of valid
					 * characters and is followed by a white character or
					 * end-of-line.
					 */
					if (p == p2 && (p1 == line || p1[-1] != '-') &&
							(strchr(" \t\n\r", p[1]) != NULL || p[1] == '\0'))
					{
						*p2 = '\0';
						++p1;
						printf("%s\t%s\t/*", p1, argv[0]);
						while (*p1)
						{
							/* insert backslash before '\\' and '/' */
							if (*p1 == '\\' || *p1 == '/')
								putchar('\\');
							putchar(*p1);
							++p1;
						}
						printf("*\n");
						p2 = strchr(p2 + 1, '*');		/* find next '*' */
					}
				}
				p1 = p2;
			}
		}
		fclose(fd);
	}
	return 0;
}
<<cut here>> cases.awk
{
print tolower($1) "\t" $2 "\t" tolower($3);
}
<<cut here>>

That's it. Good luck VIMMER.

VimTip 483: Using GREP for a list occurrences and quickfix help command.
http://vim.sourceforge.net/tip_view.php?tip_id=

This is inspired by VIMTIP#391: Simple programmers TODO list using grep and quickfix
taglist.vim is VIMSCRIPT#273

This is a little tip on shortcuts to make :grep just a little bit more handy.

:GREP is simply a front end to :grep which uses the current word under the cursor and the current file.
Use this for the times when you want a list occurrences type search. (See also :h :ilist another method)

" [Feral:158/03@07:02] Easily GREP current word in current file.
command GREP    :execute 'grep '.expand('<cword>').' '.expand('%') | :copen | :cc

Certainly nothing fancy here.

Now given that continually typing :cnext, :cprev and :cc can get a bit cumbersome to type one might consider mappings to speed up the process. When such mappings call a user function we can get somewhat fancy as illustrated below.

"[Feral:314/02@19:33] Assign some keys for handy quickfix window commands.
if has("win32")
    nnoremap <kPlus>        :call <SID>Fancy_Quickfix_Cmd(':cnext')<cr>
    nnoremap <kMinus>        :call <SID>Fancy_Quickfix_Cmd(':cprev')<cr>
    nnoremap <kMultiply>    :call <SID>Fancy_Quickfix_Cmd(':cc')<cr>
    nnoremap <c-kPlus>    :clast<CR>
    nnoremap <c-kMinus>    :cfirst<CR>
    nnoremap <m-kPlus>    :cnewer<CR>
    nnoremap <m-kMinus>    :colder<CR>
endif

" [Feral:158/03@08:02] Very simple wrapper: do quickfix cmd, center line and
"    if taglist.vim's window is open sync
function s:Fancy_Quickfix_Cmd(Cmd)
    :try
        execute a:Cmd
    :catch /^Vim(\a\+):E553:/
        :echohl ErrorMsg | echo v:exception | echohl None
    :endtry

    :norm! zz

    " If the taglist window is open then :TlistSync
    "    Tag list window name: '__Tag_List__'
    if bufwinnr('__Tag_List__') != -1
        :TlistSync
    endif
endfunction

NOTE that s:Fancy_Quickfix_Cmd() uses VIM 6.2s new try/catch commands; For previous versions just omit the try/catch  endtry lines. The function works well enough just is not as graceful when you reach the first or last of the error list. I.e. PRE 6.2 version:
function s:Fancy_Quickfix_Cmd(Cmd)
    execute a:Cmd
    :norm! zz
    " If the taglist window is open then :TlistSync
    "    Tag list window name: '__Tag_List__'
    if bufwinnr('__Tag_List__') != -1
        :TlistSync
    endif
endfunction

Just as an asside, if you did not want to use a user command for something like this you can do something like this:

nnoremap <kPlus>        :cnext<CR> :norm! zz<cr> :TlistSync<CR>
nnoremap <kMinus>        :cprev<CR> :norm! zz<cr> :TlistSync<CR>
nnoremap <kMultiply>    :cc<CR> :norm! zz<cr>

Of course if you do not have/want the syncing with taglist.vim simplly remove :TlistSync.

Now, the advantage of having s:Fancy_Quickfix_Cmd() is that we can conditionally do something based on the command, or some other attribute. In this case we function the same for all commands (and just blindly execute them). We do check to see if the taglist window is open and if so ask it to Sync, if it is not, we don't.  One other (minor, cosmetic) advantage to this is we see the user command in the echo area and not the last command executed (as with just the pure mapping method directly above).

You may need to modify the :GREP command so that your grep has the proper flags, etc. On win32 I have my grepprg set to "set grepprg=C:\Dev\bin\grep.exe\ -niH", fwiw.

Happy VIMing!

VimTip 484: Console-like fonts for Windows GVim
http://vim.sourceforge.net/tip_view.php?tip_id=

For some excellent "DOS"-like fonts in multiple sizes (.fon format) check out http://www.uwe-sieber.de/dosfon_e.html.  Very cool for GVim and console
windows!

VimTip 485: Open a new window and read in the man page for the word under the cursor
http://vim.sourceforge.net/tip_view.php?tip_id=

This short function opens a new window and reads in the Unix man page for the word under the cursor.  To use it add the following to your ~/.vimrc file:

fun! ReadMan()
    " Assign current word under cursor to a script variable:
    let s:man_word = expand('<cword>')

    " Open a new window:
    :exe ":wincmd n"

    " Read in the manpage for man_word (col -b is for formatting):
    :exe ":r!man " . s:man_word . " | col -b"

    " Goto first line...
    :exe ":goto"

    " and delete it:
    :exe ":delete"
endfun

" Map the K key to the ReadMan function:
map K :call ReadMan()<CR>

cf:
:help windows
:help wincmd
etc

The col command may differ on your version of Unix, see col(1) for details.

VimTip 486: Search for word under cursor, but don't move.
http://vim.sourceforge.net/tip_view.php?tip_id=

This is very, very simple:

:noremap <F1> #*

I find this helpful when editing multiple files and I want to search for the word under the cursor in *another* file.
I then type F1, C-^, n.

VimTip 487: jump to a file to a certain line number
http://vim.sourceforge.net/tip_view.php?tip_id=

Dear VIMMERS:

It is useful to have cn, cl for locating errors. however, when the compilation was done off-line,
gcc  ... >& compile.log
how to use the compile.log to locate the errors? for example,
     vim.h:1506
if i use "gf" when the cursor is over "vim.h", it just jumps to the begining of the file.
here may be one solution by combining several steps:
      nmap gt mAT f:l"aywbbgf:^Ra^M
"mA"   --- marks the current position to global register A so that i can return the log file by 'A
"T "     --- goes to the begining of the tag, so in any characters of "vim.h:1506", it first places the cursor to "v".
"f:"      --- goes to the ":" separator
"l"       --- goes to the starting of line number
"ayw   --- try to use register a to remember the line number
"bb"    --- move cursor back to the filename
"gf"     --- now jump to the file
":^Ra^M"
          --- jump to the line number remembered in register a


nmap gt ... place the above steps into key combinations "g" "t" so next time use "gt" instead of "gf" on the error tag!

VimTip 488: vimrc setting for wider vim diff window (gVim)
http://vim.sourceforge.net/tip_view.php?tip_id=

The Vim diff feature (fantastic as it is) opens with the default window width (gVim), and the two files each get a half width buffer windows with a vertical split between them.  When you resize, only one buffer window changes.  We might write function to automatically center the split and possibly trigger it automatically with an autocmd (advanced).  However, we can still have Vim open with a wider window when performing a diff.  The following code can be added to the vimrc file.  Be sure to adjust the numbers for the available screen real-estate and the other settings to taste.

"===============================================================
" Window settings
set lines=60           " Set window height
set columns=98         " Set window width 'co'
set guioptions+=b      " Add bottom scroll bar 'go'

" If comparing files side-by-side, then ...
if &diff
    " double the width up to a reasonable maximum
    let &columns = ((&columns*2 > 172)? 172: &columns*2)
endif
"===============================================================

Remember, the default for the columns setting is either 80 or the terminal width.  I wouldn't expect consistant results for non-gVim usage.  By the way, I still need to add a test to detect vim vs. gVim in my own vimrc (perhaps greping $VIM for gvim) so that I can adjust colors and other settings accordingly.  Note that the expression in the let statement can be replaced with a constant.  But, that expression may prove usefull if the columns setting is to vary (e.g. a filetype plugin).  For a general function (intermediate), someone would want to come up with some global names like MaxScreenColumns or MaxBufferColumns.

VimTip 489: Section jump in Latex
http://vim.sourceforge.net/tip_view.php?tip_id=

This is a small mapping that can be used for jumping sections in a latex file (just like ]m and [m for Java methods)

map <silent> ]s :/\\\(sub\)\{,2}section\s*{<CR> :noh<CR>
map <silent> [s :?\\\(sub\)\{,2}section\s*{<CR> :noh<CR>

I want to extend it to recognize something like 2]s to move two sections forward. How to do it.

Aditya

VimTip 490: Paste vim registers in search or colon command-line instead of using the system clipboard
http://vim.sourceforge.net/tip_view.php?tip_id=

To paste something into a search or the colon command-line without using the system clipboard, press Ctrl-R" (including the quote, which represents the unnamed register), or replace the quote with another register. For more information about registers, see ":help resisters".

VimTip 491: can anyone tell me how to get rid of the F1 mapping ?
http://vim.sourceforge.net/tip_view.php?tip_id=

owkay

i have been googeling for 2 hours now

and i cant find how to remove that really anoying <F1> map

i keep hitting it as i go for esc, and its really starting to piss me off ^^;

can anyone tell me how to get rid of the F1 mapping ?

VimTip 492: jump to file from :CVSDiff output
http://vim.sourceforge.net/tip_view.php?tip_id=

I use :CVSDiff from cvscommand.vim quite often to get an overview of the changes i made to a file.
I always want to jump from the diff to the corresponding line in the original file.
So I wrote a small script that does that, and put it in $VIM/after/syntax/diff.vim
Pressing <Return> will execute that script.

function! DiffJumpToFile()
  let a=line(".")                                " current line number
  let b=search("^\\(---\\|\\*\\*\\*\\) ", "b")   " search for line like *** 478,489 ***
  let c=getline(b)                               " get this line as string
  let d=strpart(c, 4, match(c, ",")-4)           " get the first line number (478) from that string

  let f=search("^\\(---\\|\\*\\*\\*\\) .*\\t", "b") " search for line like *** fileincvs.c  ....
  let g=getline(f)                                  " get this line as string
  let h=match (g, "\\t", 4)                         " look for end of filename (terminated by tab) in string
  let i=strpart(g, 4, h-4)                          " get the filename

  execute ":b " . i                                 | " change to that file
  execute "normal " . (d+a-b-1) . "G"               | " go to right line number
endfunction

nmap <buffer> <Return> :call DiffJumpToFile()<CR>

I didn't put that script in the script section because it doesn't have any error checking at all.

VimTip 493: Open the directory for the current file in Windows
http://vim.sourceforge.net/tip_view.php?tip_id=

It's often handy to open the folder that corresponds to a file I'm editing (as much as I hate to leave Vim!) I've added this mapping:
   map <C-e>  :silent !explorer %:p:h:gs?\/?\\\\\\?<CR>

So that typing ctrl-e in any buffer opens the folder that the file lives in in Windows.

See :help filename-modifiers for more.

VimTip 494: maximize or restore window
http://vim.sourceforge.net/tip_view.php?tip_id=

I used to define 2 different mapping for maximize and restore window. But I wanted a map that can toggle between them. So, I came up with this function. This function assumes you are using win32 version of gvim. If you are using different version, then substitute :simlat ~[rx] by the key combination for your window manager.

Add following lines on your [._]g*vimrc

let w:windowmaximized = 0

function! MaxRestoreWindow()
	if w:windowmaximized == 1
		let w:windowmaximized = 0
		" restore the window
		:simalt ~r
	else
		let w:windowmaximized = 1
		" maximize the window
		:simalt ~x
	endif
endfunction

map <F5> :call MaxRestoreWindow()<CR>

VimTip 495: Backspace key using puTTY to RH9 box
http://vim.sourceforge.net/tip_view.php?tip_id=

I connect to a RedHat9 server via the free software "puTTY" from a Windows computer.  On the shell (tcsh), the <Backspace> was working as it should, but in VIM it was not.  No matter what I did in the .vimrc file, it always acted like a <Delete> key.  Very annoying.

I've discovered that one must use the keyboard setting of "linux" in the puTTY settings in order for the <Backspace> key to work properly in VIM.  The "linux" keyboard is not the default.  If one does not do this, VIM always is sent the <Delete> key command when pressing on the <Backspace>.

VimTip 496: This is the hyperlinked html format of the Vim Reference Manual.
http://vim.sourceforge.net/tip_view.php?tip_id=

DESCRIPTION
----------

   	This is the hyperlinked html format of the Vim Reference Manual.
Vim is much more than just a text editor; it's a cross-platform working
environment, but quite counter-intuitive to use. A Greek translation
of the Vim Tutor and Menu is on the drawing board at LynxX.org.

   	If you have a Web browser, the official hypertext version is
currently at <http://www.vim.org/>. This unofficial version looks much
nicer than the official hypertext versions that exist at vim.org or can
readily be converted to html from the RefMan documents, but is an exact
copy of the source docs.

	You can downloaded it from here:

	-- FTP <ftp://lynxx.org/misc/download>
	-- HTTP <http://lynxx.org/misc/download>

DISCLAIMER
----------

   	This document is freely redistributable, but I take no liability
for the correctness and safety of any procedures or advice given here.
This document is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY, explicit or implied for the MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.

BUGS
----
If you find any mistakes or dead links, please contact:

<vangelise@lynxx.org>

Vangelis Eustratius

VimTip 497: Replacing a string with default buffer contents
http://vim.sourceforge.net/tip_view.php?tip_id=

It's common to replace a given string in a file with something that appears elsewhere in the file. Often I don't think to put the replacement string in a named register, so it's hard to delete the text I'm replacing without replacing what's in the default (@") copy register -- :let is too cumbersome for this. (BTW, is there a way to issue a command like 'd' or 'c' *without* replacing what's in @"?)

Anyway, I've been using this map
 vmap R :<BACKSPACE><BACKSPACE><BACKSPACE><BACKSPACE><BACKSPACE>:let @9=@"<CR>gvx"9P

which replaces what's highlighted in visual mode the contents of ""

It's ugly though (all the backspaces are necessary to delete the default  :'<,'> that shows up when you start a command in visual mode.)

I find this useful enough that I use it, but what I really want is something similar where I could type say
  R3w
(where R is remapped to my special command) that replaces the next three words the contents of @"

VimTip 498: Completation using the syntax file
http://vim.sourceforge.net/tip_view.php?tip_id=

To use the vim completion you can use a dictionary.
:set  complete=k

As a dictionary you can use a syntax file (which are in the /syntax/ directory), so you can complete
the reserved words.

Inserting in your .vimrc a line like that

autocmd Syntax * exec('set dict=/usr/share/vim/syntax/' .expand('<amatch>') .'.vim')

you can avoid to select the dictionary for each filetype.
(Don't forget to use your correct syntax directory for this).

To get more info:

:help autocmd
:help complete

VimTip 499: View character class
http://vim.sourceforge.net/tip_view.php?tip_id=

This one shows the definition of a predefined character class. ([:alpha:], [:graph:] etc.) The cursor is assumed to point to the name of the character class one wants to examine. Press "cc" ...

fun! s:Show()
  norm! viwy
  echo 'class [:' . @" . ':]' . "\n"
  let pat = '[[:' . @" . ':]]'
  let i = 0
  while i < 256
    let ch = nr2char(i)
    if ch =~ pat | echon ch . '(' . i . ')' . "\t" | endif
    let i = i + 1
  endwhile
endfun

nn cc :call <SID>Show()<Cr>

VimTip 500: View character class
http://vim.sourceforge.net/tip_view.php?tip_id=

This one shows the definition of a predefined character class. ([:alpha:], [:graph:] etc.) The cursor is assumed to point to the name of the character class one wants to examine. Press "cc" ...

fun! s:Show()
  norm! viwy
  echo 'class [:' . @" . ':]' . "\n"
  let pat = '[[:' . @" . ':]]'
  let i = 0
  while i < 256
    let ch = nr2char(i)
    if ch =~ pat | echon ch . '(' . i . ')' . "\t" | endif
    let i = i + 1
  endwhile
endfun

nn cc :call <SID>Show()<Cr>

VimTip 501: View character class
http://vim.sourceforge.net/tip_view.php?tip_id=

This one shows the definition of a predefined character class. ([:alpha:], [:graph:] etc.) The cursor is assumed to point to the name of the character class one wants to examine. Press "cc" ...

fun! s:Show()
  norm! viwy
  echo 'class [:' . @" . ':]' . "\n"
  let pat = '[[:' . @" . ':]]'
  let i = 0
  while i < 256
    let ch = nr2char(i)
    if ch =~ pat | echon ch . '(' . i . ')' . "\t" | endif
    let i = i + 1
  endwhile
endfun

nn cc :call <SID>Show()<Cr>

VimTip 502: View character class
http://vim.sourceforge.net/tip_view.php?tip_id=

This one shows the definition of a predefined character class. ([:alpha:], [:graph:] etc.) The cursor is assumed to point to the name of the character class one wants to examine. Press "cc" ...

fun! s:Show()
  norm! viwy
  echo 'class [:' . @" . ':]' . "\n"
  let pat = '[[:' . @" . ':]]'
  let i = 0
  while i < 256
    let ch = nr2char(i)
    if ch =~ pat | echon ch . '(' . i . ')' . "\t" | endif
    let i = i + 1
  endwhile
endfun

nn cc :call <SID>Show()<Cr>

VimTip 503: PuTTY numeric keypad mappings
http://vim.sourceforge.net/tip_view.php?tip_id=

Purpose: Add support for {rhs} of keyboard numeric keypad while in vim insert mode and using PuTTY as a SSH terminal connection.

What to do: Add these mappings to your _vimrc or _gvimrc.  PuTTY's default terminal type is xterm.  Check your settings or just echo $TERM at the command prompt on most unix systems to verify xterm type.

Code to add to _vimrc:
:imap ^[Oq 1
:imap ^[Or 2
:imap ^[Os 3
:imap ^[Ot 4
:imap ^[Ou 5
:imap ^[Ov 6
:imap ^[Ow 7
:imap ^[Ox 8
:imap ^[Oy 9
:imap ^[Op 0
:imap ^[On .
:imap ^[OQ /
:imap ^[OR *
:imap ^[Ol +
:imap ^[OS -

Any questions about vim and PuTTY please send to mmetzger@mv-research.com.

Michael Metzger

VimTip 505: email from vim!
http://vim.sourceforge.net/tip_view.php?tip_id=

I always found myself typing <ESC> into my email editor and wishing that it had the nice features of Vim. There are a bunch of hacky ways to email from Vim, but there's actually an elegant solution: Pine!

The University of Washington has turned what was once a lame console program into a sopohisticated IMAP email client with server-based address books and configuration files. Among its many options is one that allows you to use your favorite text editor to edit emails. There's even a very good port for Windows called PC-Pine. Here's the link:
 http://www.washington.edu/pine/

VimTip 506: Open windows Help files (chm) using <CWORD> or selected area
http://vim.sourceforge.net/tip_view.php?tip_id=

If you want to open a CHM (HTML Help) file and force the index to go to a specific entry you can do the following (on WinXP or any windows platform that has keyhh.exe).

" Create mappings to launch the ASA9 Help file with context
nnoremap <C-F1> :silent!!cmd.exe /cstart keyhh.exe -\#klink "<C-R><C-W>" "$ASANY9\docs\dbmaen9.chm"<CR><CR>

vnoremap <C-F1> :<C-U>let old_reg=@"<cr>gvy:silent!!cmd.exe /cstart keyhh.exe -\#klink "<C-R><C-R>"" "$ASANY9\docs\dbmaen9.chm"<CR><CR>:let @"=old_reg<cr>:echo ""<CR>

Each of these are on one line.

nnoremap opens the help file using the <CWORD> that the cursor is on.

vnoremap allows you to visually select a block of text and open the search window with that text.  It also restores what ever was previously visually selected after the launch.

If you use the map repeatedly, the same HTML Help window will be used.

VimTip 507: Quick window resizing
http://vim.sourceforge.net/tip_view.php?tip_id=

These key mappings (placed in your _vimrc) let you use the F8 and F9 keys to make a window wider or taller.  The shift key reverses the effect, and the Ctrl and Alt modifiers go to a choice of standard settings. Mappings to change the font size.(which work slightly differently) are also included. Obviously you can change F8 and F9 to keys of your choice.

" Window size appearance
augroup guiappearance
	au!
        set guifont=Andale_Mono:h12
	:map <F7> :set guifont=Andale_Mono:h12<CR>
	:map <S-F7> :set guifont=Andale_Mono:h10<CR>
	:map <C-F7> :set guifont=Andale_Mono:h14<CR>
	:map <F9> :set lines+=5<CR>
	:map <S-F9> :set lines-=5<CR>
	:map <C-F9> :set lines=60<CR>
	:map <M-F9> :set lines=30<CR>
	:map <F8> :set columns+=10<CR>
	:map <S-F8> :set columns-=10<CR>
	:map <C-F8> :set columns=132<CR>
	:map <M-F8> :set columns=80<CR>
augroup END

VimTip 509: Commands that don't clobber the search register
http://vim.sourceforge.net/tip_view.php?tip_id=

I frequently execute commands (mappings, usually) that perform operations that change the value of the search register for the sake of the mapping.  They might do a :s or some such that affects the search register.  I don't always want this side effect, so I use the following command/function:

" Executes a command  (across a given range) and restores  the search register
" when done.
function! SafeSearchCommand(line1, line2, theCommand)
  let search = @/

  execute a:line1 . "," . a:line2 . a:theCommand

  let @/ = search
endfunction
com! -range -nargs=+ SS call SafeSearchCommand(<line1>, <line2>, <q-args>)

" A nicer version of :s that doesn't clobber the search register
com! -range -nargs=* S call SafeSearchCommand(<line1>, <line2>, 's' . <q-args>)

Basically, :SS followed by any command will execute that command (to simulate keystrokes, use :normal as the command) and restore the search register when it's done.  :S is a replacement for :s which works EXACTLY the same way (without or without range, flags etc. etc.) but doesn't clobber the search register in the process.

VimTip 510: one way to set $VIMRUNTIME within vimrc
http://vim.sourceforge.net/tip_view.php?tip_id=

In general, $VIMRUNTIME cannot be set within vimrc.
(:set helpfile is not so useful)
Bram prefers to let vim figures it out.

This tip is for those who want to avoid setting $VIMRUNTIME as an enviromental variable
(either rc file on UNIX or enviroment on Windows).

I found the following steps worked on my PC and unix:

  1. find out your $VIM
     (On Windows, it is the directory where gvim.exe lives)


  2. create a directory called doc under $VIM
     (now, we have $VIM/doc)


  3. copy help.txt from official $VIMRUNTIME/doc
     (now, we have $VIM/doc/help.txt)

Now, we can set $VIMRUNTIME within vimrc, for example

   let $VIMRUNTIME='C:/usr/share/vim/vim62'

I find it is useful on PC especially when I have cygwin
installed, thus a single copy of VIMRUNTIME can be shared for
both vi (cygwin version) and gvim.exe (win32 version).

VimTip 511: key mapping for goto the absolute line number
http://vim.sourceforge.net/tip_view.php?tip_id=

It's quite simple,
nmap <ENTER><ENTER> G
Now, you can keep the original [count]<ENTER> function and have an easier way to goto the abolute line number.
Have a nice day!

VimTip 512: Automatic insertion of C/C++ header gates
http://vim.sourceforge.net/tip_view.php?tip_id=

C/C++ header files should be guarded against multiple inclusions using preprocessor directives, e.g.:

#ifndef FOO_H
#define FOO_H

/* Declarations. */

#endif

Placing the following snippet in your .vimrc file makes vim insert these preprocessor gates automatically:

function! s:insert_gates()
	let gatename = substitute(toupper(expand("%:t")), "\\.", "_", "g")
	execute "normal i#ifndef " . gatename
	execute "normal o#define " . gatename . "   "
	execute "normal Go#endif /* " . gatename . " */"
	normal kk
endfunction

autocmd  BufNewFile *.{h,hpp} call <SID>insert_gates()

VimTip 513: Automatic insertion of C/C++ header gates
http://vim.sourceforge.net/tip_view.php?tip_id=

C/C++ header files should be guarded against multiple inclusions using preprocessor directives, e.g.:

#ifndef FOO_H
#define FOO_H

/* Declarations. */

#endif

Placing the following snippet in your .vimrc file, makes vim insert these preprocessor gates automatically, when a new header file is created:

function! s:insert_gates()
	let gatename = substitute(toupper(expand("%:t")), "\\.", "_", "g")
	execute "normal i#ifndef " . gatename
	execute "normal o#define " . gatename . "   "
	execute "normal Go#endif /* " . gatename . " */"
	normal kk
endfunction

autocmd  BufNewFile *.{h,hpp} call <SID>insert_gates()

VimTip 514: Automatic insertion of C/C++ header gates
http://vim.sourceforge.net/tip_view.php?tip_id=

C/C++ header files should be guarded against multiple inclusions using preprocessor directives, e.g.:

#ifndef FOO_H
#define FOO_H

/* Declarations. */

#endif

Placing the following snippet in your .vimrc file, makes vim insert these preprocessor gates automatically, when a new header file is created:

function! s:insert_gates()
        let gatename = substitute(toupper(expand("%:t")), "\\.", "_", "g")
        execute "normal i#ifndef " . gatename
        execute "normal o#define " . gatename . "   "
        execute "normal Go#endif /* " . gatename . " */"
        normal kk
endfunction

autocmd  BufNewFile *.{h,hpp} call <SID>insert_gates()

VimTip 515: see filenames of all scripts that vim loaded or tried to load
http://vim.sourceforge.net/tip_view.php?tip_id=

To see filenames of all scripts that vim loaded, including
those loaded implicitly at startup:

    :scriptnames

This does not show names of 'would-be scripts' -- that is,
scripts that vim tried to open, did not find and was
silent about it.

To see the 'would-be' scripts -- that is, scripts that vim
tried to open, did not find and was silent about it -- add
'-V' option when starting vim:

    vim -V

Also:
    vim --version  # shows system-dependent location of rc-files
                   # but does not show location of system/personal
                   # plugins
   :help startup

VimTip 516: find two words in either order
http://vim.sourceforge.net/tip_view.php?tip_id=

The shortest regular expression to find two words
in either order (on the same line):

.*alice\&.*bob

(Thanks to Piet Delport and Matthew Winn)

Other solutions:

\(alice.*bob\)\|\(bob.*alice\)     -- "old-style" regexp

^\(.*Alice\)\@=\(.*Bob\)\@=

Keywords: find, match, search, words in either order,
          regular expression

VimTip 517: Rejustification of *roff style markup.
http://vim.sourceforge.net/tip_view.php?tip_id=

Normally, I bind F4 to gqap, which suffices nicely to rejustify plain text, and most of my latex and HTML stuff (with due care taken to have plenty of blank lines for delimiting.

However, if you're dealing with *roff style markup, such as man-pages or (in my case) documents using the -ms groff macros, it won't work, as the tags
are on the line just above, such as the following example.

<begin example>
.IP Boggart
Magical being that transforms into whatever the viewer most fairs.
Proffessor Lupin used a boggart to
teach Harry how to repel Dementors, as
(at that time) Harry most faired Dementors.

<end example>

Ideally, I'd just position the cursor on the body of the text (this a definition list entry, if anyone is wondering), and just press F4. But that would also rejustify the argument to the IP macro, which would be bad.

So instead of using gqap, I use gq an a selected range of lines. I search upwards something that might be a macro, or a blank line, move down a
line into the body, start to select, search forward for the next macro or
blank line, then gq to rejustify.

The regex I use to search for the extents is
\(^\.[A-Za-z]\{2\}\\|^$\)

Since the document I'm working with has an extension of .groff, I bind, on BufferEnter, the following macro.

au BufEnter *.groff nmap <F4> ?\(^\.[A-Za-z]\{2\}\\|^$\)<Enter>jV/\(^\.[A-Za-z]\{2\}\\|^$\)<Enter>kgq

And it works. I'm using vim 6.1.320, although I believe it should work on most versions.

VimTip 518: errorformat for icc7
http://vim.sourceforge.net/tip_view.php?tip_id=

This is a errorformat for Intel icc7 compiler:

errorformat=%E%f(%l): %m,%-C,%-C%p,%Z

VimTip 519: Folding like in Visual Basic .NET
http://vim.sourceforge.net/tip_view.php?tip_id=

If your are using Microsoft Visual Studio .NET for editing Visual Basic .NET files, the Window Form Designer Generated Code is folded by default. If you want to have the same nice feature when editing the same file in Vim, put this code in your _vimrc file so you can switch between the folded and unfolded mode:

function! NetFold()
   set foldmethod=syntax
   syn region myFold start="#Region" end="#End Region" transparent fold keepend extend
   syn sync fromstart
   set foldcolumn=2
endfunction

function! NetUnFold()
	set foldmethod=manual
	set foldcolumn=0
	norm zE
endfunction

So when your are editing a *.vb file, you simply have to call the function like this:

:call NetFold()
or
:call NetUnFold()

Also, if you want that little function to be called automatically when you edit a *.vb file, put these two lines in your _vimrc file:

autocmd BufNewFile,BufRead *.vb	setfiletype vb
autocmd BufNewFile,BufRead *.vb	call NetFold()

Hope this will help. If you have any other suggestion, don't be shy to add them!

VimTip 520: Searching for Identifiers
http://vim.sourceforge.net/tip_view.php?tip_id=

The problem:

It's always annoying trying to do a search and replace for identifiers in C when the identifier that you are searching for is a substring of other identifiers or keywords in the program.  For instance, let's say you want to search for every place you access the ubiquitous loop variable 'i'.  If you do a search, you'll hit all the i's in the "if" and "while" keywords and any other identifiers that contain the letter i.  For awhile I have been looking for some way to do this in vim.  Other IDE's that I have seen have a "whole word" option where the text must be the whole word.  Vim has the "]CTRL-I" command, but that is useless for search and replace because when you replace one instance, you won't have the original identifier under your cursor any more.  Until recently, I didn't know how to do it in vim without manually typing the whole regular expression for C identifiers.

The solution:

Use the "\<" and "\>" in your search.  Evidently, these respresent the start and end of words.  So, to search for all occurrences of the variable 'i', you would use the following command:

/\<i\>

If you want all identifiers that start with 'i', you use "/\<i" and similarly, for all identifiers ending in 'i', use "/i\>".

If anyone knows a better solution, I would love to know about it.

VimTip 521: Something in GVIM for fun
http://vim.sourceforge.net/tip_view.php?tip_id=

Try these for fun

Open gvim with some text in it and try
set rl
to come back to where u were try set norl

In Gvim
type ggvGg? --- This encrypts the whole of text

Happy vimiiiing !!!!

VimTip 522: Fix an autoindent error
http://vim.sourceforge.net/tip_view.php?tip_id=

When splitting a line in two, I sometimes insert a return before a space.  Unfortunately, this mangles the autoindentation: the last tab turns into spaces.  The following map fixes that problem:

"Fixes a rare autoindent error
inoremap <CR> <C-R>=ReturnWrapper()<CR>
function ReturnWrapper()
  if strpart(getline('.'), col('.') - 1) =~ '^\s*\S'
    return "\<ESC>wi\<CR>"
  else
    return "\<CR>"
  endif
endf

Thanks to vimtip #102 for the tip on using <c-r> with a wrapper function.

VimTip 523: Folding functions with the prototype included
http://vim.sourceforge.net/tip_view.php?tip_id=

I used to use folding to fold functions in C/C++ from the "{" to the "}", but I wanted a way to fold the prototype as well.  Using foldexpr allows this.

" ----------- CUT
function FoldBrace()
    if getline(v:lnum+1)[0] == '{'
        return '>1'
    endif
    if getline(v:lnum)[0] == '}'
        return '<1'
    endif
    return foldlevel(v:lnum-1)
endfunction

set foldexpr=FoldBrace()
set foldmethod=foldexpr
" ---------- END CUT

Note that this will only work if you put the braces on lines by themselves in the very first column, ie:
void func()
{
....
}

VimTip 524: evaluate expression in any mode, including normal mode, using <CTRL-R>=
http://vim.sourceforge.net/tip_view.php?tip_id=

The <CTRL-R>= things evaluates the expression. For example:
           <CTRL-R>=12+34<cr>
<CTRL-R>= works in insert mode and in command mode.I felt
it more convenient if <CTRL-R>= did the same thing
in normal mode too.

I have this in my .vimrc:

        map <CTRL-R>= :echo

Now <CTRL-R>=123*456<CR> evaluates expressions for me in
all 3 modes: normal mode, insert mode, and command mode.
In fact I found it much more convenient to do casual calculations
using <CTRl-R>= in normal mode than in any other mode.

Be warned: when typing <CTRL-R>= in normal mode, don't make
long pause before '='. <CTRL-R> alone means 'redo' in normal mode.
Vim is very smart, and figures the difference between single
<CTRL-R> (which is 'redo') and the mapped sequence <CTRL-R>= (which is
remapped). The 'timeoutlen' option controls this difference.
The default value of 'timeoutlen' option is very convenient.

This is expansion of vimtip #73 "using vim as calculator"

References: :he c_CTRL-R
             :he i_CTRL-R
             :he 'timeoutlen'
             :he 'ttimeoutlen'

Keywords: calculator, expression evaluation, normal mode

VimTip 525: JavaBeans helper function
http://vim.sourceforge.net/tip_view.php?tip_id=

This one helps creating beans. Nothing serious actually, but might come in handy. It's pretty fresh, cuz I just got annoyed with Netbeans - I haven't tested it fully. Perhaps we could create some bigger Java Struts thing, huh?

nnoremap <buffer> <silent>dc :call <SID>AddBean()<CR>
function! s:AddBean()
    let line = line('.')
    let name = inputdialog('Enter the name of the variable: ')
    let type = inputdialog('Enter the type of the variable: ')
    let upperName = substitute(name, '^\(\w\)\(.*\)$', '\u\1\2', '')
    call append(line, "\t}")
    call append(line, "\t\tthis.".name." = ".name.";")
    call append(line, "\tpublic void set".upperName."(".type." ".name.") {")
    call append(line, "")
    call append(line, "\t}")
    call append(line, "\t\treturn (this.".name.");")
    call append(line, "\tpublic ".type." get"."".upperName."() { ")
    call append(line, "")
    call append(line, "\tprivate ".type." ".name.";")
    call append(line, "\t//".name)
    return line
endfunction

VimTip 526: enhancing Benji Fisher's word_complete.vim script
http://vim.sourceforge.net/tip_view.php?tip_id=

I suggest you first look at the script itself:

	http://www.vim.org/scripts/script.php?script_id=73

Since the script has some problems (at least for me) when I paste text in X11 with the mouse, and since I need to switch to paste more anyway, I now use this in my .vimrc:

" the word_complete.vim plugin just *rocks*
autocmd VimEnter * call DoWordComplete()
fun! SetComplete()
    call DoWordComplete()
    set nopaste
    nunmap <F12>
    iunmap <F12>
    nmap <F12> :call UnsetComplete()<CR>
    imap <F12> <Esc>:call UnsetComplete()<CR>a
    echo
endfun
fun! UnsetComplete()
    call EndWordComplete()
    set paste
    nunmap <F12>
    iunmap <F12>
    nmap <F12> :call SetComplete()<CR>
    imap <F12> <Esc>:call SetComplete()<CR>a
    echo
endfun
nmap <F12> :call UnsetComplete()<CR>
imap <F12> <Esc>:call UnsetComplete()<CR>a

Issues:
 (i) I'm sure this can be done better
 (ii) in insert mode, F12 switches to paste mode, but not back again. In normal mode, it works. I'm sure this is going to be something really, really silly.

VimTip 527: vim (console/xterm) colors in gvim
http://vim.sourceforge.net/tip_view.php?tip_id=

You might have noticed that gvim uses slightly different colors compared to the console version.  If you like the console colors more than the gvim default colors (as I do), you can add the following to your .vimrc:

    set background=dark
    hi SpecialKey    guifg=Blue
    hi MoreMsg       guifg=Green
    hi Visual        guifg=NONE guibg=NONE
    hi Folded        ctermbg=4 guibg=Blue
    hi FoldColumn    ctermbg=7
    hi DiffAdd       guibg=Blue
    hi DiffChange    guibg=Magenta
    hi DiffDelete    guibg=Cyan
    hi Normal        guifg=Gray guibg=Black
    hi Cursor        guibg=White
    hi lCursor       guibg=White
    hi Comment       guifg=Cyan
    hi Constant      guifg=Magenta
    hi Special       guifg=Red
    hi Identifier    guifg=Cyan
    hi Statement     guifg=Yellow
    hi PreProc       guifg=Blue
    hi Type          guifg=Green
    hi Underlined    guifg=Blue
    hi Todo          guifg=Black

There's one little difference: Folded is changed to something better for console *and* gui and FoldColumn is left as is in gvim and changed for console vim to match the gvim version.

VimTip 528: Make search results appear in the middle of the screen.
http://vim.sourceforge.net/tip_view.php?tip_id=

Some useful mapping to make search results appear in the middle of the screen.

nmap n nmzz.`z
nmap N Nmzz.`z
nmap * *mzz.`z
nmap # #mzz.`z
nmap g* g*mzz.`z
nmap g# g#mzz.`z

VimTip 529: Making <s-tab> (shift-tab) work
http://vim.sourceforge.net/tip_view.php?tip_id=

Shift Tab <s-tab> is a useful key combination to be able to use.
I wanted to use it for tab completion: vimtip #102
Many people also use it for unindenting: vimtip #456
But shift tab seemed not to work on my system (slackware 8.1)
but I managed to find a solution, and a workaround.

Diagnosis:

Make sure you are getting something from the keypress.
Go into insert mode:
and press <control-v> then <tab>
You should get a tab.
and press <control-v> then <shift-tab>
You should get ^[[Z

If this happens, it is good, you can skip the next part of the diagnosis.

Diagnosis Part 2:

If you get nothing when you do <control-v> then <shift-tab> go to a command line prompt (#) and type:
# xmodmap -pke | grep 'Tab'

It should either show:
keycode  23 = Tab
or
keycode  23 = Tab ISO_Left_Tab

Now, which one is the 'right' one seems to depend on what terminal program you are using its various settings.
(I need to use the 'ISO_Left_Tab' one with 'xterm' but the 'Tab' one with Eterm)
I suggest you try changing to the mapping to the other one and test what you get from the keypresses again. If it doesn't work, you can just change it back.

To change the mapping:
# xmodmap -e 'keycode  23 = Tab ISO_Left_Tab'
or
# xmodmap -e 'keycode  23 = Tab'

If changing the xmodmap setting worked, you'll probably need to put it somewhere where it will load on X startup or login.
(.xinitrc or .bashrc or somewhere else depending on your system config.)
If it didn't work see the other things to try below.

Interpreting shift-tab correctly:

Once you have the shift-tab key combo generating the correct string ^[[Z you just need to make sure that is then interpreted by vim as <s-tab>

As of version 6.2 vim does this, so upgrading to 6.2 would be good.
If you cannot upgrade for whatever reason try this workaround:

:map <esc>[Z <s-tab>
:ounmap <esc>[Z

This will map the key you get when you press shift tab to <s-tab> which
you can then use in other maps/scripts
I suggest adding these lines (minus the leading : of course) to your .vimrc

Other things to try:

If none of the above worked, here are some other things to investigate.

Make sure your window manager is not eating the keystrokes. - You don't have it mapped there to change desktop, or switch between windows
or something do you?
Use 'xev' to check that shift-tab is registering as a keypress and what it is returning.

Good Luck.

VimTip 530: How do I get the name of the current file
http://vim.sourceforge.net/tip_view.php?tip_id=

To get the name of the file you are currently editing use:

@%

If you want to make sure of the path as well use:

expand("%:p")

see also:

help @
help expand

vimtip #296 for why it might be a useful thing to do.

VimTip 531: 1-2-3, let's make gvim.exe for free
http://vim.sourceforge.net/tip_view.php?tip_id=

This tip is for those who is interested to make gvim.exe on
Windows without using MSVC or BCC. The condition is that cygwin
is installed. (Another tip for Windows users: cygwin makes
Windows really useful!)

Following is three steps (under any shell and any directory)
step 1:
cvs -z3 -d:pserver:anonymous@cvs.vim.sf.net:/cvsroot/vim co vim
step 2:
cd vim/src
step 3:
make -f Make_cyg.mak IME=yes

I have tested under Windows 2000 and have used my own gvim.exe
for months without any problem.

Special thanks to Dan Sharp to develop/debug Make_cyg.mak, which
make it possible.

VimTip 532: usefule keymaps -- for comment out,etc..
http://vim.sourceforge.net/tip_view.php?tip_id=

-->a key map for commenting out lines -- use f12 key
append this line into your .vimrc/.gvim rc file
map <F12> ^i#<Esc>j
-->key maps to avoid a long shift press
nmap  :X        :x
nmap  :W        :w
nmap  :Q        :q

VimTip 533: Page 1 of 123 in header of :hardcopy
http://vim.sourceforge.net/tip_view.php?tip_id=

To get this to work you have to know how many lines per page :hardcopy
is normally making. Open empty document and in Normal mode "100o". Then
make ":%s/^/\=line('.')". Now ":hardcopy > nu.ps". Open nu.ps in
PostScript viewer. You will see how many lines per page Vim is printing.

In my case this is 73.
Now set 'printheader' option:

:set printheader=%<%f%h%m%=Page\ %N\ of\ %{line('$')/73+1}

Explanations of % items in option are here |'statusline'|.
line('$') - number of lines in buffer
73 - number of lines per page
+1 - Vim don't know floating point math and everything rounds down.

VimTip 534: for verilog users only
http://vim.sourceforge.net/tip_view.php?tip_id=

for all verilog users dealing with netlists,this an easier way to find out in which module you are really working in.add this map to your .vimrc/.gvimrc file.use `(tick) key to find out in which module u are actually residing in.

map ` ma?module<CR>Wyiw'a:echo "module -->" @0<CR>

note:
this map works only when u are whithin the module.placing it on module/endmodule does not make any sense.

VimTip 535: Working with only one term/console?
http://vim.sourceforge.net/tip_view.php?tip_id=

Sometimes you can only work with a single terminal/console, or you hate having
too many windows open and need to switch between them, or QuickFix does not
work on your favourite languages? This simple, yet powerful key stroke (Ctrl-Z)
might be very useful to you.

For example, let's say you are composing an email using vim on mutt, or you want
to compile your <insert your favourite language> file, you can simply press Ctrl-Z,
gives you the prompt back, do multiple commands and whatever you want, and
goes back to vim editing by typing "fg" again.

If you need to admin some machine that only have vi instead of vim on some reason,
you can edit multiple files by suspend them, using "jobs" to list them and "fg %n" (n
is the job number) to load them back.

So by using the simple Ctrl-Z, not only that you can edit multiple files in the same vim,
you can edit multiple groups of files in different vim.

Although it is a shell feature, but it goes together nicely with vim.

Just in case for people that do not know, if all you want is to run a single external
command, use ":!cmd", or "!<motion><filter>" to filter <motion> text throught the
command.

For example, if you have a line "1 + 1 * 2", position cursor on it, and type "!}bc",
you got "3" for you answer back.

Or another example, position your cursor at the first line of your paragraph and
type "!}fmt", now the paragraph is nicely formatted.

With all these in hand, you don't need to waste key strokes to switch between
different windows anymore, the only drawback is it only works in *nix.

VimTip 536: Automaticly quit Vim if quickfix window (buffer) is the last
http://vim.sourceforge.net/tip_view.php?tip_id=

I was confused when I do some development job. Usually I have open one window with source code and one with error codes (command :copen). When I quit the source code quickfix window stay open. I'm lazy man so I must close this window with additional typing. I make simple autocmd which this difficult work in my stead.

If you like it (or are lazy too) include this code in your .vimrc and use your spared time somewhere else :-).

au BufEnter * call MyLastWindow()

function! MyLastWindow()
    " if the window is quickfix go on
    if &buftype=="quickfix"
        " if this window is last on screen quit without warning
        if winbufnr(2) == -1
            quit!
        endif
    endif
endfunction

VimTip 537: mimicking the shift-arrows (mark block) in terminals that don't understand shift-arrow (e.g. putty)
http://vim.sourceforge.net/tip_view.php?tip_id=

I like the MS-windows default behavior (ctrl-c for copy, ctrl-v for paste, etc) even when I'm running vimon a unix terminal. However, using mswin doesn't give the right "mark block" behavior in the terminal I use (putty). This may hold true for other Xterm emulators: the shift-arrows (mark block) don't work because shift-arrow sends exactly the same signal as just arrows. I have some maps that fix this by assinging some imaps and vmaps to the combination of ctrl-arrows (thanks to Antoine J. Mechelynck)

" make arrow keys work in visual mode
vmap <ESC>OA k
vmap <ESC>OB j
vmap <ESC>OC l
vmap <ESC>OD h
" simulate shift-arrows (select block in windows) with control-arrows
inoremap <ESC>[A <C-O>vk
vnoremap <ESC>[A k
inoremap <ESC>[B <C-O>vj
vnoremap <ESC>[B j
inoremap <ESC>[C <C-O>vl
vnoremap <ESC>[C l
inoremap <ESC>[D <C-O>vh
vnoremap <ESC>[D h

VimTip 538: e-mail archive
http://vim.sourceforge.net/tip_view.php?tip_id=

This is a small archive of all the email sent to the Vim mailing list (vim_at_vim.org). This archive covers 2-1/2 years, they are gzipped text files that contain six months each. http://www.theswamp.org/vim/

VimTip 539: Quick access to vim tips and scripts with konqueror / kde
http://vim.sourceforge.net/tip_view.php?tip_id=

For those of you using KDE and Konqueror to browse the vim.sf.net, you can add it to the so called "Web Shortcuts" in konqueror:

1. In Konqueror choose "Settings/Configure Konqueror"
2. Goto "Web Shortcuts", choose "Add..."
3. Now configure the shortcut:
 * Search Name Provider: "VIM Tips"
 * Search URI: "http://vim.sourceforge.net/tips/tip.php?tip_id=\{@}"
 * URI shortcuts: "vt,vimt,vimtip"
4. Click OK and Apply the changes to Konqueror

You can now use: "vt:4" in Konqueror's location bar to jump directly to Vim Tip #4.
Feel free to do the same for VIM scripts using "http://vim.sourceforge.net/scripts/script.php?script_id=\{@}" as the Search URI.

VimTip 541: How to get help using VIM
http://vim.sourceforge.net/tip_view.php?tip_id=

If you need help with vim and do not know where to go. Check out the Community link on the left. Or click this link
http://vim.sourceforge.net/community.php

VimTip 542: Edit remote files locally via SCP/RCP/FTP
http://vim.sourceforge.net/tip_view.php?tip_id=

I'm frequently editing files remotely, but if the network traffic is tight, then a normal VIM session turns into a tortuous event. The solution to that was right under my nose: VIM's Network-Oriented File Transfers (:help netrw).

Instead of editing the file remotely, it can be transfered from the host server, to a local copy, edited and then sent back when done. I know that you can do this manually, but it's a hassle, besides, if it can be done automatically, why not go for that? :)

Assuming you have the following installed and properly configured:

1. VIM
2. netrw.vim (afaik comes in all recent vim installs)
3. scp, rcp, ftp or ftp+

Then to use, all you need to go is specify the protocol, user, host and path to the file you want to edit:

vim scp://konimi@vim.org//var/www/html/rtc_functions.php
gvim scp://konimi@vim.org//var/www/html/tips/add_tip.php

Every time you write the file (:w etc.) the file will get copied over to the source and you will be brought back to your session for further editing.

If you already have an open session, then just issue the following commands:

To read/load up a file: :Nread scp://konimi@vim.org//var/www/html/rtc_functions.php
To write the file back: :Nwrite scp://konimi@vim.org//var/www/html/rtc_functions.php

That's it! You'll be editing at local speed.

VimTip 543: vim.po - Internationalizing the Vim editor
http://vim.sourceforge.net/tip_view.php?tip_id=

vim.po	- Internationalizing the Vim editor
+++++++++++++++++++++++++++++++++++++++++++

	For a given vim-###-src#.tar.gz release there is only one
	vim.po file that can be created for translation purposes.
	However, this vim.po is not unique since several options may
	be set while extracting with `xgettext', depending mostly on
	the format of comments.  For your convenience you can download
	a standard vim.pot to use as a translation template for
	vim-6.1 to most any language(s):

		http://lynxx.org/misc/download/vim-6.1-pot.tgz

	This is the general template for translating messages in Vim 6.1
	using the Xgettext format. It contains all English messages in
	the (untranslated) form:

		msgid "ABC" 		- English text
		msgstr "" 		- canditate language


	To translate Vim 6.1 messages, proceed line-by-line, taking
	care not to translate commands and options specific to the
	editor. See the  GNU `gettext' man-page for more info and
	details on this.


	This vim.pot should be used only with v. 6.1 to translate to
	any language.


	When Vim versions advance, a standard vim.po must be created
	from the newer sources, as delineated in the next VimTip "Vim
	goes INTL - Translating Vim Editor Messages, Menus, and
	Encodings' (VimTip#).

	You may also want to download a complete set in Greek to use as
	an example of full support for a specific language:

		http://lynxx.org/misc/download/vim-6.1-menu_el.zip
		http://lynxx.org/misc/download/vim-6.1-menu_el.tgz

	Happy Intl-ing!

Vangelis Eustratius
vangelise@lynxx.org

VimTip 544: Vim goes Greek - Greek language support for Vim 6.1
http://vim.sourceforge.net/tip_view.php?tip_id=

Vim goes Greek - Complete set of Greek language support for Vim 6.1
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

ENGLISH TEXT
------------

	This is the full set of messages, menus and encodings to
	be used to support Greek language. This set contains:

	vim.pot				-- dummy portable
						object template for
						vim-6.1 (can be used
						with any language)
	vim.po				-- the above vim.pot
						file with strings
						translated in Greek
	lang/el/LC_MESSAGES/vim.mo	-- the Greek vim.po
						file formatted in
						machine object mode
						(vim.mo)
	lang/menu_gr_gr.greek.vim	-- Greek used as
						the default encoding
	lang/menu_gr_gr.latin1.vimq	-- Greek for Latin
	lang/menu_gr_gr.iso_8859-1.vim	-- Latin-based ISO
						encoding sourceing
						from iso_8859-7 spec
	lang/menu_gr_gr.iso_8859-7.vim	-- Greek-Latin-based
						ISO encoding
	lang/menu_greece_greek.737.vim	-- MS-DOS/wINDOWS codepage
						for Greek (737)
	lang/menu_greek_greece.1253.vim	-- MS-DOS/wINDOWS codepage
						for Greek (1253)
	lang/menu_greek_greece.cp437.vim-- Unix CodePage for Greek
						(nl_cp437)
	lang/menu_gr_gr.utf-8.vim 	-- UTF-8 for Greek
	tutor/tutor.gr			-- Vim TUTOR in Greek
	README.TXT 			-- this file

	These compressed archives can be downloaded from:

		http://lynxx.org/misc/download/vim-6.1-menu_el.zip
		http://lynxx.org/misc/download/vim-6.1-menu_el.tgz

	To use Vim to edit in Greek (or any) language, we first enable
	the language option for the keyboard (Control
	Panel|Keyboard|Languages|Greek) and enable a key sequence
	(e.g. Ctrl-Shift) to toggle between the default language and
	Greek. In Vim the Greek language is displayed correcty.

	Finally, we unzip vim-6.1-menu_el to the vim61 directory. This
	ensures that the above files are place in the correct path. If
	you don't know how to extract to $VIMRUNTIME, unzip to any
	temporary folder. Then drag&drop or copy-and-paste each of the
	above files to its place after creating the container folders
	(/path/to/vim61/lang/el).
	This is what one may call manual extraction, so please wash your
	hands beforehand.

	For help on setting up Vim to support Greek -- from Vim do:

		:help language
		:help messages
		:help encoding

	For messages you'll have to set at least:

	let $LANG='el'		/	let $LANG='gr'
	:lan mes el		/	:lan mes gr

	For menus:

	:menut	English	Greek 	/	let menut=Greek

	from the cmdline or in the _vimrc file.

	For more information see VimTip #    "Vim goes INTL -
	Translating Vim Editor Messages, Menus, Encodings".

	The present document was posted as VimTip # and can be viewed
	online at:

		http://www.vim.org/tips/tip.php?tip_id=

	Enjoy Vim a la Greek!

GREEK TEXT
----------

Vim &#963;&#964;&#945; &#917;&#955;&#955;&#951;&#957;&#953;&#954;&#940; - &#928;&#955;&#942;&#961;&#949;&#962; &#963;&#949;&#964; &#965;&#960;&#959;&#963;&#964;&#942;&#961;&#953;&#958;&#951;&#962; &#949;&#955;&#955;&#951;&#957;&#953;&#954;&#974;&#957; &#947;&#953;&#945; &#964;&#959; Vim 6.1
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

	&#913;&#965;&#964;&#972; &#949;&#943;&#957;&#945;&#953; &#964;&#959; &#960;&#955;&#942;&#961;&#949;&#962; &#963;&#949;&#964; &#956;&#965;&#957;&#951;&#956;&#940;&#964;&#969;&#957;, &#956;&#949;&#957;&#959;&#973; &#954;&#945;&#953; &#954;&#969;&#948;&#953;&#954;&#959;&#960;&#959;&#943;&#951;&#963;&#951;&#962;
	&#947;&#953;&#945; &#967;&#961;&#942;&#963;&#951; &#963;&#949; &#965;&#960;&#959;&#963;&#964;&#942;&#961;&#953;&#958;&#951; &#964;&#951;&#962; &#949;&#955;&#955;&#951;&#957;&#953;&#954;&#942;&#962; &#947;&#955;&#974;&#963;&#963;&#945;&#962; &#956;&#949; &#964;&#959; Vim 6.1.

	&#928;&#949;&#961;&#953;&#949;&#967;&#972;&#956;&#949;&#957;&#945;:
	++++++++++++


	vim.pot				-- &#954;&#949;&#957;&#972; &#960;&#961;&#972;&#964;&#965;&#960;&#959; &#929;&#927;
						&#947;&#953;&#945; &#964;&#959; vim-6.1 (&#956;&#960;&#959;&#961;&#949;&#943;
						&#957;&#945; &#967;&#961;&#951;&#963;&#953;&#956;&#959;&#960;&#959;&#953;&#951;&#952;&#949;&#943;
						&#956;&#949; &#959;&#960;&#959;&#953;&#945;&#948;&#942;&#960;&#959;&#964;&#949; &#947;&#955;&#974;&#963;&#963;&#945;
	vim.po				-- &#964;&#959; &#960;&#945;&#961;&#945;&#960;&#940;&#957;&#969; &#945;&#961;&#967;&#949;&#943;&#959; vim.pot
						&#956;&#949; &#963;&#965;&#956;&#946;&#959;&#955;&#959;&#963;&#949;&#953;&#961;&#941;&#962;
						&#956;&#949;&#964;&#945;&#966;&#961;. &#963;&#964;&#945; &#949;&#955;&#955;&#951;&#957;&#953;&#954;&#945;
	lang/el/LC_MESSAGES/vim.mo   	-- &#964;&#959; &#949;&#955;&#955;&#951;&#957;&#953;&#954;&#972; &#945;&#961;&#967;&#949;&#943;&#959; vim.po
						&#956;&#959;&#961;&#966;&#959;&#960;&#959;&#953;&#951;&#956;&#941;&#957;&#959; &#963;&#949;
						&#954;&#945;&#964;&#940;&#963;&#964;&#945;&#963;&#951; &#924;&#927; (vim.mo)
	lang/menu_gr_gr.greek.vim	                -- Greek &#967;&#961;&#951;&#963;&#953;&#956;&#959;&#960;&#959;&#953;&#949;&#943;&#964;&#945;&#953; &#963;&#945;&#957;
						&#954;&#969;&#948;&#953;&#954;&#959;&#960;&#959;&#943;&#951;&#963;&#951; &#960;&#961;&#959;&#949;&#960;&#953;&#955;&#959;&#947;&#942;&#962;
	lang/menu_gr_gr.latin1.vimq	                -- &#917;&#955;&#955;&#951;&#957;&#953;&#954;&#940; &#947;&#953;&#945; Latin
	lang/menu_gr_gr.iso_8859-1.vim	                -- &#954;&#969;&#948;&#953;&#954;&#959;&#960;&#959;&#943;&#951;&#963;&#951; ISO &#956;&#949; &#946;&#940;&#963;&#951; &#964;&#951;
						&#923;&#945;&#964;&#953;&#957;&#953;&#954;&#942;, &#949;&#954;&#960;&#951;&#947;&#940;&#950;&#949;&#953; &#945;&#960;&#972;
						&#964;&#951; &#960;&#961;&#959;&#948;&#953;&#945;&#947;&#961;&#945;&#966;&#942; iso_8859-7
	lang/menu_gr_gr.iso_8859-7.vim	                -- &#954;&#969;&#948;&#953;&#954;&#959;&#960;&#959;&#943;&#951;&#963;&#951; ISO &#956;&#949; &#946;&#940;&#963;&#951;
						&#964;&#951; &#923;&#945;&#964;&#953;&#957;&#953;&#954;&#942;-&#917;&#955;&#955;&#951;&#957;&#953;&#954;&#942;
	lang/menu_greece_greek.737.vim	-- &#954;&#969;&#948;&#953;&#954;&#959;&#963;&#949;&#955;&#943;&#948;&#945; MS-DOS/wINDOWS
						&#947;&#953;&#945; &#949;&#955;&#955;&#951;&#957;&#953;&#954;&#940; (737)
	lang/menu_greek_greece.1253.vim	-- &#954;&#969;&#948;&#953;&#954;&#959;&#963;&#949;&#955;&#943;&#948;&#945; MS-DOS/wINDOWS
						&#947;&#953;&#945; &#949;&#955;&#955;&#951;&#957;&#953;&#954;&#940; (1253)
	lang/menu_greek_greece.cp437.vim            -- &#922;&#969;&#948;&#953;&#954;&#959;&#963;&#949;&#955;&#943;&#948;&#945; Unix
						&#947;&#953;&#945; &#949;&#955;&#955;&#951;&#957;&#953;&#954;&#940; (nl_cp437)
	lang/menu_gr_gr.utf-8.vim 	                -- UTF-8 &#947;&#953;&#945; &#917;&#955;&#955;&#951;&#957;&#953;&#954;&#940;
	tutor/tutor.gr			-- &#934;&#929;&#927;&#925;&#932;&#921;&#931;&#932;&#919;&#931; Vim &#963;&#964;&#945; &#917;&#955;&#955;&#951;&#957;&#953;&#954;&#940;
	README.TXT 			-- &#945;&#965;&#964;&#972; &#964;&#959; &#945;&#961;&#967;&#949;&#943;&#959;


	&#913;&#965;&#964;&#940; &#964;&#945; &#963;&#965;&#956;&#960;&#953;&#949;&#963;&#956;&#941;&#957;&#945; &#945;&#961;&#967;&#949;&#943;&#945; &#956;&#960;&#959;&#961;&#959;&#973;&#957; &#957;&#945; &#956;&#949;&#964;&#945;&#966;&#959;&#961;&#964;&#969;&#952;&#959;&#973;&#957; &#945;&#960;&#972;:

		http://lynxx.org/misc/download/vim-6.1-menu_el.zip
		http://lynxx.org/misc/download/vim-6.1-menu_el.tgz


	&#915;&#953;&#945; &#957;&#945; &#967;&#961;&#951;&#963;&#953;&#956;&#959;&#960;&#959;&#953;&#942;&#963;&#949;&#964; &#964;&#959; Vim &#963;&#945;&#957; &#949;&#960;&#949;&#958;&#949;&#961;&#947;&#945;&#963;&#964;&#942; &#954;&#949;&#953;&#956;&#941;&#957;&#959;&#965; &#963;&#964;&#945;
	&#949;&#955;&#955;&#951;&#957;&#953;&#954;&#940; (&#942; &#959;&#960;&#959;&#953;&#945;&#948;&#942;&#960;&#959;&#964;&#949; &#940;&#955;&#955;&#951; &#947;&#955;&#974;&#963;&#963;&#945;, &#960;&#961;&#974;&#964;&#945; &#949;&#957;&#949;&#961;&#947;&#959;&#960;&#959;&#953;&#942;&#963;&#964;&#949; &#964;&#951;&#957;
	&#949;&#960;&#953;&#955;&#959;&#947;&#942; &#947;&#953;&#945; &#964;&#959; &#960;&#955;&#951;&#954;&#964;&#961;&#959;&#955;&#972;&#947;&#953;&#959; (&#928;&#943;&#957;&#945;&#954;&#945;&#962; &#917;&#955;&#941;&#947;&#967;&#959;&#965;|&#928;&#955;&#951;&#954;&#964;&#961;&#959;&#955;&#972;&#947;&#953;&#959;|
	&#915;&#955;&#974;&#963;&#963;&#949;&#962;|&#917;&#955;&#955;&#951;&#957;&#953;&#954;&#940;) &#954;&#945;&#953; &#948;&#953;&#945;&#955;&#941;&#958;&#964;&#949; &#956;&#953;&#945; &#948;&#953;&#945;&#948;&#959;&#967;&#942; &#960;&#955;&#942;&#954;&#964;&#961;&#969;&#957; (&#960;.&#967;. )
	&#947;&#953;&#945; &#957;&#945; &#945;&#955;&#955;&#940;&#950;&#949;&#964;&#949; &#956;&#949;&#964;&#945;&#958;&#973; &#964;&#951;&#962; &#960;&#961;&#959;&#949;&#960;&#953;&#955;&#949;&#947;&#956;&#941;&#957;&#951;&#962; &#947;&#955;&#974;&#963;&#963;&#945;&#962; &#954;&#945;&#953;
	&#964;&#969;&#957; &#949;&#955;&#955;&#951;&#957;&#953;&#954;&#974;&#957;. &#931;&#964;&#959; Vim &#964;&#945; &#949;&#955;&#955;&#951;&#957;&#953;&#954;&#945; &#960;&#961;&#959;&#946;&#940;&#955;&#955;&#959;&#957;&#964;&#945;&#953; &#963;&#969;&#963;&#964;&#940;.


	&#932;&#941;&#955;&#959;&#962;, &#945;&#960;&#959;&#963;&#965;&#956;&#960;&#953;&#941;&#949;&#964;&#949; &#964;&#959; vim-6.1-menu_el &#963;&#964;&#959;&#957; &#954;&#945;&#964;&#940;&#955;&#959;&#947;&#959; vim61.
	&#913;&#965;&#964;&#972; &#949;&#958;&#945;&#963;&#966;&#945;&#955;&#943;&#950;&#949;&#953; &#972;&#964;&#953; &#964;&#945;&#960;&#945;&#961;&#945;&#960;&#940;&#957;&#969; &#945;&#961;&#967;&#949;&#943;&#945; &#964;&#959;&#960;&#959;&#952;&#949;&#964;&#959;&#973;&#957;&#964;&#945;&#953; &#963;&#964;&#951; &#963;&#969;&#963;&#964;&#942;
	&#948;&#953;&#945;&#948;&#961;&#959;&#956;&#942;. &#913;&#957; &#948;&#949;&#957; &#958;&#941;&#961;&#949;&#964;&#949; &#957;&#945; &#949;&#958;&#940;&#947;&#949;&#964;&#949; &#963;&#964;&#959; $VIMRUNTIME, &#958;&#949;&#950;&#953;&#960;&#940;&#961;&#949;&#964;&#949;
	&#963;&#949; &#959;&#960;&#959;&#953;&#959;&#948;&#942;&#960;&#959;&#964;&#949; &#960;&#961;&#959;&#963;&#969;&#961;&#953;&#957;&#972; &#966;&#940;&#954;&#949;&#955;&#959;.  &#922;&#945;&#964;&#972;&#960;&#953;&#957; &#963;&#973;&#961;&#949;&#964;&#949;-&#954;-&#945;&#966;&#942;&#963;&#949;&#964;&#949; &#942;
	&#945;&#957;&#964;&#953;&#947;&#961;&#940;&#968;&#964;&#949;-&#954;-&#949;&#960;&#953;&#954;&#959;&#955;&#955;&#942;&#963;&#964;&#949; &#964;&#945; &#960;&#945;&#961;&#945;&#960;&#940;&#957;&#969; &#945;&#961;&#967;&#949;&#953;&#945; &#963;&#964;&#951; &#952;&#941;&#963;&#951; &#964;&#959;&#965;&#962; &#956;&#949;&#964;&#940;
	&#964;&#951; &#948;&#951;&#956;&#953;&#959;&#965;&#961;&#947;&#943;&#945; &#964;&#969;&#957; &#954;&#945;&#964;&#945;&#955;&#972;&#947;&#969;&#957; &#960;&#959;&#965; &#952;&#945; &#964;&#945; &#960;&#949;&#961;&#953;&#941;&#967;&#959;&#965;&#957;
	(/&#948;&#953;&#945;&#948;&#961;&#959;&#956;&#951;/&#960;&#961;&#959;&#962;/vim61/lang/el).
	&#913;&#965;&#964;&#942; &#949;&#943;&#957;&#945;&#953; &#951; &#955;&#949;&#947;&#972;&#956;&#949;&#957;&#951; &#967;&#949;&#953;&#961;&#959;&#954;&#943;&#957;&#951;&#964;&#951; &#949;&#958;&#945;&#947;&#969;&#947;&#942;, &#947;&#953;&#900;&#945;&#965;&#964;&#972; &#960;&#945;&#961;&#945;&#954;&#945;&#955;&#959;&#973;&#956;&#949;
	&#957;&#945; &#960;&#955;&#973;&#957;&#949;&#964;&#949; &#964;&#945; &#967;&#941;&#961;&#953;&#945; &#963;&#945;&#962; &#960;&#961;&#959;&#951;&#947;&#959;&#965;&#956;&#941;&#957;&#969;&#962;.

	&#915;&#953;&#945; &#946;&#959;&#942;&#952;&#949;&#953;&#945; &#963;&#964;&#951; &#961;&#973;&#952;&#956;&#953;&#963;&#951; &#964;&#969;&#957; &#960;&#945;&#961;&#945;&#956;&#941;&#964;&#969;&#957; &#964;&#959;&#965; Vim &#947;&#953;&#945; &#965;&#960;&#959;&#963;&#964;&#942;&#961;&#953;&#958;&#951;
	&#949;&#955;&#955;&#951;&#957;&#953;&#954;&#974;&#957;, &#945;&#960;&#972; &#964;&#951; &#947;&#961;&#945;&#956;&#956;&#942; &#949;&#957;&#964;&#959;&#955;&#974;&#957; &#964;&#959;&#965; Vim, &#948;&#974;&#963;&#964;&#949;:


			:help language
			:help messages
			:help encoding


	&#945;&#960;&#972; &#964;&#951; &#947;&#961;&#945;&#956;&#956;&#942; &#949;&#957;&#964;&#959;&#955;&#974;&#957; &#964;&#959;&#965; Vim. &#932;&#959;&#965;&#955;&#940;&#967;&#953;&#963;&#964;&#959;&#957; &#960;&#961;&#941;&#960;&#949;&#953; &#957;&#945; &#964;&#949;&#952;&#959;&#973;&#957;
	&#947;&#953;&#945; &#956;&#965;&#957;&#942;&#956;&#945;&#964;&#945;:

	let $LANG='el'		/	let $LANG='gr'
	:lan mes el		/	:lan mes gr

	&#947;&#953;&#945; &#956;&#949;&#957;&#959;&#973;:

	:menut	English	Greek 	/	let menut=Greek

	&#945;&#960;&#972; &#964;&#951; &#947;&#961;&#945;&#956;&#956;&#942; &#949;&#957;&#964;&#959;&#955;&#974;&#957; &#942; &#963;&#964;&#959; &#945;&#961;&#967;&#949;&#943;&#959; _vimrc.

	&#915;&#953;&#945; &#960;&#949;&#961;&#953;&#963;&#963;&#972;&#964;&#949;&#961;&#949;&#962; &#960;&#955;&#951;&#961;&#959;&#966;&#959;&#961;&#943;&#949;&#962;, &#948;&#949;&#962; VimTip # ("Vim goes INTL -
	Translating Vim Editor Messages, Menus, Encodings").


	&#932;&#959; &#960;&#945;&#961;&#972;&#957; &#941;&#947;&#947;&#961;&#945;&#966;&#959; &#948;&#951;&#956;&#959;&#963;&#953;&#949;&#973;&#964;&#951;&#954;&#949; &#963;&#945;&#957; VimTip #  &#954;&#945;&#953; &#956;&#960;&#959;&#961;&#949;&#943; &#957;&#945;
	&#958;&#949;&#966;&#965;&#955;&#953;&#963;&#964;&#949;&#943; &#963;&#949; &#945;&#960;&#949;&#965;&#952;&#949;&#943;&#945;&#962; &#963;&#973;&#957;&#948;&#949;&#963;&#951; &#963;&#964;&#951;&#957; &#953;&#963;&#964;&#959;&#963;&#949;&#955;&#943;&#948;&#945;:

		http://www.vim.org/tips/tip.php?tip_id=

	Kales epejergasies keimenou!

Vaggelis Efstratiou
vangelise@lynxx.org

VimTip 545: Vim goes Greek - Greek language support for Vim 6.1
http://vim.sourceforge.net/tip_view.php?tip_id=

Vim goes Greek - Complete set of Greek language support for Vim 6.1
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

ENGLISH TEXT
------------

	This is the full set of messages, menus and encodings to
	be used to support Greek language. This set contains:

	vim.pot				   -- dummy portable
						object template for
						vim-6.1 (can be used
						with any language)
	vim.po				  -- the above vim.pot
						file with strings
						translated in Greek
	lang/el/LC_MESSAGES/vim.mo	                 -- the Greek vim.po
						file formatted in
						machine object mode
						(vim.mo)
	lang/menu_gr_gr.greek.vim	                 -- Greek used as
						the default encoding
	lang/menu_gr_gr.latin1.vimq	                 -- Greek for Latin
	lang/menu_gr_gr.iso_8859-1.vim	                 -- Latin-based ISO
						encoding sourceing
						from iso_8859-7 spec
	lang/menu_gr_gr.iso_8859-7.vim	                 -- Greek-Latin-based
						ISO encoding
	lang/menu_greece_greek.737.vim	-- MS-DOS/wINDOWS codepage
						for Greek (737)
	lang/menu_greek_greece.1253.vim	-- MS-DOS/wINDOWS codepage
						for Greek (1253)
	lang/menu_greek_greece.cp437.vim            -- Unix CodePage for Greek
						(nl_cp437)
	lang/menu_gr_gr.utf-8.vim 	                -- UTF-8 for Greek
	tutor/tutor.gr			-- Vim TUTOR in Greek
	README.TXT 			-- this file

	These compressed archives can be downloaded from:

		http://lynxx.org/misc/download/vim-6.1-menu_el.zip
		http://lynxx.org/misc/download/vim-6.1-menu_el.tgz

	To use Vim to edit in Greek (or any) language, we first enable
	the language option for the keyboard (Control
	Panel|Keyboard|Languages|Greek) and enable a key sequence
	(e.g. Ctrl-Shift) to toggle between the default language and
	Greek. In Vim the Greek language is displayed correcty.

	Finally, we unzip vim-6.1-menu_el to the vim61 directory. This
	ensures that the above files are place in the correct path. If
	you don't know how to extract to $VIMRUNTIME, unzip to any
	temporary folder. Then drag&drop or copy-and-paste each of the
	above files to its place after creating the container folders
	(/path/to/vim61/lang/el).
	This is what one may call manual extraction, so please wash your
	hands beforehand.

	For help on setting up Vim to support Greek -- from Vim do:

		:help language
		:help messages
		:help encoding

	For messages you'll have to set at least:

	let $LANG='el'		/	let $LANG='gr'
	:lan mes el		/	:lan mes gr

	For menus:

	:menut	English	Greek 	/	let menut=Greek

	from the cmdline or in the _vimrc file.

	For more information see VimTip #    "Vim goes INTL -
	Translating Vim Editor Messages, Menus, Encodings".

	Enjoy Vim a la Greek!

GREEK TEXT
----------

Vim &#963;&#964;&#945; &#917;&#955;&#955;&#951;&#957;&#953;&#954;&#940; - &#928;&#955;&#942;&#961;&#949;&#962; &#963;&#949;&#964; &#965;&#960;&#959;&#963;&#964;&#942;&#961;&#953;&#958;&#951;&#962; &#949;&#955;&#955;&#951;&#957;&#953;&#954;&#974;&#957; &#947;&#953;&#945; &#964;&#959; Vim 6.1
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

	&#913;&#965;&#964;&#972; &#949;&#943;&#957;&#945;&#953; &#964;&#959; &#960;&#955;&#942;&#961;&#949;&#962; &#963;&#949;&#964; &#956;&#965;&#957;&#951;&#956;&#940;&#964;&#969;&#957;, &#956;&#949;&#957;&#959;&#973; &#954;&#945;&#953; &#954;&#969;&#948;&#953;&#954;&#959;&#960;&#959;&#943;&#951;&#963;&#951;&#962;
	&#947;&#953;&#945; &#967;&#961;&#942;&#963;&#951; &#963;&#949; &#965;&#960;&#959;&#963;&#964;&#942;&#961;&#953;&#958;&#951; &#964;&#951;&#962; &#949;&#955;&#955;&#951;&#957;&#953;&#954;&#942;&#962; &#947;&#955;&#974;&#963;&#963;&#945;&#962; &#956;&#949; &#964;&#959; Vim 6.1.

	&#928;&#949;&#961;&#953;&#949;&#967;&#972;&#956;&#949;&#957;&#945;:
	++++++++++++


	vim.pot				-- &#954;&#949;&#957;&#972; &#960;&#961;&#972;&#964;&#965;&#960;&#959; &#929;&#927;
						&#947;&#953;&#945; &#964;&#959; vim-6.1 (&#956;&#960;&#959;&#961;&#949;&#943;
						&#957;&#945; &#967;&#961;&#951;&#963;&#953;&#956;&#959;&#960;&#959;&#953;&#951;&#952;&#949;&#943;
						&#956;&#949; &#959;&#960;&#959;&#953;&#945;&#948;&#942;&#960;&#959;&#964;&#949; &#947;&#955;&#974;&#963;&#963;&#945;
	vim.po				-- &#964;&#959; &#960;&#945;&#961;&#945;&#960;&#940;&#957;&#969; &#945;&#961;&#967;&#949;&#943;&#959; vim.pot
						&#956;&#949; &#963;&#965;&#956;&#946;&#959;&#955;&#959;&#963;&#949;&#953;&#961;&#941;&#962;
						&#956;&#949;&#964;&#945;&#966;&#961;. &#963;&#964;&#945; &#949;&#955;&#955;&#951;&#957;&#953;&#954;&#945;
	lang/el/LC_MESSAGES/vim.mo   	-- &#964;&#959; &#949;&#955;&#955;&#951;&#957;&#953;&#954;&#972; &#945;&#961;&#967;&#949;&#943;&#959; vim.po
						&#956;&#959;&#961;&#966;&#959;&#960;&#959;&#953;&#951;&#956;&#941;&#957;&#959; &#963;&#949;
						&#954;&#945;&#964;&#940;&#963;&#964;&#945;&#963;&#951; &#924;&#927; (vim.mo)
	lang/menu_gr_gr.greek.vim	                -- Greek &#967;&#961;&#951;&#963;&#953;&#956;&#959;&#960;&#959;&#953;&#949;&#943;&#964;&#945;&#953; &#963;&#945;&#957;
						&#954;&#969;&#948;&#953;&#954;&#959;&#960;&#959;&#943;&#951;&#963;&#951; &#960;&#961;&#959;&#949;&#960;&#953;&#955;&#959;&#947;&#942;&#962;
	lang/menu_gr_gr.latin1.vimq	                -- &#917;&#955;&#955;&#951;&#957;&#953;&#954;&#940; &#947;&#953;&#945; Latin
	lang/menu_gr_gr.iso_8859-1.vim	                -- &#954;&#969;&#948;&#953;&#954;&#959;&#960;&#959;&#943;&#951;&#963;&#951; ISO &#956;&#949; &#946;&#940;&#963;&#951; &#964;&#951;
						&#923;&#945;&#964;&#953;&#957;&#953;&#954;&#942;, &#949;&#954;&#960;&#951;&#947;&#940;&#950;&#949;&#953; &#945;&#960;&#972;
						&#964;&#951; &#960;&#961;&#959;&#948;&#953;&#945;&#947;&#961;&#945;&#966;&#942; iso_8859-7
	lang/menu_gr_gr.iso_8859-7.vim	                -- &#954;&#969;&#948;&#953;&#954;&#959;&#960;&#959;&#943;&#951;&#963;&#951; ISO &#956;&#949; &#946;&#940;&#963;&#951;
						&#964;&#951; &#923;&#945;&#964;&#953;&#957;&#953;&#954;&#942;-&#917;&#955;&#955;&#951;&#957;&#953;&#954;&#942;
	lang/menu_greece_greek.737.vim	-- &#954;&#969;&#948;&#953;&#954;&#959;&#963;&#949;&#955;&#943;&#948;&#945; MS-DOS/wINDOWS
						&#947;&#953;&#945; &#949;&#955;&#955;&#951;&#957;&#953;&#954;&#940; (737)
	lang/menu_greek_greece.1253.vim	-- &#954;&#969;&#948;&#953;&#954;&#959;&#963;&#949;&#955;&#943;&#948;&#945; MS-DOS/wINDOWS
						&#947;&#953;&#945; &#949;&#955;&#955;&#951;&#957;&#953;&#954;&#940; (1253)
	lang/menu_greek_greece.cp437.vim            -- &#922;&#969;&#948;&#953;&#954;&#959;&#963;&#949;&#955;&#943;&#948;&#945; Unix
						&#947;&#953;&#945; &#949;&#955;&#955;&#951;&#957;&#953;&#954;&#940; (nl_cp437)
	lang/menu_gr_gr.utf-8.vim 	                -- UTF-8 &#947;&#953;&#945; &#917;&#955;&#955;&#951;&#957;&#953;&#954;&#940;
	tutor/tutor.gr			-- &#934;&#929;&#927;&#925;&#932;&#921;&#931;&#932;&#919;&#931; Vim &#963;&#964;&#945; &#917;&#955;&#955;&#951;&#957;&#953;&#954;&#940;
	README.TXT 			-- &#945;&#965;&#964;&#972; &#964;&#959; &#945;&#961;&#967;&#949;&#943;&#959;


	&#913;&#965;&#964;&#940; &#964;&#945; &#963;&#965;&#956;&#960;&#953;&#949;&#963;&#956;&#941;&#957;&#945; &#945;&#961;&#967;&#949;&#943;&#945; &#956;&#960;&#959;&#961;&#959;&#973;&#957; &#957;&#945; &#956;&#949;&#964;&#945;&#966;&#959;&#961;&#964;&#969;&#952;&#959;&#973;&#957; &#945;&#960;&#972;:

		http://lynxx.org/misc/download/vim-6.1-menu_el.zip
		http://lynxx.org/misc/download/vim-6.1-menu_el.tgz


	&#915;&#953;&#945; &#957;&#945; &#967;&#961;&#951;&#963;&#953;&#956;&#959;&#960;&#959;&#953;&#942;&#963;&#949;&#964; &#964;&#959; Vim &#963;&#945;&#957; &#949;&#960;&#949;&#958;&#949;&#961;&#947;&#945;&#963;&#964;&#942; &#954;&#949;&#953;&#956;&#941;&#957;&#959;&#965; &#963;&#964;&#945;
	&#949;&#955;&#955;&#951;&#957;&#953;&#954;&#940; (&#942; &#959;&#960;&#959;&#953;&#945;&#948;&#942;&#960;&#959;&#964;&#949; &#940;&#955;&#955;&#951; &#947;&#955;&#974;&#963;&#963;&#945;, &#960;&#961;&#974;&#964;&#945; &#949;&#957;&#949;&#961;&#947;&#959;&#960;&#959;&#953;&#942;&#963;&#964;&#949; &#964;&#951;&#957;
	&#949;&#960;&#953;&#955;&#959;&#947;&#942; &#947;&#953;&#945; &#964;&#959; &#960;&#955;&#951;&#954;&#964;&#961;&#959;&#955;&#972;&#947;&#953;&#959; (&#928;&#943;&#957;&#945;&#954;&#945;&#962; &#917;&#955;&#941;&#947;&#967;&#959;&#965;|&#928;&#955;&#951;&#954;&#964;&#961;&#959;&#955;&#972;&#947;&#953;&#959;|
	&#915;&#955;&#974;&#963;&#963;&#949;&#962;|&#917;&#955;&#955;&#951;&#957;&#953;&#954;&#940;) &#954;&#945;&#953; &#948;&#953;&#945;&#955;&#941;&#958;&#964;&#949; &#956;&#953;&#945; &#948;&#953;&#945;&#948;&#959;&#967;&#942; &#960;&#955;&#942;&#954;&#964;&#961;&#969;&#957; (&#960;.&#967;. )
	&#947;&#953;&#945; &#957;&#945; &#945;&#955;&#955;&#940;&#950;&#949;&#964;&#949; &#956;&#949;&#964;&#945;&#958;&#973; &#964;&#951;&#962; &#960;&#961;&#959;&#949;&#960;&#953;&#955;&#949;&#947;&#956;&#941;&#957;&#951;&#962; &#947;&#955;&#974;&#963;&#963;&#945;&#962; &#954;&#945;&#953;
	&#964;&#969;&#957; &#949;&#955;&#955;&#951;&#957;&#953;&#954;&#974;&#957;. &#931;&#964;&#959; Vim &#964;&#945; &#949;&#955;&#955;&#951;&#957;&#953;&#954;&#945; &#960;&#961;&#959;&#946;&#940;&#955;&#955;&#959;&#957;&#964;&#945;&#953; &#963;&#969;&#963;&#964;&#940;.


	&#932;&#941;&#955;&#959;&#962;, &#945;&#960;&#959;&#963;&#965;&#956;&#960;&#953;&#941;&#949;&#964;&#949; &#964;&#959; vim-6.1-menu_el &#963;&#964;&#959;&#957; &#954;&#945;&#964;&#940;&#955;&#959;&#947;&#959; vim61.
	&#913;&#965;&#964;&#972; &#949;&#958;&#945;&#963;&#966;&#945;&#955;&#943;&#950;&#949;&#953; &#972;&#964;&#953; &#964;&#945;&#960;&#945;&#961;&#945;&#960;&#940;&#957;&#969; &#945;&#961;&#967;&#949;&#943;&#945; &#964;&#959;&#960;&#959;&#952;&#949;&#964;&#959;&#973;&#957;&#964;&#945;&#953; &#963;&#964;&#951; &#963;&#969;&#963;&#964;&#942;
	&#948;&#953;&#945;&#948;&#961;&#959;&#956;&#942;. &#913;&#957; &#948;&#949;&#957; &#958;&#941;&#961;&#949;&#964;&#949; &#957;&#945; &#949;&#958;&#940;&#947;&#949;&#964;&#949; &#963;&#964;&#959; $VIMRUNTIME, &#958;&#949;&#950;&#953;&#960;&#940;&#961;&#949;&#964;&#949;
	&#963;&#949; &#959;&#960;&#959;&#953;&#959;&#948;&#942;&#960;&#959;&#964;&#949; &#960;&#961;&#959;&#963;&#969;&#961;&#953;&#957;&#972; &#966;&#940;&#954;&#949;&#955;&#959;.  &#922;&#945;&#964;&#972;&#960;&#953;&#957; &#963;&#973;&#961;&#949;&#964;&#949;-&#954;-&#945;&#966;&#942;&#963;&#949;&#964;&#949; &#942;
	&#945;&#957;&#964;&#953;&#947;&#961;&#940;&#968;&#964;&#949;-&#954;-&#949;&#960;&#953;&#954;&#959;&#955;&#955;&#942;&#963;&#964;&#949; &#964;&#945; &#960;&#945;&#961;&#945;&#960;&#940;&#957;&#969; &#945;&#961;&#967;&#949;&#953;&#945; &#963;&#964;&#951; &#952;&#941;&#963;&#951; &#964;&#959;&#965;&#962; &#956;&#949;&#964;&#940;
	&#964;&#951; &#948;&#951;&#956;&#953;&#959;&#965;&#961;&#947;&#943;&#945; &#964;&#969;&#957; &#954;&#945;&#964;&#945;&#955;&#972;&#947;&#969;&#957; &#960;&#959;&#965; &#952;&#945; &#964;&#945; &#960;&#949;&#961;&#953;&#941;&#967;&#959;&#965;&#957;
	(/&#948;&#953;&#945;&#948;&#961;&#959;&#956;&#951;/&#960;&#961;&#959;&#962;/vim61/lang/el).
	&#913;&#965;&#964;&#942; &#949;&#943;&#957;&#945;&#953; &#951; &#955;&#949;&#947;&#972;&#956;&#949;&#957;&#951; &#967;&#949;&#953;&#961;&#959;&#954;&#943;&#957;&#951;&#964;&#951; &#949;&#958;&#945;&#947;&#969;&#947;&#942;, &#947;&#953;&#900;&#945;&#965;&#964;&#972; &#960;&#945;&#961;&#945;&#954;&#945;&#955;&#959;&#973;&#956;&#949;
	&#957;&#945; &#960;&#955;&#973;&#957;&#949;&#964;&#949; &#964;&#945; &#967;&#941;&#961;&#953;&#945; &#963;&#945;&#962; &#960;&#961;&#959;&#951;&#947;&#959;&#965;&#956;&#941;&#957;&#969;&#962;.

	&#915;&#953;&#945; &#946;&#959;&#942;&#952;&#949;&#953;&#945; &#963;&#964;&#951; &#961;&#973;&#952;&#956;&#953;&#963;&#951; &#964;&#969;&#957; &#960;&#945;&#961;&#945;&#956;&#941;&#964;&#969;&#957; &#964;&#959;&#965; Vim &#947;&#953;&#945; &#965;&#960;&#959;&#963;&#964;&#942;&#961;&#953;&#958;&#951;
	&#949;&#955;&#955;&#951;&#957;&#953;&#954;&#974;&#957;, &#945;&#960;&#972; &#964;&#951; &#947;&#961;&#945;&#956;&#956;&#942; &#949;&#957;&#964;&#959;&#955;&#974;&#957; &#964;&#959;&#965; Vim, &#948;&#974;&#963;&#964;&#949;:


			:help language
			:help messages
			:help encoding


	&#945;&#960;&#972; &#964;&#951; &#947;&#961;&#945;&#956;&#956;&#942; &#949;&#957;&#964;&#959;&#955;&#974;&#957; &#964;&#959;&#965; Vim. &#932;&#959;&#965;&#955;&#940;&#967;&#953;&#963;&#964;&#959;&#957; &#960;&#961;&#941;&#960;&#949;&#953; &#957;&#945; &#964;&#949;&#952;&#959;&#973;&#957;
	&#947;&#953;&#945; &#956;&#965;&#957;&#942;&#956;&#945;&#964;&#945;:

	let $LANG='el'		/	let $LANG='gr'
	:lan mes el		/	:lan mes gr

	&#947;&#953;&#945; &#956;&#949;&#957;&#959;&#973;:

	:menut	English	Greek 	/	let menut=Greek

	&#945;&#960;&#972; &#964;&#951; &#947;&#961;&#945;&#956;&#956;&#942; &#949;&#957;&#964;&#959;&#955;&#974;&#957; &#942; &#963;&#964;&#959; &#945;&#961;&#967;&#949;&#943;&#959; _vimrc.

	&#915;&#953;&#945; &#960;&#949;&#961;&#953;&#963;&#963;&#972;&#964;&#949;&#961;&#949;&#962; &#960;&#955;&#951;&#961;&#959;&#966;&#959;&#961;&#943;&#949;&#962;, &#948;&#949;&#962; VimTip # ("Vim goes INTL -
	Translating Vim Editor Messages, Menus, Encodings").

	Kales epejergasies keimenou!

Vaggelis Efstratiou
vangelise@lynxx.org

VimTip 546: Vim goes INTL - Translating Messages, Menus, Encodings
http://vim.sourceforge.net/tip_view.php?tip_id=

Vim goes INTL - Translating Vim Editor Messages, Menus, Encodings
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Message Translation
===================

The program used for internationalizing sources is the GNU `gettext'
utility. It is discussed in detail by its creators so we won't go into
it here.

Instead, we'll follow the GNU `gettext' diagram to the letter so that
we can visualize the process of creating our vim.po and vim.mo files
using the program.

	Numbers in parentheses represent the steps we'll actually
	carry out (1 through 5):

	~~~~~~~~~~~~~~~~ QUOTE ~~~~~~~~~~~~~~~~

        (#1)			          [1.1]

Original C Sources ---> PO mode ---> Marked C Sources ---.
                                                         |
              .---------<--- GNU gettext Library         |
.--- make <---+                                          |
|             `---------<--------------------+-----------'
       		 (#2)
|                                            |
|   .-----<--- PACKAGE.pot <--- xgettext <---'   .---<--- PO Compendium
|   |                                            |             ^
|   |                                            `---.         |
		     [2.1]
|   `---.                                            +---> PO mode ---.
|       +----> tupdate -------> LANG.pox --->--------'                |
|   .---'                                                             |
|   |                                                                 |
|   `-------------<---------------.                                   |
		        (#3)
|                                 +--- LANG.po <--- New LANG.pox <----'
|   .--- LANG.gmo <--- msgfmt <---'
|   |
	    (#4)					  (#5)

|   `---> install ---> /.../LANG/PACKAGE.mo ---.
|                                              +---> "Hello world!"
`-------> install ---> /.../bin/PROGRAM -------'

	~~~~~~~~~~~~~~ END QUOTE ~~~~~~~~~~~~~~

(drwng got distorted in textarea)

STEP #1
-------
	Get the most recent of the vim sources (vim-6.1-src1.tar.gz,
vim-6.1-src2.tar.gz) from http://www.vim.org/download.php

	# create a temporary folder - let's call it "vim_tmp" -
	# anywhere on your disk:
	mkdir /path/to/vim_tmp

	# copy the vim source tarball(s) in the temporary directory:
	cp /original/location/vim???.tar.gz /path/to/vim_tmp

	# change to that directory:
	cd /path/to/vim_tmp

	# and decompress them (currently there are only two source
	# archives):
	tar xvfz vim-6.1-src1.tar.gz ; tar xvfz vim-6.1-src2.tar.gz

NOTE: 	Several subdirectories are created, but only the `src'
	directory contains really translatable strings.

[1.1]
-------
	We bypass this step since all canditate strings for
translation in C sources are already marked with `N_()' or `_()' in
vim source files.  For a full discussion of how to mark strings as
translatable in C source files, please refer to the GNU `gettext'
utilities manpage.  We'll return later to this step as the keywords in
vim source files (`N_' and `_') are needed as an argument to the
`xgettext' command.

IMPORTANT: 	Before proceeding to make the PO file, we'll have to
tag the sources, i.e. create the `tags' file:


		# since the `src' directory is the only one containing
		# translatable strings, and because only *.c files plus
		# two more fileS (globals.h, if_perl.xs) have them,
		# we switch to the `src' directory and issue:
		etags *.[ch] *.xs

		# to make sure all files get tagged
		# we could just as well have issued:
		etags src/*/*.*

STEP #2
-------
	The command-line options we'll use are fully described
in the gettext manpage.

NOTE: 		(i) We'll add the `join' option in the second instance
of the command line so that the strings for the second keyword (`_')
be extracted and appended to the same vim.po file; otherwise a second
file vim.po would have to be created.  (ii) We use INPUTFILE=*.[ch]
because we know where the strings are to be exctracted from; else we
must use INPUTFILE=* to exctract from all files.

	# We are ready to issue the `xgettext' command - once for each
	# keyword, and only for the files we know they contain
	#
	# translatable strings (i.e. *.c, globals.h and if_perl.xs):
	xgettext -a -d vim -k N_ -s *.c *.h *.xs

	xgettext -a -j -d vim -k _ -s *.c *.h *.xs

	# It can also be invoked in full:
	xgettext --extract-all --default-domain=vim \
		--keyword=N_ --sort-output *.c *.h *.xs
	xgettext --extract-all --join-existing --default-domain=vim \
		--keyword=_ --sort-output *.c *.h *.xs

CAUTION:	Don't be surprised when opening a vim.po file in a
	text editor. It looks something like this:

	...
		#: ex_cmds.c:4421
		msgid "E149: Sorry, no help for %s"
		msgstr ""


		#: globals.h:1053
		msgid "E14: Invalid address"
		msgstr ""
	...



	Now before proceeding to get the binary text we're after
	(vim.mo), we'll have to translate _all_and_each_messages_
	listed in the vim.po file. The translator must insert the
	translated sting as the value of the `msgstr' variable
	(between quotation marks).

	To stay with the previous quotation, the Italian translation
	of the excerpt above is:

	...
		#: ex_cmds.c:4421
		msgid "E149: Sorry, no help for %s"
		msgstr "E149: Spiacente, nessun aiuto per %s"


		#: globals.h:1053
		msgid "E14: Invalid address"
		msgstr "E14: Indirizzo invalido"
	...

[2.1]
-------
	We currently have no use for the `tupdate' command since
there's no vim.po file yet; however, this program comes handy when we
already have a *.po file and must update it based on a new release of
sources. The command is simple enough. After unpacking the new
tarballs to our "vim_tmp" directory (step 1), we issue:

	# change to tmp directory
	cd /path/to/vim_tmp

	# rename "vim.po" to "OLD_vim.po" assuming it's placed here:
	mv vim.po OLD_vim.po

	# update OLD_vim.po:
	tupdate NEW_vim.po OLD_vim.po

	# rename "NEW_vim.po" back to its usable filename:
	mv NEW_vim.po vim.po

	In case we don't want to go through the whole process of
	creating a vim.po file after a new vim-###-src#.tar.gz
	release, this program will take care of recreating our updated
	vim.po file (NEW_vim.po) from OLD_vim.po, including the old
	translations which will be taken over to the newly created
	file as long as they still match. However, it is recommended
	that, after a new vim_src### release, we actually start over.
	Just in case!

STEP #3
-------
	Next step is simplicity itself--assuming all messages
have already been translated in vim.po. We'll only use one option out
of several that the `msgfmt' program supports; they are fully described
in the `msgfmt' manpage. For hints on internationalizing Vim see the
previous VimTip (VimTip#).


	# change to tmp directory where our vim.po is placed:
	cd /path/to/vim_tmp

	# create vim.mo from vim.po:
	msgfmt -o vim.mo vim.po

	# or in full-text:
	msgfmt --output-file=vim.mo vim.po

STEP #4
-------
	Installing the vim.mo file requires that a directory
in $VIMRUNTIME$ (i.e. currently /path/to/vim61) exists or is created
express for the language you'll be supporting.

	Let's suppose the language we support is Greek (abbreviated as
	`gr' or `el'). We do:

	# create directory named `el' in $VIMRUNTIME$/path/to/lang
	# with a standard subdirectory `LC_MESSAGES':
	mkdir /path/to/vim61/lang/el
	mkdir /path/to/vim61/lang/el/LC_MESSAGES

	# copy our vim.mo file for Greek language supported:
	cp /path/to/vim_tmp/vim.mo /path/to/vim61/lang/el/LC_MESSAGES

STEP #5
-------
	Vim detects the system's local language settings when
starting and--if supported--loads it automatically; else you'll have
to change default message language from within Vim using:

	" lan[guage] {name} e.g.: lan el

	" now let's test if it's working by issuing an erroneous vim
	command--like: :HELP

	"	and you'll get the message:
	&#916;&#949;&#957; &#949;&#943;&#957;&#945;&#953; &#949;&#957;&#964;&#959;&#955;&#942; &#954;&#949;&#953;&#956;&#949;&#957;&#959;&#947;&#961;&#940;&#966;&#959;&#965;: HELP

	"	that's all Greek to me: HELP
	Not an editor command: HELP

Summary
-------

	- Download and unpack the vim sources in a temporary directory.
	- Use GNU `gettext' to get your template (untranslated) file.
	- Translate all entries in the template in your language.
	- Convert the translated PO file into a MO file using `msgfmt'.
	- Place MO file in /vim##/lang/your_language/LC_MESSAGES folder.
	- Set the 'language', 'messages', 'menu' options in Vim.
	- Test Vim and use it with your newly installed language.

Menu Translation
================

	BASICS
	------
		For Latin-based languages, menu translation is
	fairly painless. Open a `menu_xx_xx.latin1.vim' and use it as
	a template to create the menu after translating the relevant
	strings into the Latin-based language you intend to support.
	You only have to pay attention that unique letter identifiers
	in a given submenu don't repeat (e.g. &Open binds the letter
	`O' uniquely so that the keyboard responds to Alt-O, and
	cannot be repeated in the "File" menu.  For Latin-based
	languages, at least one encoding must be defined as the
	default encoding for a given system; Latin1 is used on all
	OS'. If your canditate language is non-Latin but Latin-based,
	--as a rough rule--do menu translations in at least one of the
	following encodings:


	o	utf-8
	o	iso-####-#
	o	an MS-DOS/wINDOWS code page
		--consult old MS-DOS (v.5 or 6.2) online help for
		codepage and/or country setting details).

	HOW-TO
	------
		To create the menu file, we use one or several
	word processors that supports one or several of the encodings
	for the language we intend to support. If we can find the
	above encodings in the SaveAs option of our word processor(s),
	it's already sufficient -- depending on the number of OS' you
	wish to support.  We can use, for example, an existing
	menu_xx_xx.latin1.vim template and translate the translatable
	strings pretty much like the gettext program prepares them by
	distinguishing between `msgid "ABC"' and `msgstr "XYZ"'.
	Instead we'll do it manually.  Save only the translated
	strings of the supported language (i.e. `msgstr "XYZ"' in our
	example) into a separate file using the Save As option of a
	word processor (e.g. MS-Word). Now we have, for example, a
	file containing the translated stings, say in iso-####-x with
	filename `msgstr_iso-####-x'.

	Here's the Hungarian menu for the iso_8859-2 specification
	(lang/menu_hu_hu.iso_8859-2.vim):

	msgid "ABC"	 		msgstr "XYZ"
	~~~~~~~~~~~~~~~~~~~~~~ QUOTE ~~~~~~~~~~~~~~~~~~~~~~
	...
	scriptencoding iso-8859-2


	" Help menu
	menutrans &Help			&S&#970;g&#963;
	menutrans &Overview<Tab><F1>	&#913;&ttekint&#953;s<Tab><F1>
	menutrans &How-to\ links	&HOGYAN\ linkek
	menutrans &User\ Manual		&K&#953;zik&#966;nyv"
	...

	~~~~~~~~~~~~~~~~~~~~ END QUOTE ~~~~~~~~~~~~~~~~~~~~

	We would create two plain text files, one with filename
	`msgid_iso-####-y', containing the left-most part of
	menu_hu_hu.iso_8859-2.vim:


	...
	menutrans &Help
	menutrans &Overview<Tab><F1>
	menutrans &How-to\ links
	menutrans &User\ Manual
	...

	and one with filename `msgstr_iso-####-z' we got with the
	SaveAs option of our word processor, containing the right-side
	part of menu_hu_hu.iso_8859-2.vim:

	...
					&S&#970;g&#963;
					&#913;&ttekint&#953;s<Tab><F1>
					&HOGYAN\
					linkek
					&K&#953;zik&#966;nyv"
	...

	CAUTION:	Do not use a spreadsheet to do the job as
	these apps add/remove bytes to encodings and reset counters
	when saved and distort them. Only use your wordprocessor's
	SaveAs option and make sure it's a good one at that.

	Then we open both files in a simple text editor (Windows
	Notepad or vim) and paste line by line the left-side-file to
	the right-side-file so that the we get the joined file. Now
	them as a simple text. This is, say, our
	save menu_aa_bb.iso_8859-cc.vim

	CAUTION TOO:	Do not use a legacy word processessing
	program for this last Save-As-Text-Only file operation. Do
	not use the word processor that helped with the encoding; else
	you might get the wrong bytes in encodings when the left-most
	part of the file is saved along with the rest.


	We can repeat the same (painstaking, yet menus are short)
	process with utf-8 encoding, MS-wINDOWS codepage, and any
	other encoding we need to support.



Encodings
=========

	To create the language encodings files for Vim in any
	language, we first jot down the full specification of the
	encodings in the most common OS' for the language we intend to
	support.

	Next we create a corresponding menu_xx_yy.ABC_mn-zz.vim file
	for each of these supported encondings (making sure they
	exist!).

	We may use only one or several menu translations (we suggested
	three basic ones above, sect. 2); one of these -- the one
	with the translated strings -- can be used as the default
	encoding to reference other ones. We reference the encodings
	we cannot create with a word processor to the default encoding
	using any menu_xx_yy.ABC_mn-zz.vim as a template.

	Here's the Spanish menu for the MS-wINDOWS codepage 850
	specification (lang/menu_spanish_spain.850.vim):

		~~~~~~~~~~~~~~~~~~~~~~ QUOTE ~~~~~~~~~~~~~~~~~~~~~~

		source <sfile>:p:h/menu_es_es.iso_8859-1.vim

		~~~~~~~~~~~~~~~~~~~~ END QUOTE ~~~~~~~~~~~~~~~~~~~~

	As you can see, it contains only one line and sources this spec
	here from another one (i.e. es_es.iso_8859-1 in this case).

Examples
========

	As an example for fully supporting a specific language you may
	download the Greek tarball:

		http://lynxx.org/misc/download/vim-6.1-menu_el.zip
		http://lynxx.org/misc/download/vim-6.1-menu_el.tgz

	See also VimTip "Vim goes Greek - Complete set of Greek language
	support for Vim 6.1" (VimTip#).

Disclaimer
==========

	This document is freely redistributable, but I take no
	liability for the correctness and safety of any procedures or
	advice given here.  This document is distributed in the hope
	that it will be useful, but WITHOUT ANY WARRANTY, explicit or
	implied for the MERCHANTABILITY or FITNESS FOR A PARTICULAR
	PURPOSE.

	Happy PO-MO-ing!

Vangelis Eustratius
vangelise@lynxx.org

VimTip 547: Smarter Table Editing
http://vim.sourceforge.net/tip_view.php?tip_id=

Smarter Table Editing

I frequently need to edit tables where the fields are of varying lengths.
Switching between fields is a pain as the fields can contain multiple words and
using the w key is impractical. Moreover adding a new row to the table is most
troublesome. The new fields need to be aligned with the old entries and tabs
don't work very well. Below is an example of such a table that I pulled from
the vim user's guide:

USAGE                         RESULT    DESCRIPTION

append( {lnum}, {string})     Number    append {string} below line {lnum}
argc()                        Number    number of files in the argument list
argidx()                      Number    current index in the argument list
argv( {nr})                   String    {nr} entry of the argument list

* The table above might not be aligned vertically because of the font vim-online
is using

I wrote the NextField function (given below) to automatically check the fields
on the line directly above and move the cursor to the beginning of the next
field. The function pads the line if required. I am using 2 or more spaces as
the field separator but the field separator is an argument to the function and
can be changed easily.

I have mapped <S-Tab> (Shift-Tab) to invoke the function. In the case of the
above table hitting <S-Tab> anywhere on the lines after the line that starts
with "append" will cause the cursor to move to the next field position or just
before it depending on the context. The function will not work on the line
starting with "append" as there is an empty line with no fields above it. It
will work on the empty line below the table titles as there are fields on the
line above it. Same is the case with the empty line below the last line of the
table.

The function takes the following arguments:

fieldsep:   A pattern that specifies the field separator between table columns
minlensep:  Minimum length of field separator. It is used to make the function
            move to the next field even when the cursor is positioned less than
            the length of a field separator from the next table column. Set this
            to 0 if you are not sure what this argument is for.
padstr:     The string to be used for padding when the current line needs to be
            padded in order to reach the next table column.
offset:     The offset at which you want the cursor to be positioned in the
            next table column. Set it to 0 if you want the cursor positioned at
            the start of the next table column.

(The above table is another case where the function is helpful)

To use the function, place the code below in vimrc and add the following lines
after it:

map <S-Tab> :call NextField(' \{2,}',2,' ',0)<CR>
map! <S-Tab> <C-O>:call NextField(' \{2,}',2,' ',0)<CR>

Note: If the whitespace between the fields consists of anything other than
spaces, the function will not work correctly without changing the field
separator. Use expandtab option if you must use tabs.

Many variations of the above idea are possible. One variation would be to have
a plugin that when invoked on a specific line, extracts the field information
on that line and maps the tab key to move to the next field then onwards. That
way there won't be any dependence on the line directly above the cursor. If you
have any suggestions of your own let me know. If enough people show interest in
enhancing this feature I most likely will code an enhanced version.

--------------------------------Cut Here----------------------------------------
" function: NextField
" Args: fieldsep,minlensep,padstr,offset
"
" NextField checks the line above for field separators and moves the cursor on
" the current line to the next field. The default field separator is two or more
" spaces. NextField also needs the minimum length of the field separator,
" which is two in this case. If NextField is called on the first line or on a
" line that does not have any field separators above it the function echoes an
" error message and does nothing.

func! NextField(fieldsep,minlensep,padstr,offset)
    let curposn = col(".")
    let linenum = line(".")
    let prevline = getline(linenum-1)
    let curline = getline(linenum)
    let nextposn = matchend(prevline,a:fieldsep,curposn-a:minlensep)+1
    let padding = ""

    if nextposn > strlen(prevline) || linenum == 1 || nextposn == 0
        echo "last field or no fields on line above"
        return
    endif

    echo ""

    if nextposn > strlen(curline)
        if &modifiable == 0
            return
        endif
        let i = strlen(curline)
        while i < nextposn - 1
            let i = i + 1
            let padding = padding . a:padstr
        endwhile
        call setline(linenum,substitute(curline,"$",padding,""))
    endif
    call cursor(linenum,nextposn+a:offset)
    return
endfunc
--------------------------------Cut Here----------------------------------------

VimTip 548: Using H and L keys as context sensitive pagedown/pageup
http://vim.sourceforge.net/tip_view.php?tip_id=

The H and L keys move the cursor to the top or bottom of the window
respectively. They can be a real time saver, instead of hitting j/k many times,
a single H/L can move the cursor to the proper place. However, when you are
already at the top of the window the H key does nothing and similarly at the
bottom of the window the L key does nothing.

I started using the H/L keys a few days ago and quickly discovered that after
getting to the top using H, I often want to scroll up. Hitting H again does
nothing, so I wrote a function Hcontext which makes the H key context
sensitive. I then mapped Hcontext to the H key.  Now hitting the H key anywhere
other than at the top of the window leads to the usual behavior but hitting H
at the first line of the window causes the window to scroll one page back and
positions the cursor at the top of the window.  Similar behavior is implemented
by the Lcontext function but in the other direction. Hitting L on the last line
of the window now acts like the pagedown key.

Even if you have never used the H/L keys before you can now start using them
as replacement pagedown/pageup keys. Just cut and paste the code at the end
into your vimrc and put the following maps after that.

noremap H :call Hcontext()<CR>
noremap L :call Lcontext()<CR>

The unmapped H and L keys take a numeric count as well. Unfortunately, I am not
aware of a way to make that count available to the user functions I wrote. The
typical vim behavior in case of user functions is to supply the count as a
range to the user function. This works most of the time but sometimes the count
gets rejected because of range checking. If you are aware of a workaround
please let me know.

You can contact me by writing to latif@techuser.net. If you have suggestions as
to other keys that can be made context sensitive without affecting their
original function, email me. I also maintain a webpage where you can ask help
for your text processing problems. The webpage is at http://www.techuser.net

---------------------------------Cut Here----------------------------------------
func! Hcontext()
    if (winline() == 1 && line(".") != 1)
        exe "normal! \<pageup>H"
    else
        exe "normal! H"
    endif
    echo ''
endfunc

func! Lcontext()
    if (winline() == winheight(0) && line(".") != line("$"))
        exe "normal! \<pagedown>L"
    else
        exe "normal! L"
    endif
    echo ''
endfunc
---------------------------------Cut Here----------------------------------------

VimTip 550: FreeBSD Fix: Arrow keys/cursor movement prints A B C D letters on remote shell: xterm, vt100.
http://vim.sourceforge.net/tip_view.php?tip_id=

Hi,
I wonder how many of you are pissed of with arrow keys behavior during INSERT mode in Vim.
So was I.
Leave all the key mappings default, do not change your TERM environment.
Here's a simple tip,
:set term=cons25 and save the settings for Vim usage.

It was tested with Vim 5.8 and 6.1 editions on; FreeBSD 4.X-STABLE; xterm(-color),VT100 remote terminals; (t)csh shells.

Greets.
Peace.
Legalize it.

VimTip 551: automatic indenting XML file in VIM with the help of XSLT
http://vim.sourceforge.net/tip_view.php?tip_id=

Do you want to indent an XML file? Try the following XSLT:
---------------------------------------- name it indent.xsl
<xsl:stylesheet version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:output method="xml" indent="yes"/>
<xsl:strip-space elements="*"/>
<xsl:template match="/">
  <xsl:copy-of select="."/>
</xsl:template>
</xsl:stylesheet>
----------------------------------------
In VIM, whenever a file with the ".xml" extension is loaded into the buffer, you can try the following
in your ~/.vimrc to trigger the XSLT for filtering on the buffer contents:
----------------------------------------
  if version >= 540
    augroup filetype
       autocmd FileType xml '[,']!xsltproc indent.xsl %
    augroup END
  endif
  " other autocmds
  if version>540
    autocmd!
  endif
----------------------------------------
Voila! Next time when you load an XML file in VIM, it will be indented automatically.

Cheers,

VimTip 552: replace buffer list when switching
http://vim.sourceforge.net/tip_view.php?tip_id=

I use vim's session file feature a lot to switch between projects. Preserving all that context is nice. Usually my process goes like this:

1. Save the current session:
 :mks! ~/v/project1.vim

2. Quit vim
:xa

3. Restart with different session file:
 vim -S ~/v/project2.vim

I was exiting and re-opening vim because if I just loaded the second project file, a list of /both/ projects buffers would appear in my buffer list. This was not what I wanted-- I wanted to replace the first buffer list completely wtih the second.
There is a simple way to do this.

At the top of a session file, add this:

1,999bdelete

That will delete the first 999 existing buffers, effectively allowing any new buffer definitions in the rest of the session file to replace
what is currently there. Now you can switch directly to a new session without exiting. Just use:

 :so ~/v/project2.vim

VimTip 553: Prev and Next
http://vim.sourceforge.net/tip_view.php?tip_id=

One of the most useful key combinatins that remain unknown to the masses are <C-o> and <C-i>.
They work like the "back" and "next" arrows in your HTTP user agent, meaning you can jump back and back again between files/locations within the same file very very easily and comfortable.

:jumplist        for a list of possible locations.

Try it.

Use it.

Have a nice day.

VimTip 554: Smarter Table Editing II
http://vim.sourceforge.net/tip_view.php?tip_id=

In vimtip #547 I described some functions that enable easier navigation
and editing of tables. I have considerably enhanced the functionality
and placed all the relevant code in a script file vimscript #769.

The idea of the script is to automatically extract fields from a table
row and use that information to create maps that aid in editing and
navigation of the table. The user first marks a table row as table
heading. The line does not literally have to be the table heading, but
it should be representative of the typical row of the table in
question.

After this step the script maps tab and shift-tab keys to move between
fields. These mappings work in both insert and normal modes. The tab
mapping is especially useful in insert mode as it inserts the correct
amount of padding to reach the start of the next field.

The script also has an alignment feature that aligns the fields of the
row with that of the heading. Editing a pre-existing table frequently
leads to misaligned rows and this feature alleviates the need to
manually add/remove padding.

To better illustrate the functionality of the script, I have created
the table below:

====================================================================
This table      illustrates the use of         table.vim script
====================================================================
<Leader>th      marks a line as table heading  and
activates maps  for <Tab>                      and <S-Tab> keys
<Leader>th      must be invoked on a well      formed line with
the right       number of columns
This means      that the above line does not   qualify
Also notice     that the field separator is    atleast two spaces
--------------------------------------------------------------------
when the maps   are active, pressing           <Tab> here
<-- moves here  <Tab> here                     <-- moves here
<==             <S-Tab> moves back to "<=="    <**
<S-Tab> here    moves to "<**" above
--------------------------------------------------------------------
The maps for    <Tab> and <S-Tab> work in      insert and normal
modes, and can  be deactivated by pressing     <Leader>tt
pressing        <Leader>tt again,              re-enables the maps
--------------------------------------------------------------------
The script      has some very basic support    for field alignment
 It is very       easy to get out of alignment        when editing
<Leader>ta      on the line above will         fix the line to:
It is very      easy to get out of alignment   when editing
--------------------------------------------------------------------
<Leader>ta      can be very handy if the user  wants to expand or
contract        fields, just change the width  of the fields on the
  heading line      and press                      <Leader>th
  to mark the       new heading and then           num<Leader>ta
  on the top        line of the table.             num is the
  number of         lines in the table
--------------------------------------------------------------------
The alignment   command fails when a row has   more fields than
the heading     or when the contents of a      field don't fit
inside the      field, as specified by the     heading row
case1           is        this                 row
case2 is this row      ...                       ...
this is another     example of case2, there    is no space for
field           separator on the first         field on above line
====================================================================

If you don't like the default mappings change them to whatever you
like. The mappings are defined on top of the table.vim script file.

To install the script, place table.vim in the vim macros directory
and source it in your vimrc using:
source $VIMRUNTIME/macros/table.vim

If you simply want to check the functionality of the script, place
the script file in your current directory, open vim in the same
directory and use
:so table.vim

If you have questions/comments or bug-reports to submit, send them
to latif@techuser.net or visit my website http://www.techuser.net

The script can also be downloaded from http://www.techuser.net/files

VimTip 555: Vim as bookmark manager
http://vim.sourceforge.net/tip_view.php?tip_id=

Vim as bookmarks manager

Sometimes you are collecting bookmarks from various sources, not only
web, mail client, usenet even newspapers. Sometimes it is not possible, easy etc.
to insert them in your favorite web browser bookmark manager. But
nothing is lost - you can use your Editor :)

Keep all URLs in one file called eg. url. One URL per line.
Put this in your .vimrc:

autocmd BufRead ~/url map <F8> :call BrowserURL()<cr>
let g:web_browser = "konqueror"
function! BrowserURL()
	if getline('.') !~ '^\s*\#'
		if g:web_browser == "konqueror"
			exe ":!dcop `dcopfind -a 'konqueror*'` konqueror-mainwindow\\#1 newTab ".getline('.')
		elseif g:web_browser == "mozilla"
			exe ":!mozilla -remote \"openurl(".getline('.').", new-tab)\""
		endif
	endif
endfunction

Note: you can select in Visual mode few lines and open in one keypress
few tabs. Comment lines with # at the beginning. This lines won't be
precessed with function.

I am sure such operation are possible also with other webbrowsers with
tabs.

Konqueror from KDE3.2-Alpha1 (but this dcop commands should work also
	with older versions)
Mozilla 1.4

VimTip 556: Help on <F2> for Python with pydoc
http://vim.sourceforge.net/tip_view.php?tip_id=

Add the following 2 lines to your ~/.vim/ftplugin/python.vim, open an pythonscript place the cursor over an keyword and press F2 and be happy.

map <F2> :exec "!xterm -e 'pydoc ".expand("<cword>")."'"<CR><CR>
imap <F2> <ESC>:exec "!xterm -e 'pydoc ".expand("<cword>")."'"<CR><CR>i

VimTip 557: Opening several files in vim via ListFile
http://vim.sourceforge.net/tip_view.php?tip_id=

Suppose You want to open several files in vim, but the names of the files to open are stored in a file, each file name on separate line. This is the case with Total Commander, when You open a program and pass it %L as a parameter.

It is possible to do it like that:

gvim "+gl/^/exec 'badd '.getline('.')" +bdel +nohls +"cd %:h" LISTFILE

where LISTFILE contains list of file names to open.

For abovementioned Total Commander, I create new item in "start menu", and assign a shortcut, let's say CTRL+ALT+F4 to it. Set path\gvim.exe as a command.

This is what i put in a "parameters" section:

"+gl/^/exec 'badd '.getline('.')" +bdel +nohls +"cd %%:h" %L

Then I can select several files, press CTRL+ALT+F4 and load all of them into my favourite text editor :)

VimTip 558: Using TagList for ANT build files
http://vim.sourceforge.net/tip_view.php?tip_id=

ANT is a XML based make utility (mainly for Java, http://ant.apache.org).

A build file can have several projects, and each project can have many targets.
Here is a simple example:
ant clean
ant compile
ant run

Editing an ANT file can be tiresome looking for the appropriate target entry.

Using the taglist plugin at least version 2.02 (http://vim.sourceforge.net/script.php?script_id=273) you can easily navigate an ANT file by creating these entries:

In your _vimrc file:
let g:tlist_ant_settings = 'ant;p:Project;t:Target'

And either add to or create a ctags.cnf file:
--langdef=ant
--langmap=ant:.xml
--regex-ant=/^[ \t]*<[ \t]*project.*name="([a-zA-Z0-9 ]+)".*>/\1/p,project/i
--regex-ant=/^[ \t]*<[ \t]*target.*name="([a-zA-Z0-9 ]+)".*>/\1/t,target/i

To determine where to create the ctags.cnf file see the ctags documentation (http://ctags.sourceforge.net/ctags.html, on WinXP this file goes into C:\Documents and Settings\local_user_name\ctags.cnf).

When this is used in conjuction with the Vim compiler for ANT and a Vim Menu  for ANT (http://www.vim.org/script.php?script_id=155), it can be very powerful.

VimTip 559: Use Vim to Expire your Mail (So that Mutt can delete them later)
http://vim.sourceforge.net/tip_view.php?tip_id=

Mutt has a feature to list expired mails (~E). Sadly, there's no built in way to
set the expiry date of a certain mail so I came up with a vim mapping to manually
insert the "Expiry:" field of the mail header.  It will ask for the date the email should
expire (default is 'today') and then run the date command to produce the rfc-822
compliant date.

Here's the mapping and related function:

" Set expire date for the currently edited mail
nmap ,e gg/^Date: <CR>:call GetExpiryDate()<CR>:exe "normal! oExpires:\ndate --rfc-822 -d '". ExpiryDate."'"<ESC>!!sh<CR>kJ<CR>

function GetExpiryDate()
 call inputsave()
 let g:ExpiryDate = input("Enter expiry date: ", "today")
 call inputrestore()
endfunction

VimTip 560: Generate calendar file
http://vim.sourceforge.net/tip_view.php?tip_id=

Since I work on different machines, I prefer all my calendar items to be
available in one single ASCII file, which is easily handable with vim.
The function Calendar() below generates the following output (extract)

...............
----- Week 1 -----
Mo 30
Tu 31
====================    2003    ========================================
====================    Q 1     ========================================
--------------------  Jan 2003  ----------------------------------------
We 01
Th 02
Fr 03
Sa 04
Su 05
----- Week 2 -----
Mo 06
Tu 07
...............

This may be stored in a file accessible by a single key stroke from vim.

Here is the function:

function! Calendar(year, month, day, weekday, week, daycount)
  " output daycount calendar days starting from given date
  " into new buffer
  new
  set buftype=nofile bufhidden=hide noswapfile
  let year = a:year
  let month = a:month
  let day = a:day
  let wd = a:weekday
  let week = a:week

  let index = 0
  let date = ''
  let diy = 777 " day in year, wrong before next year
  while (index < a:daycount) " no of days to output
    let diy = diy + 1
    if (wd > 7)
       let wd = 1
       let week = week + 1
       if (week >= 53)
         if (week >= 54)
           let week = 1
	 elseif (day >= 28 || day <= 3)
           let week = 1
	 endif
       endif
    endif
    if (wd == 1) " day name
       let dn = "Mo"
    elseif (wd == 2)
       let dn = "Tu"
    elseif (wd == 3)
       let dn = "We"
    elseif (wd == 4)
       let dn = "Th"
    elseif (wd == 5)
       let dn = "Fr"
    elseif (wd == 6)
       let dn = "Sa"
    elseif (wd == 7)
       let dn = "Su"
    else
       let dn = "** ERROR: Unknown day name ** "
    endif
    if ((day > 31) || (month == 2 && (day > 29 || day > 28 && year % 4))
    	\ || (month == 4 && day > 30) || (month == 6 && day > 30)
	\ || (month == 9 && day > 30) || (month == 11 && day > 30))
       let day = 1
       let month = month + 1
       if (month > 12)
	  let month = 1
	  let diy = 1
	  let year = year + 1
	  if (wd <= 3)
	    let week = 1
          endif
       endif
       if (month == 1)
	 let yline = "===================="
	 call append(line("$"), yline . "    " . year . "    " . yline . yline )
	 call append(line("$"), yline . "    Q 1     " . yline . yline )
	 let monthn = "Jan"	" month name
       elseif (month == 2)
	 let monthn = "Feb"
       elseif (month == 3)
	 let monthn = "Mar"
       elseif (month == 4)
	 let monthn = "Apr"
	 call append(line("$"), yline . "    Q 2     " . yline . yline )
       elseif (month == 5)
	 let monthn = "May"
       elseif (month == 6)
	 let monthn = "Jun"
       elseif (month == 7)
	 let monthn = "Jul"
	 call append(line("$"), yline . "    Q 3     " . yline . yline )
       elseif (month == 8)
	 let monthn = "Aug"
       elseif (month == 9)
	 let monthn = "Sep"
       elseif (month == 10)
	 let monthn = "Oct"
	 call append(line("$"), yline . "    Q 4     " . yline . yline )
       elseif (month == 11)
	 let monthn = "Nov"
       elseif (month == 12)
	 let monthn = "Dec"
       else
	 let monthn = "** ERROR: Unknown month ** "
       endif
       let mline = "--------------------"
       call append(line("$"), mline . "  " . monthn . " " . year . "  " . mline . mline )
    endif
    if (wd == 1)
       "call append(line("$"), "----- Week " . week . " (" . diy . "..) -----")
       call append(line("$"), "----- Week " . week . " -----")
    endif
    let date = dn . " " " beginn with name of day of week
    if (month < 10)
       let date = date . year . '-0' . month
    else
       let date = date . year . '-' . month
    endif
    " skip month, year
    let date = dn . " " " not interested in year, month
    if (day < 10)
       let date = date . '0' . day
    else
       let date = date . day
    endif
    " let date = date . " (" . diy . ")"
    call append(line("$"), date)

    let index = index + 1
    let day = day + 1
    let wd = wd + 1
  endwhile
endfunction

map <S-F7> :call Calendar(2002, 12, 30, 1, 1, 1000)<CR><CR>
" Dec 30, 2003 is Monday (day 1 in week), week 1 in 2003

Put the above code in your vimrc and call the function, here it is shown
with entries for 1000 days. Of course, if you do not use correct
arguments matching and existing day, all output will be mess.

VimTip 561: Context Sensitive h and l
http://vim.sourceforge.net/tip_view.php?tip_id=

While writing an email I noticed that the h key does nothing when pressed at
the start of the line. It occurred to me that it would be very natural behavior
for the h key to move to the end of the previous line under the above situation.
Similarly, it would be fairly useful behavior for the l key to move to the
start of the next line when the cursor is at the end of the line.

The following illustration should clarify the behavior I am talking about:

pressing l at the end of this line -->
<-- should move to the beginning of this line

pressing h at the start of the next line, should move to end of this line -->
<--

I have coded two functions that implement the desired behavior. Putting the
code given at the end of this tip in your vimrc will map the h and l keys to
behave in a context sensitive manner. The only caveat is that under
"virtualedit=all" h/l keys will revert to their usual vim behavior.

This tip is similar in spirit to vimtim# 548, which concerned the H and L keys.
Robert Kelly created vimscript# 763 for the code in vimtip# 548. I suggest that
he adds the code below to that script. You can also retrieve a script
with mappings for all the above mentioned keys on my download page
http://www.techuser.net?content=5

------------------------------------cut here-----------------------------------
nmap <silent> h :<C-U>call ContextLeft()<CR>
nmap <silent> l :<C-U>call ContextRight()<CR>

func! ContextLeft()
    let cnt = v:count == 0 ? 1 : v:count
    if col('.') == 1 && line('.') != 1 && &ve != "all"
        exe "normal! " . cnt. "k$"
    else
        exe "normal! " . cnt. "h"
    endif
endfunc

func! ContextRight()
    let cnt = v:count == 0 ? 1 : v:count
    if col('.') >= strlen(getline('.')) && line('.') != line('$') && &ve != "all"
        exe "normal! " . cnt . "j^"
    else
        exe "normal! " . cnt . "l"
    endif
endfunc
------------------------------------cut here-----------------------------------

VimTip 562: modeline sets vimrc options on a per file basis
http://vim.sourceforge.net/tip_view.php?tip_id=

Sometimes I want vi to treat a file different than the .vimrc file.
For example, I have a file that has fixed length text records,
 tabs in this file would mess it up.
Setting the option expandtab will force tabs to be converted to spaces.

Near the top of the file I put a line that says:
# vim: set expandtab:

When I open the file after that it will replace ^I (tab characters) with the correct number of spaces.

VimTip 563: useful Occurences under cursor and with prompt
http://vim.sourceforge.net/tip_view.php?tip_id=

[I is very useful  display all lines that contain the keyword under the cursor
so following are two function for selection contain in two way under cursor or prompt find

a big thanx Yegappan give me the hint for ijump

function! s:UnderOccurences()
   exe "normal [I"
   let nr = input("Which one: ")
   if nr == ""
       return
   endif
   exe "normal " . nr . "[\t"
endfunction!

function! s:FindOccurences()
   let pattern = input("Prompt Find: ")
   if pattern == ""
       return
   endif
   exe "ilist " . pattern
   let nr = input("Which one: ")
   if nr == ""
       return
   endif
   exe "ijump " . nr . pattern
endfunction

VimTip 564: mouse wheel for scroll only - disable paste on middle button press.
http://vim.sourceforge.net/tip_view.php?tip_id=

I have had a problem when using the mousewheel for scrolling. I occasionaly press the wheel and it pastes text in the clipboard's "*" register at the place where the scroll wheel was pressed accidentally. This has been a constant irritation.

The workaround is documented in VIM help -
:help <MiddleMouse>

From change.txt (VIM help):
"If you have a scrollwheel and often accidentally paste
text, you can use these mappings to disable the
pasting with the middle mouse button: >
    :map <MiddleMouse> <Nop>
    :imap <MiddleMouse> <Nop>"

Also, to revert to the original setting for middle button click, simply unmap the previous setting.
    :unmap <MiddleMouse>
    :iunmap <MiddleMouse>

Enjoy!

VimTip 565: never see ^M again
http://vim.sourceforge.net/tip_view.php?tip_id=

There have been plenty of tips dealing with ridding of ^M characters
appended to dos text files. However, all of the previous tips involve
some typing. With the following command in your vimrc, you won't have to
type anything. Moreover, you are not likely to see ^M characters again
at all, they get removed before you get to view the file. The only
exception being readonly files.

autocmd BufRead * silent! %s/^M$//

Note: Use <C-V><C-M> to enter ^M and not caret followed by M

VimTip 566: Autocomplete with TAB when typing words
http://vim.sourceforge.net/tip_view.php?tip_id=

"-- Use TAB to complete when typing words, else inserts TABs as usual.
"-- Uses dictionary and source files to find matching words to complete.

"-- See help completion for source,
"-- Note: usual completion is on <C-n> but more trouble to press all the time.
"-- Never type the same word twice and maybe learn a new spellings!
"-- Use the Linux dictionary when spelling is in doubt.
"-- Window users can copy the file to their machine.
"-- http://www.cs.albany.edu/~mosh - Mohsin Ahmed

function! Mosh_Tab_Or_Complete()
    if col('.')>1 && strpart( getline('.'), col('.')-2, 3 ) =~ '^\w'
        return "\<C-N>"
    else
        return "\<Tab>"
endfunction

:inoremap <Tab> <C-R>=Mosh_Tab_Or_Complete()<CR>

:set  dictionary="/usr/dict/words"

VimTip 567: Edit a temporary copy of the current file
http://vim.sourceforge.net/tip_view.php?tip_id=

" Edit a copy of the current file as $TMP/file-$DATE by pressing 'zs'

:map  zs    :exe "sav $TMP/" . expand("%:t") . strftime("-%Y-%m-%d_%H%M%S")<CR>



VimTip 568: Use temporary tags file when browsing new source.
http://vim.sourceforge.net/tip_view.php?tip_id=

" Create and Use $TMP/tags for local source dir (which may be unwriteable)
" Unix users can change c:/tmp to ~/tmp/ (I use $TMP with sh).

:map  <c-k>t  :!(cd %:p:h;ctags -o c:/tmp/tags -R .)&<CR>:set tags^=c:/tmp/tags<CR>

VimTip 569: Insert line numbers or filter thru perl.
http://vim.sourceforge.net/tip_view.php?tip_id=

" Create a menu item to call perl on the file
" Edit the -e "script" before pressing return to filter thru perl
" Script below works shell=sh, and add line numbers to the file.

:amenu Mo1.Format.NumberLines<TAB>:!perl :1,$!perl -ne \"printf(\\"\%3d:\%s\\",\$.,\$_);\"

"
" http://www.cs.albany.edu/~mosh Mohsin

VimTip 570: Align badly formatted text region into table.
http://vim.sourceforge.net/tip_view.php?tip_id=

" What: Aligns badly formatted text into a table.

" How: Select region and press <A-a>,
"    in this case aligns the '=', you decide the centering string
"    before pressing return

" You need the perl script "align" from
"    http://www.cs.albany.edu/~mosh/Perl/align
" Inspired by Emacs align.el
" Works on Windows and Unix.

" Default key Mapping is:

:vmap <A-a> !perl ~/perl/align -c:=

" Example input:
"  x = 1;
"    xyz = 245;
"  a=1;

" Example Output:
"    x = 1;
"  xyz = 245;
"    a = 1;

"



" I know not what; but format in apparel,
" In gait and countenance surely like a father.
" -- BIONDELLO in Taming of Shrew by Shakespeare.

VimTip 571: source ..../vimrc and use ..../tags in an ancestor directory.
http://vim.sourceforge.net/tip_view.php?tip_id=

" Source .../.vimrc and use .../tags in ancestor of source directory.
" useful when you have source tree eight fathom deep,
" an exercise in vim loops.

    let parent=1
    let local_vimrc = ".vimrc"
    let local_tags = "tags"
    while parent <= 8
        if filewritable(local_vimrc)
            echomsg "sourcing " . local_vimrc
            exe ":so " . local_vimrc
        endif
        let local_vimrc = "../". local_vimrc
        let local_tags = "../". local_tags
        exe ":set tags+=".local_tags
        let parent = parent+1
        " ToDo: stop at the root on windows and ~ on unix.
    endwhile
    unlet parent local_vimrc

" Vat be all you, one, two, tree, four, come for?
" -- DOCTOR CAIUS, Windsor, Shakespeare.

" http://www.cs.albany.edu/~mosh - Mohsin.

VimTip 572: auto highlight word under cursor (when reading new code)
http://vim.sourceforge.net/tip_view.php?tip_id=

" Highlight all instances of word under cursor, when idle.
" Useful when studying strange source code.
" Turn on/off with z/ (or key of your choice)

:map z/ :call Mosh_Auto_Highlight_Toggle()<CR>

:function! Mosh_Auto_Highlight_Cword()
    :exe "let @/='\\<".expand("<cword>")."\\>'"
:endfunction

function! Mosh_Auto_Highlight_Toggle()
    :if exists("#CursorHold#*")
    :  au! CursorHold *
    :  let @/=''
    :else
    :  set hlsearch
    :  set updatetime=500
    :  au! CursorHold * nested call Mosh_Auto_Highlight_Cword()
    :endif
endfunction

" There is cold meat i' the cave; we'll browse on that,
" -- GUIDERIUS, in Cymbeline by Shakespeare.

" No occupation; all men idle, all;
" -- GONZALO, Tempest by ShakesPear.

" http://www.cs.albany.edu/~mosh - Mohsin.

VimTip 573: Repeating a substitute from current cursor position
http://vim.sourceforge.net/tip_view.php?tip_id=

The :RS /pattern/subpattern/{flags} command+function as shown
below allows one to repeat a RS-substitute after the current
cursor position.

   Ex.
       cursor starts...
       one two three one two three one two three
       o^here

       :RS /two/TWO/
        one TWO three one two three one two three
        one TWO^cursor ends up here

       move cursor:
        one TWO three one two three one two three
        one TWO three one two ^

       cursor ends up:
        one TWO three one two three one TWO three
        one TWO three one two three one TWO^

   (normally I'd have left the characters preceding the ^ as blanks but I'm
   trying to avoid problems with proportional fonts)

Put the following into your <.vimrc> if you'd like to be able to do this:

" ---------------------------------------------------------------------
" RS: repeat substitution command
com! -range -nargs=* RS call RepeatSubst(<q-args>)

" RepatSubst:
fun! RepeatSubst(subexpr)
  if a:subexpr != ""
   let g:repeatsubst= a:subexpr
  endif
  let curcol= col(".")
  let sep   = strpart(g:repeatsubst,0,1)
  let pat   = substitute(g:repeatsubst,'^.\(.\{-}\)'.sep.'.*$','\1','')
  s/\%#./\r&/
  let curcol= curcol + matchend(getline("."),pat)
  exe "s".g:repeatsubst
  norm! k
  j!
  exe 'norm! '.curcol.'|'
endfun
" ---------------------------------------------------------------------

VimTip 574: delete/move matching paragraphs/lines
http://vim.sourceforge.net/tip_view.php?tip_id=

" Put these in .vimrc, and these four items will become menu items.
" You can of course just type these one liners, if you don't have menus.
" Edit /word/ before pressing return,
" Note: /word/ can be any perl expression to select paras.

:amenu Mo1./.Delete-Matching-Paras<tab>:1,$!perl :1,$! perl -0000lne 'print if m/word/'

:amenu Mo1./.Delete-Matching-Lines<TAB>:g//d     :g//d<CR>
:amenu Mo1./.Delete-Non-Matching-Lines<TAB>:v//d :v//d<CR>

:amenu Mo1./.Move-Matching-Lines-Top<TAB>g//\.m0     ma:g// .m0<CR>`a
:amenu Mo1./.Move-Non-Matching-Lines-Last<TAB>v//\.m$ ma:v// .m$<CR>`a

" - Mohsin Ahmed http://www.cs.albany.edu/~mosh

" > To match thy goodness? My life will be too short,
" > And every measure fail me. -- Cordelia, King Lear 4.7

VimTip 575: chop long lines.
http://vim.sourceforge.net/tip_view.php?tip_id=

" Some regexp substitutions for your menus from .vimrc

:amenu Mo1.Format.ChopLongLines         :%s!\(.\{-80,}\)\s!\1<C-v>\r!gc

:amenu Mo1.Format.JoinHypenatedLines    :%s,\v\s+(\w+)-\n(\s*)(\S+)\s*, \1\3^M\2,gc

:amenu Mo1.Format.JoinBackSlashLines    :%s,\\\n,,gc

" - Mohsin Ahmed http://www.cs.albany.edu/~mosh
" > How now, how now, chop-logic! What is this? - Capulet, R & Juliet 3.5, WS.

VimTip 576: one call to generate all unicode "characters" from within vim
http://vim.sourceforge.net/tip_view.php?tip_id=

This is a small function to generate all unicode "characters".
It might be interesting to those who are familiar with CJK.

I modified Frank's idea, http://groups.yahoo.com/group/vim/message/43907,
with a neat format. (Thank you, Frank)

Tony Mechelynck offered a great tip as how to work with utf-8 in
http://vim.sourceforge.net/tip_view.php?tip_id=246

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
function! GenerateUnicode()
  let i = 0
  while i <= 16*16*16*16
    let n = i
    let j = 0
    let h = ""
    while n
       let h = '0123456789ABCDEF'[n%16].h
       let n = n/16
    endwhile
    let c = h.' '
    while j<16
      let u = i+j
      let c = c.nr2char(u).' '
      let j = j+1
    endwhile
    $put = c
    let i = i+16
    if (i%(16*16) == 0)
      $put='----------------------------------------------------'
      $put='     0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F '
      $put='----------------------------------------------------'
    endif
  endwhile
endfunction
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

VimTip 577: Access vim@vim.org using Newsgroup Reader
http://vim.sourceforge.net/tip_view.php?tip_id=

For some reason one may not prefer mailling lists over usenet newsgroups (like me).

IMHO Newsgroup reader is a lot more versatile and easy to use. So, find a newsgroup equivalent for vim@vim.org is improtant for newsgreoup users. Unfortunately, the comp.editors on USENET is not as active as vim@vim.org.

The non-official news server news.gmane.org, have a mirror to vim@vim.org, named gmane.editors.vim, the maillist vim@vim.org and newsgroup gmane.editors.vim seemed to be syncronised together.

To access the gmane news, just new an account with the NNTP server news.gmane.org, then find the newsgroup gmane.editors.vim, then you can enjoy vim@vim.org with your favorate news reader program, and without messing up mailling list messages with your private e-mail client (which is what the newsgroup designed for).

I think gmane.editors.vim should be highly recommended for newsgoup users.

VimTip 578: Specify Range with search patterns
http://vim.sourceforge.net/tip_view.php?tip_id=

I was recently using sed to pull out multi-line fields with sed when I wondered if I could specify a range using two search patterns in vim as I can in sed.  Sure enough it works.  I am using 6.1 and do not know if this feature is new but I suspect it  has probably been around.

Here is a contrived example.  Suppose I had a vim script I was editing and I want to comment out the function declaration of a function named My_func.  Instead of searching for it, marking the range and then adding a comment to the start of the line, the following command will work:

:/^ *function *My_funct\>/,/^ *endfunction/s/^/" /

The range is specified by two patterns.  For the start of the range I look for the line which contains function My_funct.  I added the \> end of word delimeter to the pattern in case I had other functions that had names beginning with My_func.

The end of the range will be the first occurance of the second pattern, /^ *endfunction/ starting from where the first pattern was matched.

The two patterns are separated with a comma as any range would be and the command to perform on the range follows.  In this case a substitution, s/^/: / but it could be any command.

This has become useful and even though I have used vim for several years this was a new discovery for me.

VimTip 579: Cut&Paste without too much newlines, eg. into WORD
http://vim.sourceforge.net/tip_view.php?tip_id=

Sometimes I am forced to enter text into MS Word. Since this tool is not
reliable and fast enough for me, I often prefer to create the text in
VIM before and cut&paste it into Word.
Unfortunately, Word creates newlines of its own and regards entered
newlines as paragraphs. So I created a mapping that deletes all single
newlines from a selected area but keeps multiple ones. Here it is:

vmap <C-C> "+y:let @+ = substitute(@+, "\n\n\n*", "±", "g")
	\\|:let @+ = substitute(@+, "\n", " ", "g")<CR>
	\\|:let @+ = substitute(@+, "±", "\\n", "g")<CR>
	\\|'<

Just shortly what is does:
Copy the visual area into the selection register +, subsitute two and
more newlines but a strange symbol hopefully not contained in the area
(±), substitute single newlines by a blank and resubstitute the strange
symbol by one newline, then go back to the beginning of the selected area.

If you select now text in VIM with V, it is copied with <Ctrl-C> as
described and can be pasted normally into another application.

Siegfried

VimTip 580: Switching back and forth between ViM and Visual Studio .NET
http://vim.sourceforge.net/tip_view.php?tip_id=

This tip is for when you work on a devstudio project and need the debugger heavily and/or can't stay in ViM all the time. But when it comes time to make changes you want to do them in ViM and don't want to relocate the file and line number.

After you have made the change and perhaps opened another file or navigated your way to a new section of the code you want to switch back to devstudio at the spot you were in ViM. It may be because you want to set a breakpoint or any reason.

The easy part:
Launching ViM from DevStudio.NET is easy.

From the DevStudio menu item Tools|External Tools...  add a new entry where:
The "Command Line" field is set to the path of the ViM executable
The "Arguments" field contains: --servername gmain --remote-silent +$(CurLine) +"normal zz" $(ItemPath)
The "Initial Directory" may optionally contain: $(ItemDir)

This will start a ViM session or connect to an already existing one (--remote-silent) named gmain (--servername gmain). This will use only one instance of ViM for all devstudio editing. It will open the file specified by $(ItemPath) and set the cursor pos to $(CurLine). It will also execute the normal command zz to center the cursor.

You can then create a keyboard shorcut to map to this tool (Tools|Options||Environment|Keyboard, select Tools.ExternalCommandX) and you will be able to switch to ViM quickly.

The hard part:
Opening a file in an existing DevStudio.NET instance is a pain and setting the cursor to a line number is even more so.

DevStudio cannot be controlled by the command line. To open a file in an existing instance a DDE call must be initiated. Its an old and obsolete technology called Dynamic Data Exchange used for interprocess communication. When you click on a .cpp file in the Windows Explorer it calls devenv.exe with the /DDE switch (its undocumented) and sends it an Open DDE command. You can see it for yourself if you look at the file type mapping of .cpp in the Windows Explorer (if you haven't already changed them to open ViM :-)). The Explorer shell is DDE enabled but I found no way to send DDE from the command line (I didn't really look for it either ;-)). So I wrote a small C++ console app from the code I got from an Experts Exchange question. I formatted the code, renamed references from DevStudio to DevEnv and put it in a project.

Setting the line number is a different problem. I wrote a Perl script using the Win32::GuiTest module. This module allows interacting with the Windows GUI and provides a very useful function called SendKeys. The script finds the Visual C++ window (if you are using a different language change the script) and sends it: a CTRL-G, the current line number as specified on the command line and ENTER.

It is integrated in ViM by a function (in _vimrc) that gets the current file name and line number and silently executes the script:
function! DevEnvDDE()
	let cmd = '!devenvdden.pl %:p ' . line(".")
	silent execute cmd
endfunction

All that is left is to map the function to a key.

You can get the source files for the Perl script and DDE project at http://dunderxiii.tripod.com/vimtips/devenvdde.zip
The original DDE code was taken at http://www.experts-exchange.com/Programming/Programming_Platforms/Win_Prog/Q_20489782.html
Win32::GUITest is located at http://groups.yahoo.com/group/perlguitest/

VimTip 581: Using vim to view source and edit textarea in mozilla/firebird
http://vim.sourceforge.net/tip_view.php?tip_id=

This is the feature I have dreamed for months, please refer to
http://mozex.mozdev.org

VimTip 582: Quick way to write to your file.
http://vim.sourceforge.net/tip_view.php?tip_id=

Put this in your .vimrc
map , :w^M

When you need to save your file instead of typing :w and hitting enter, just hit the comma (,) Note that with vim you may need to type CTRL-Q first to get the verbose CTRL-M character in your file.  For those who have earlier versions or non-PC compatible, CTRL-V before CTRL-M will get that character in there.  Has been life-changing for me :-).  I can't take the credit as I found this one years back when scanning info about building html pages.  The author had a little script that checked the update of the file and sent a message to the browser to re-read the file when the file was written.  He's the one who suggested mapping an unmapped button to do this.

VimTip 583: Vim as XML Editor
http://vim.sourceforge.net/tip_view.php?tip_id=

If Vim is your main text editor, and if you do a lot of XML editing, then this mini howto might help you to make that even more fun:

Vim as XML Editor
http://www.pinkjuice.com/howto/vimxml/

VimTip 584: Awesome text formatter
http://vim.sourceforge.net/tip_view.php?tip_id=

The berkeley program 'par' can format/justify
text/c-comments (examples below) better (and much more) than
the default unix formatters.

Download from: http://www.cs.berkeley.edu/~amc/Par/

Usage:

Select region and press <A-q> to format.
In ~/_vimrc put (-j is for justify lines)

  :set formatprg=par\ -w60
  : map <A-q> {v}!par -jw60<CR>
  :vmap <A-q> !par -jw60<CR>

Examples from par.man

    Before:

        /*   We the people of the United States, */
        /* in order to form a more perfect union, */
        /* establish justice, */
        /* insure domestic tranquility, */
        /* provide for the common defense, */
        /* promote the general welfare, */
        /* and secure the blessing of liberty */
        /* to ourselves and our posterity, */
        /* do ordain and establish the Constitution */
        /* of the United States of America. */

    After "par -59":

        /*   We the people of the United States, in      */
        /* order to form a more perfect union, establish */
        /* justice, insure domestic tranquility, provide */
        /* for the common defense, promote the general   */
        /* welfare, and secure the blessing of liberty   */
        /* to ourselves and our posterity, do ordain     */
        /* and establish the Constitution of the United  */
        /* States of America.                            */

    Or after "par -59f":

        /*   We the people of the United States,  */
        /* in order to form a more perfect union, */
        /* establish justice, insure domestic     */
        /* tranquility, provide for the common    */
        /* defense, promote the general welfare,  */
        /* and secure the blessing of liberty to  */
        /* ourselves and our posterity, do ordain */
        /* and establish the Constitution of the  */
        /* United States of America.              */

    Or after "par -59l":

        /*   We the people of the United States, in      */
        /* order to form a more perfect union, establish */
        /* justice, insure domestic tranquility,         */
        /* provide for the common defense, promote       */
        /* the general welfare, and secure the           */
        /* blessing of liberty to ourselves and our      */
        /* posterity, do ordain and establish the        */
        /* Constitution of the United States of America. */

    Or after "par -59lf":

        /*   We the people of the United States,  */
        /* in order to form a more perfect union, */
        /* establish justice, insure domestic     */
        /* tranquility, provide for the common    */
        /* defense, promote the general welfare,  */
        /* and secure the blessing of liberty     */
        /* to ourselves and our posterity, do     */
        /* ordain and establish the Constitution  */
        /* of the United States of America.       */

    Or after "par -59lft0":

        /*   We the people of the United States,         */
        /* in order to form a more perfect union,        */
        /* establish justice, insure domestic            */
        /* tranquility, provide for the common           */
        /* defense, promote the general welfare,         */
        /* and secure the blessing of liberty            */
        /* to ourselves and our posterity, do            */
        /* ordain and establish the Constitution         */
        /* of the United States of America.              */

    Or after "par -59j":

        /*   We  the people  of  the  United States,  in */
        /* order to form a more perfect union, establish */
        /* justice, insure domestic tranquility, provide */
        /* for the  common defense, promote  the general */
        /* welfare, and  secure the blessing  of liberty */
        /* to ourselves and our posterity, do ordain and */
        /* establish  the  Constitution  of  the  United */
        /* States of America.                            */

    Or after "par -59jl":

        /*   We  the   people  of  the   United  States, */
        /* in   order    to   form   a    more   perfect */
        /* union,  establish  justice,  insure  domestic */
        /* tranquility, provide for  the common defense, */
        /* promote  the  general   welfare,  and  secure */
        /* the  blessing  of  liberty to  ourselves  and */
        /* our  posterity, do  ordain and  establish the */
        /* Constitution of the United States of America. */

    Before:

        Preamble      We the people of the United States,
        to the US     in order to form
        Constitution  a more perfect union,
                      establish justice,
                      insure domestic tranquility,
                      provide for the common defense,
                      promote the general welfare,
                      and secure the blessing of liberty
                      to ourselves and our posterity,
                      do ordain and establish
                      the Constitution
                      of the United States of America.

    After "par -52h3":

        Preamble      We the people of the United
        to the US     States, in order to form a
        Constitution  more perfect union, establish
                      justice, insure domestic
                      tranquility, provide for the
                      common defense, promote the
                      general welfare, and secure
                      the blessing of liberty to
                      ourselves and our posterity,
                      do ordain and establish the
                      Constitution of the United
                      States of America.

    Before:

         1  We the people of the United States,
         2  in order to form a more perfect union,
         3  establish justice,
         4  insure domestic tranquility,
         5  provide for the common defense,
         6  promote the general welfare,
         7  and secure the blessing of liberty
         8  to ourselves and our posterity,
         9  do ordain and establish the Constitution
        10  of the United States of America.

    After "par -59p12l":

         1  We the people of the United States, in order to
         2  form a more perfect union, establish justice,
         3  insure domestic tranquility, provide for the
         4  common defense, promote the general welfare,
         5  and secure the blessing of liberty to ourselves
         6  and our posterity, do ordain and establish the
         7  Constitution of the United States of America.

    Before:

        > > We the people
        > > of the United States,
        > > in order to form a more perfect union,
        > > establish justice,
        > > ensure domestic tranquility,
        > > provide for the common defense,
        >
        > Promote the general welfare,
        > and secure the blessing of liberty
        > to ourselves and our posterity,
        > do ordain and establish
        > the Constitution of the United States of America.

    After "par -52":

        > > We the people of the United States, in
        > > order to form a more perfect union,
        > > establish justice, ensure domestic
        > > tranquility, provide for the common
        > > defense,
        >
        > Promote the general welfare, and secure
        > the blessing of liberty to ourselves and
        > our posterity, do ordain and establish
        > the Constitution of the United States of
        > America.

    Before:

        >   We the people
        > of the United States,
        > in order to form a more perfect union,
        > establish justice,
        > ensure domestic tranquility,
        > provide for the common defense,
        >   Promote the general welfare,
        > and secure the blessing of liberty
        > to ourselves and our posterity,
        > do ordain and establish
        > the Constitution of the United States of America.

    After "par -52d":

        >   We the people of the United States,
        > in order to form a more perfect union,
        > establish justice, ensure domestic
        > tranquility, provide for the common
        > defense,
        >   Promote the general welfare, and secure
        > the blessing of liberty to ourselves and
        > our posterity, do ordain and establish
        > the Constitution of the United States of
        > America.

    Before:

        # 1. We the people of the United States.
        # 2. In order to form a more perfect union.
        # 3. Establish justice, ensure domestic
        #    tranquility.
        # 4. Provide for the common defense
        # 5. Promote the general welfare.
        # 6. And secure the blessing of liberty
        #    to ourselves and our posterity.
        # 7. Do ordain and establish the Constitution.
        # 8. Of the United States of America.

    After "par -37p13dh":

        # 1. We the people of the
        #    United States.
        # 2. In order to form a more
        #    perfect union.
        # 3. Establish justice,
        #    ensure domestic
        #    tranquility.
        # 4. Provide for the common
        #    defense
        # 5. Promote the general
        #    welfare.
        # 6. And secure the blessing
        #    of liberty to ourselves
        #    and our posterity.
        # 7. Do ordain and establish
        #    the Constitution.
        # 8. Of the United States of
        #    America.

    Before:

        /*****************************************/
        /*   We the people of the United States, */
        /* in order to form a more perfect union, */
        /* establish justice, insure domestic    */
        /* tranquility,                          */
        /*                                       */
        /*                                       */
        /*   [ provide for the common defense, ] */
        /*   [ promote the general welfare,    ] */
        /*   [ and secure the blessing of liberty ] */
        /*   [ to ourselves and our posterity, ] */
        /*   [                                 ] */
        /*                                       */
        /* do ordain and establish the Constitution */
        /* of the United States of America.       */
        /******************************************/

    After "par -42r":

        /********************************/
        /*   We the people of the       */
        /* United States, in order to   */
        /* form a more perfect union,   */
        /* establish justice, insure    */
        /* domestic tranquility,        */
        /*                              */
        /*                              */
        /*   [ provide for the common ] */
        /*   [ defense, promote the   ] */
        /*   [ general welfare, and   ] */
        /*   [ secure the blessing of ] */
        /*   [ liberty to ourselves   ] */
        /*   [ and our posterity,     ] */
        /*   [                        ] */
        /*                              */
        /* do ordain and establish the  */
        /* Constitution of the United   */
        /* States of America.           */
        /********************************/

    Or after "par -42re":

        /********************************/
        /*   We the people of the       */
        /* United States, in order to   */
        /* form a more perfect union,   */
        /* establish justice, insure    */
        /* domestic tranquility,        */
        /*                              */
        /*   [ provide for the common ] */
        /*   [ defense, promote the   ] */
        /*   [ general welfare, and   ] */
        /*   [ secure the blessing of ] */
        /*   [ liberty to ourselves   ] */
        /*   [ and our posterity,     ] */
        /*                              */
        /* do ordain and establish the  */
        /* Constitution of the United   */
        /* States of America.           */
        /********************************/

    Before:

        Joe Public writes:
        > Jane Doe writes:
        > >
        > >
        > > I can't find the source for uncompress.
        > Oh no, not again!!!
        >
        >
        > Isn't there a FAQ for this?
        >
        >
        That wasn't very helpful, Joe. Jane,
        just make a link from uncompress to compress.

    After "par -40q":

        Joe Public writes:

        > Jane Doe writes:
        >
        >
        > > I can't find the source for
        > > uncompress.
        >
        > Oh no, not again!!!
        >
        >
        > Isn't there a FAQ for this?
        >

        That wasn't very helpful, Joe.
        Jane, just make a link from
        uncompress to compress.

    Or after "par 40qe":

        Joe Public writes:

        > Jane Doe writes:
        >
        > > I can't find the source for
        > > uncompress.
        >
        > Oh no, not again!!!
        >
        > Isn't there a FAQ for this?

        That wasn't very helpful, Joe.
        Jane, just make a link from
        uncompress to compress.

    Or after "par -40qi":

        Joe Public writes:
        > Jane Doe writes:
        > >
        > >
        > > I can't find the source for
        > > uncompress.
        > Oh no, not again!!!
        >
        >
        > Isn't there a FAQ for this?
        >
        >
        That wasn't very helpful, Joe.
        Jane, just make a link from
        uncompress to compress.

    Or after "par -40qie":

        Joe Public writes:
        > Jane Doe writes:
        > > I can't find the source for
        > > uncompress.
        > Oh no, not again!!!
        >
        > Isn't there a FAQ for this?
        That wasn't very helpful, Joe.
        Jane, just make a link from
        uncompress to compress.

    Before:

        I sure hope there's still room
        in Dr. Jones' section of archaeology.
        I've heard he's the bestest.  [sic]

    After "par -50g":

        I sure hope there's still room in
        Dr. Jones' section of archaeology.  I've
        heard he's the bestest. [sic]

    Or after "par -50gc":

        I sure hope there's still room in
        Dr. Jones' section of archaeology.  I've
        heard he's the bestest.  [sic]

    Before:

        John writes:
        : Mary writes:
        : + Anastasia writes:
        : + > Hi all!
        : + Hi Ana!
        : Hi Ana & Mary!
        Please unsubscribe me from alt.hello.

    After "par Q+:+ q":

        John writes:

        : Mary writes:
        :
        : + Anastasia writes:
        : +
        : + > Hi all!
        : +
        : + Hi Ana!
        :
        : Hi Ana & Mary!

        Please unsubscribe me from alt.hello.

    Before:

        amc> The b option was added primarily to deal with
        amc> this new style of quotation
        amc> which became popular after Par 1.41 was released.
        amc>
        amc> Par still pays attention to body characters.
        amc> Par should not mistake "Par" for part of the prefix.
        amc> Par should not mistake "." for a suffix.

    After "par B=._A_a 50bg":

        amc> The b option was added primarily to
        amc> deal with this new style of quotation
        amc> which became popular after Par 1.41
        amc> was released.
        amc>
        amc> Par still pays attention to body
        amc> characters.  Par should not mistake
        amc> "Par" for part of the prefix.  Par
        amc> should not mistake "." for a suffix.




VimTip 585: Keymap for normal mode
http://vim.sourceforge.net/tip_view.php?tip_id=

I generated a keymap for the vim 6.X normal mode on a german keyboard layout.
Keymaps for other layouts may follow, if someone tells me about how they look.
The keymap is here:
http://michaelsen.kicks-ass.net/bjoern/keymap.pdf

The author may be contacted here:
bjoern@michaelsen.kicks-ass.net

VimTip 586: Smarter Pasting
http://vim.sourceforge.net/tip_view.php?tip_id=

Frequently I yank a few words or part of a line and like to have them pasted on a separate line. Vim provides the put and put! commands for that purpose but they are not mapped by default to anything.  Typing the commands is much slower than inserting a line and pasting to it so I have created the following maps:

nnoremap ,p :pu "<CR>
nnoremap ,P :pu! "<CR>

VimTip 587: Preview current file in Mozilla through localhost
http://vim.sourceforge.net/tip_view.php?tip_id=

This is something I 'discovered'  whilst trying to preview html or php files in mozilla using the apache server locally.

Put the path as the first line of a file wrapped in the appropriate comments.
eg: php:
<?php	// http://localhost/examples/chapter02/vieworders2.php	?>
eg html:
<!-- http://localhost/examples/chapter02/orderform.html -->

Place the following mappings in your .vimrc file
" Typing <S-F12> will open the file in moz through the server.
nmap <S-F12> :sil! !start mozilla "<cfile>"<CR>
imap <S-F12> <esc>:sil! !start mozilla "<cfile>"<CR>i

As I'm working through Wellings PHP and MySQL Web Development I can use my tokens plugin to speed creating the first line as follows:


Add these as the string parts of the array:
(for php)
"phpf <?php	// http://localhost/examples/chapter¤«  chapter?   »/¤«  file name  ».php  ?>"
(for html)
"htmlf <!--  http://localhost/examples/chapter¤«  chapter?   »/¤«  file name  ».html  -->"

then on the first line of the file if I type phpf <leader>et I'll only have to enter the chapter number and the filename without the extension. eg    04<cr>  orders<cr>
This will insert:
<?php	// http://localhost/examples/chapter04/orders.php	?>

Place the cursor anywhere on the file path, <S-F12> and the file will load (through apache) in moz.

Hope someone finds this useful,
Mark

VimTip 588: How to sort using visual blocks
http://vim.sourceforge.net/tip_view.php?tip_id=

1. To sort lines based on a visually-selected column:

	Check out
	http://www.erols.com/astronaut/vim/index.html#VimFuncs ;
	look under "Visual Block Sorting".  It uses Piet Delport's
	vim-based binary insertion sort and some vim-glue to provide
	visual-block sorts!

	To enable it, put <bisort.vim> into your <.vim/plugin>
	directory.

	To then perform sorting based on a visual-block selection
	(ctrl-v):

		:'<,'>Vissort

2. To sort a visually-selected block (and leave the text outside the
   block in place):

	Check out
	http://www.erols.com/astronaut/vim/index.html#VimFuncs ;
	look under "Visual Block Commands".  The <vis.vim> plugin
	provides a command which allows other commands to be applied
	only to the visually selected block.

	To then perform sorting of just a visual-block (ctrl-v):

		:'<,'>B !sort

	Or, using Piet Delport's binary insertion sort:

		:'<,'>B Bisort

Examples:

	Original, visual-block select the central column
		one   two    three
		four  five   six
		seven eight  nine
		ten   eleven twelve

	:'<,'>Vissort
		seven eight  nine
		ten   eleven twelve
		four  five   six
		one   two    three

	:'<,'>B !sort
		one   eight  three
		four  eleven six
		seven five   nine
		ten   two    twelve

	:'<,'>B Bisort
		one   eight  three
		four  eleven six
		seven five   nine
		ten   two    twelve

VimTip 589: Vim as refactoring tool (with examples in C#)
http://vim.sourceforge.net/tip_view.php?tip_id=

You can use vim as a refactoring tool.

The advantages are:

1. You automatisate repetitive writing tasks
2. You learn refactoring

You can expect much from a refactoring tool but if you have a look at the
commercial refactoring tools there is much (not all!) vim can do too.

Whatever your opinion is, my experience is that vim helps to refactor.

I give you three examples, all in C#.

Example 1:

Anti-sphagetti code weapon or the "Extract Method" refactoring.

Sphagetti code example:

public string CreateMenu(string startMenu,string file)
{
	string strOutput = "";
	int i = 0;
	ArrayList startArray = new ArrayList();
	string strVariable = "";
	string strTemp = "";

	XmlDocument XMLDoc = new XmlDocument();
	try {
		XMLDoc.Load(file);
	}
	catch (Exception e)
	{
		strOutput = e.GetBaseException().ToString();
		return strOutput;
	}

	XmlNodeList nodeList = XMLDoc.DocumentElement.ChildNodes;

	...


Imagine 50 lines of code here.

Use the "extract method refactoring" to make a "composed method".

I use a vim function (see below) to build the exracted method.

I highlight the code part I want to extract and press \em (for e-xtract m-ethod).

A dialog appears and asks me how to name the new method.

I type in "GetXmlDocumentFrom" and do get this:

// = GetXmlDocumentFrom();
private GetXmlDocumentFrom()
{
	XmlDocument XMLDoc = new XmlDocument();
	try {
		XMLDoc.Load(file);
	}
	catch (Exception e)
	{
		strOutput = e.GetBaseException().ToString();
		return strOutput;
	}
	// return ;
}

Now I have time to think what parameters the method needs and what to return.

I end up with the following function and  remove it from the original function:

private XmlDocument GetXmlDocumentFrom(string XmlFile)
{
	XmlDocument XMLDoc = new XmlDocument();
	string strOutput = "";
	try
	{
		XMLDoc.Load(XmlFile);
	}
	catch (Exception e)
	{
		strOutput = e.GetBaseException().ToString();
		ErrorMessage(strOutput);
	}
	return XMLDoc;
}

In the original code I put two lines.

XmlDocument XMLDoc = new XmlDocument();
XMLDoc = GetXmlDocumentFrom(XmlFile);

So I reduced the original code for 8 lines and made it clearer what the code does.

I do this with the rest of the code again and again.

Since the class gets bloated because of the many new methods I later will use
the "Extract Class" refactoring to put this method in an own XmlDocument-class.

This has the advantage that our new function is also available for other
similar purposes.

I will create the new class also with the help of vim, the actual extracting of
the method into the new class is just a matter of copy & paste.

Here is the vim-code:

vmap \em :call ExtractMethod()<cr>
function! ExtractMethod() range
	let name = inputdialog("Name of new method:")
	'<
	exe "normal O\<bs>private " . name ."()\<cr>{\<esc>"
	'>
	exe "normal oreturn ;\<cr>}\<esc>k"
	s/return/\/\/ return/ge
	normal j%
	normal kf(
	exe "normal yyPi// = \<esc>wdwA;\<esc>"
	normal ==
	normal j0w
endfunction

Example 2:

The "Self Encapsulate Field" refactoring.

I have heard a programmer who just uses Visual Studio (nothing against Visual
Studio, it's a great tool!) say: "I do not use properties. It's too much
work." He just uses fields instead.

With vim it is no problem to write a property, id est to use the "Self
Encapsulate Field" refactoring.

I write a name e.g. "Name" press CTRL-C CTRL-P CTRL-S (c-reate p-roperty with
s-tring).  Voila, the new property appears in just a second:

private string m_Name;
public string Name
{
	get
	{
		return m_Name;
	}
	set
	{
		m_Name = value;
	}
}

Here are the vim mappings and the underlying function:

"Create property
imap <C-c><C-p><C-s> <esc>:call CreateProperty("string")<cr>a
imap <C-c><C-p><C-i> <esc>:call CreateProperty("int")<cr>a

function! CreateProperty(type)
	exe "normal bim_\<esc>b\"yywiprivate ".a:type." \<esc>A;\<cr>public ".a:type." \<esc>\"ypb2xea\<cr>{\<esc>oget\<cr>{\<cr>return \<esc>\"ypa;\<cr>}\<cr>set\<cr>{\<cr>\<tab>\<esc>\"yPa = value;\<cr>}\<cr>}\<cr>\<esc>"
	normal 12k2wi
endfunction

You can combine Visual Studio and vim. You can work in Visual Studio and load
the file in vim for refactoring. I have made a menu entry in Visual Studio that
loads the actual file I am writing in vim (cf. Tip #580 http://vim.sourceforge.net/tips/tip.php?tip_id=580).

Example 3:

The "Replace Conditional with Polymorphism" refactoring.

Imagine a switch and you want to replace it with an abstract class and some
concrete classes which inherit from this parent class.

You may think "Why should I replace this switch? It's too much work. Writing
all these classes ..."

With vim it's just a question of a few seconds.

To build the abstract class  I type, say  "Fruit".
Then I press CTRL-C CTRL-A CTRL-C (c-reate a-bstract c-lass) and get

public abstract class Fruit
{
	public abstract void |();
}

| means the Cursor position.

Now I fill in the methods.

public abstract class Fruit
{
	public abstract void Taste();
	public abstract void Color();
	public abstract string GetSize();
}

Now I go on the first letter of "Fruit" and type CTRL-C CTRL-C CTRL-C (c-reate c-oncrete c-lass).

A dialog appears and asks me for the new name of the concrete class. I type in Apple and get

public class Apple : Fruit
{
	public override void Taste()
	{
	}

	public override void Color()
	{
	}

	public override string GetSize()
	{
	}
}

I continue doing so with all the child classes of the abstract class.
In this way I get code templates that I can implement now.

Here are my mappings and the underlying funtion.

"Create abstract class
imap <C-c><C-a><C-c> <esc>bipublic abstract class <esc>A<cr>{<cr>public abstract void X();<cr>}<esc>:?X<cr>0fXs
"Create concrete class
map <C-c><C-c><C-c> :silent! call ImplementAbstractClass()<cr>

function! ImplementAbstractClass() range
	exe "normal \<esc>\"yyw"
	/{
	normal "xy%
	normal %o
	exe "normal \<esc>o"
	let name = inputdialog("Name of new method:")
	exe "normal ipublic class " .name." : \<esc>\"yp\"xp"
	exe "normal }O}\<esc>=="
	normal %v%
	normal gv
	'<,'>s/abstract/override/g
	normal gv
	'<,'>s/;/\r{\r}\r/g
	normal ==
	normal %kdd%k
endfunction

Happy vimming ... and happy refactoring!

Klaus

VimTip 590: Using vim to send mail on windows
http://vim.sourceforge.net/tip_view.php?tip_id=

The question of using Vim for writing email messages with
Vim on windows was raised many times.

Finally there *is* an elegant solution.

go to
http://sylpheed-claws.sourceforge.net/win32/
and download
sylpheed-0.9.6claws.exe
Install an application

go to menu
configuration -> Common preferences
go to tab Other
and fill something like
c:\Progra~1\Vim\vim62b\gvim.exe -f "%s"
(depending on where your Vim is installed)
as the the editor option
The -f option is very important so Vim does not fork.

You might also go to Compose tab and select
Automatically launch an external editor.

Tada.......

Beware
Sylphed-Claws is a bleeding edge software.

Have a nice time
Stano

VimTip 591: Have a nice and easy use of plugins
http://vim.sourceforge.net/tip_view.php?tip_id=

Are you tired of hundreds of mappings and functions that pollute your .vimrc ? Do you want to
nicely organize your customization to quickly find what you search ? Perhaps is it time for you to
consider the use of plugins (if it is not already done).

Plugins are really easy to do and provide a simple way to organize functions and mappings. They are
automaticaly loaded

Here is an example of simple and very short plugin that provides a command MyCommand that saves the
selected text in the file passed in parameter.
I don't know if the function is useful but the example show the parameter passing, the
autocompletion and the use of ranges in a function.

Autocompletion is very practical to help to remember the commands you defined. It is often a
problem to remember all the mappings you've done so it may be faster to type your command than to
remember the mapping you've chosen.
Using user-commands allows you to use mappings only when it is absolutely pertinent

------------------ file MyPlugin.vim -----------------------
" save 'cpo'
let s:cpo_save = &cpo
set cpo&vim

" To Edit the Plugin
nnoremap <F12> :e $VIMRUNTIME/plugins/MyPlugin.vim
" To reload the plugin if you modify it
nnoremap <S-F12> :so $VIMRUNTIME/plugins/MyPlugin.vim

" It is very interesting to define commands to call your functions because you can then use
" autocompletion and other features you cannot use for usual functions
if !exists(':MyCommand')
    command -range=% -nargs=1 -complete=file MyCommand <line1>,<line2>call s:MyCommandFunction(<f-args>)
endif

" the ! allows you to modify the function and reload the plugin. It will be your new version that
" will be considered
function! s:MyCommandFunction(...) range
    split
    execute "norm " . a:firstline . "GV"
    execute "norm " . a:lastline . 'G"ay'
    enew
    norm "ap
    exe "sav! " . a:1
    q
endfunction

" restore 'cpo'
let &cpo = s:cpo_save
unlet s:cpo_save
---------------------End of file --------------------------

commented version of the function :

function! s:MyCommandFunction(...) range
    " create a temporary window
    split
    " select and copy the lines in the range passed (a:firstline and a:lastline are the vim
    " variables for the first and the last lien of the range
    execute "norm " . a:firstline . "GV"
    execute "norm " . a:lastline . 'G"ay'
    " create a new file and paste
    enew
    norm "ap
    " saves the file with the name passed in parameter
    " exe executes the string passed as a command
    " a:1 is the first parameter (if you have more, a:2, a:3. a:0 gives you the number of parameter
    " passed
    exe "sav! " . a:1
    " quit the temporary window
    q
endfunction

Of course you can separate your functions in different plugins (one for the mapping, one for the
functions...
You can use prefix to classify your functions and use the autocompletion more efficiently.

Where to find help on these subjects

General considerations on plugins
:help plugins

How to create a user-command and how to use the parameters (-range, -nargs, -complete...)
:help user-commands

How to program vim
:help eval.txt

all the buildin functions
:help functions
How to define a function
:help user-functions

VimTip 592: Smart <Home> and <End> keymaps
http://vim.sourceforge.net/tip_view.php?tip_id=

I found interesting the way <Home> and <End> keys act in some editors and I wondered why try not
carry it out with Vim.
Put the following lines in your ~/.vimrc and so <Home> will move the cursor between the first column and
the first non-blank character. <End> is similar but work at the end of the line.
I think this should be very useful to the indented code and trailing characters.

let g:home_key = '0'
let g:end_key = '$'

function ToggleHome()
  exe "normal! \<Esc>".g:home_key
  let g:home_key = g:home_key == '0'? '^' : '0'
endfunction

function ToggleEnd()
  exe "normal! \<Esc>".g:end_key
  let g:end_key = g:end_key == '$'? 'g_' : '$'
endfunction

inoremap <silent> <Home> <Esc>:call ToggleHome()<CR>i
nnoremap <silent> <Home> :call ToggleHome()<CR>
inoremap <silent> <End> <Esc>:call ToggleEnd()<CR>a
nnoremap <silent> <End> :call ToggleEnd()<CR>

VimTip 593: basic postfix abbreviations
http://vim.sourceforge.net/tip_view.php?tip_id=

     I'm learning VIM in order to be more competitive in online programming competitions where speed of accurate typing is a factor. This may be a basic tip for some more advanced VIM users out there. I'm very used to editors that provide prefix abbreviation expansion; for example, in jEdit I'd type FA,array,<C-ENTER> in order to make a basic for loop that scanned the array. I wanted this in VIm as well, but found that it was harder to program. When I discovered that I could use a postfix abbreviation instead of a prefix one, I realized that I really didn't need any programming, but rather a long :ab statement like this:

"this is for java, c++,c# can reshape as necessary
:ab ff <ESC>^d$ifor(int i=0;i<<ESC>pi.length;i++){<CR><CR>}//end for loop over array <ESC>pi[i]<ESC>==k==k==ji<TAB>

this way, if I need a loop over the array lines[] then I would type
lines<SPACE>ff<SPACE> and vim would transform this into (with proper indentation)

for(int i=0;i<lines.length;i++){
        <CURSOR>
}//end for loop over array lines[i]

similar abreviations with multiple arguments could be delimited by spaces and could be yanked into multiple registers and plunked down as necessary. You could even use a similar structure to writing abbreviations in jEdit. But, this opens up possibilities for many different things, because VIM allows you to map real commands into the abbreviations, instead of just vanilla text like in jEdit.

VimTip 595: suppressing file changed warnings in a specific buffer
http://vim.sourceforge.net/tip_view.php?tip_id=

I generally liked the warnings that VIM gives when a file changes outside of the editor. However, there are times when I want to run a shell command that changes the buffer, and I don't want to hear about it.

I've come up with the following convoluted method to do this, but if there's a better way, I'd love to know.

function ChangeThisBuffer
    "set an environment variable to current buffer name
    let $aucfile = expand( "%" )
    "add autocmd which only applies to this buffer which removes itself once it runs once
    autocmd FileChangedShell $aucfile autocmd! FileChangedShell $aucfile
    execute( 'silent !mycommand' )
endfunction

One problem with this approach is that if the shell command fails, or doesn't really change the file, then you won't be notified the <b>next</b> time it changes.

VimTip 596: Insert location of the currently edited file
http://vim.sourceforge.net/tip_view.php?tip_id=

With
:imap <C-r>@ <C-r>=expand("%:p:h")<cr>

VimTip 597: indet a code block - >i{
http://vim.sourceforge.net/tip_view.php?tip_id=

Let's say we have:
// some code
{ // start block
//some other code
// HERE IS THE CURSOR
// other code
} // end block

The command ">i{" will indent the current block of lines, inside {}.
The { and } are unmodified.
The ">a{" will modify also the { } lines.

"<i{" will shift to the left (let's say UNindent).
Similar "<a{"

Hope this helps.

VimTip 598: (PHP) on line help
http://vim.sourceforge.net/tip_view.php?tip_id=

Hi,
vim is my favorite; so, I use it for .php file.
Very often I need the php manual to see the parametrs order for functions.
Unitl a month ago I always opened a browser and gone to http://http://ro.php.net/FUNCTION_NAME
for example http://ro.php.net/printf .

A month ago I have discovered
set keywordprg=a_script

What it does:
default, when you ar with the cursor on a WORD and press K (SHIFT+k) in `command mode',
the vim will run 'man WORD'.
If you set keywordprg=a_script,  the  vim will run `a_script WORD'

So I have
set keywordprg=/home/marcel/php_doc
and php_doc looks like:
#######
#!/usr/bin/bash
links http://www.php.net/$1
#######
And now I have the online help

`links' is a text browser for *nix, http://links.browser.org/
Of course you can use the `lynx'.

Hope this helps

VimTip 599: vim plugin for clearcase
http://vim.sourceforge.net/tip_view.php?tip_id=

The ccase.vim vim clearcase plugin is very useful. But there is a bug in clearcase, if you are doing multisite development, even if you checkout file unreserved, it still hold the mastership. So your partner on other side still cannot checkin code.

The default unreserved checkout swith on ccase.vim is "-unreserved", need to change to "-unreserved -nma".

VimTip 600: Copy current file name into windows clipboard
http://vim.sourceforge.net/tip_view.php?tip_id=

Sometimes I need to use a file name that I'm editing in other applications (compiling, attaching to e-mail, referencing in document) etc.
I found these two mappings to be useful for copying file name to the windows clipboard.

Inside VIm I do ",cs" or ",cl"  and then simply paste into other document using regular windows paste command. The mappings work in normal mode.
,cs is used to copy just the file name
,cl is used to copy file name including the full path

nmap ,cs :let @*=expand("%")<CR>
nmap ,cl :let @*=expand("%:p")<CR>

VimTip 601: Tag with line:column
http://vim.sourceforge.net/tip_view.php?tip_id=

Tags allow us to jump to a particular line,
but I needed to get to the exact column also,
eg. when I have many tags on one long line.

This is not possible with the tag format, however
with Vim's regexp extensions, I am able to generate
and use such tags, eg:

> tail -1 ./tags

main	mohsin.c	/^\%89l\%12c/ ;" Goto line 89, column 12.

VimTip 602: How to remove one mark or all marks at once
http://vim.sourceforge.net/tip_view.php?tip_id=

To remove a mark you can use \mh in normal mode. Go to the mark and type \mh.

If you are using marks in a script you can use the function below.
Then you would write e.g.

function! MyFunction()
	...
	kl "set mark l
	...
	"do something
	...
	call RemoveMark("l") "Mark l is no longer used, remove it
	...
endfunction

Here is the function:

function! RemoveMark(mark)
	try
		exe "normal '" . a:mark "go to the mark
		normal \mh "remove it
	catch
	endtry
endfunction

If you want to remove all  your marks in normal mode you can use the mapping
map \rm :call RemoveMarks()<cr>

It calls the function:

function! RemoveMarks()
	try
		call RemoveMark("a")
		call RemoveMark("b")
		call RemoveMark("c")
		call RemoveMark("d")
		call RemoveMark("e")
		call RemoveMark("f")
		call RemoveMark("g")
		call RemoveMark("h")
		call RemoveMark("i")
		call RemoveMark("j")
		call RemoveMark("k")
		call RemoveMark("l")
		call RemoveMark("m")
		call RemoveMark("n")
		call RemoveMark("o")
		call RemoveMark("p")
		call RemoveMark("q")
		call RemoveMark("r")
		call RemoveMark("s")
		call RemoveMark("t")
		call RemoveMark("u")
		call RemoveMark("v")
		call RemoveMark("w")
		call RemoveMark("x")
		call RemoveMark("y")
		call RemoveMark("z")
	catch
	endtry
endfunction

Could you think of other possibilities?
Please share it with us.

Note:
I am using the try-catch clause so the following works only for >= vim 6.2.
If you want to use the functions for an older version remove the try-catch
clauses.

Happy vimming

Klaus

VimTip 603: Bookmarks as menu item
http://vim.sourceforge.net/tip_view.php?tip_id=

I like to save location of files I am editing
in a bookmark file. Each bookmark shows up as a
menu item.

Add the attached lines to ~/_vimrc, and the Bookmark->Add
menu items will appeare in gvim (I use it on Windows/NT).

Note: I used cmd.exe,sh.exe,echo.exe to write the bookmark
to a file, it is tricky to get the quotes right.
It would be whole lot easier if vim had a function
append-register-or-string-to-file. Maybe someone can
find a way to do this without external shells?

- Mohsin (mosh.cs.albany.edu)

:set shell=sh shellslash shellcmdflag=-c shellxquote=\" shellpipe=\|\ tee
:amenu Mo2.BookMarks.Add
                \ :let @b='\\042 Bookmark: '.
                \    " DATE=".strftime("%Y-%b-%d_%X").
                \    " PWD=".escape(getcwd(),'\').
                \ escape("\\n",'\').
                \ ":amenu Mo2.BookMarks.".
                \ escape(escape(expand("%:t"),'.\'),'\').
                \ ' :sp +'.line(".").' '.
                \ escape(expand("%:p"),' \')<CR>
                \ :exe ':!(echo '.@b.' >> $HOME/bookmark.vim)'<CR>
                \ :so $HOME/bookmark.vim<CR>

:amenu Mo2.BookMarks.Edit :sp $HOME/bookmark.vim<CR>
:amenu Mo2.BookMarks.Load :so $HOME/bookmark.vim<CR>


if filereadable(expand("$HOME/bookmark.vim"))
    :amenu Mo2.BookMarks.-Sep-	:
    :so $HOME/bookmark.vim
endif




VimTip 604: Doing <enter> in nmode
http://vim.sourceforge.net/tip_view.php?tip_id=

Although very simple, I think this is nifty:

:nmap <enter> _i<enter><esc>

Now one can press enter in normal mode to insert an empty line. This spares me from alot of typing.

VimTip 605: replace a word with the yanked text
http://vim.sourceforge.net/tip_view.php?tip_id=

I often need to replace a word with the yanked text when programming, so I add this map:

map S diw"0P

I rarely use S command, because it's equal to cc.

VimTip 606: Seeing the man pages while being in VIM
http://vim.sourceforge.net/tip_view.php?tip_id=

You can see the man pages of anything you want from VIM. No need to exit VIM. Just put the cursor under the word.and press shift+k (Capital K) and you will be in the man page section. when you are through just press 'q' and you will be out of VIM. Press enter to come back to VIM.

VimTip 607: Opening gvim atop a console window
http://vim.sourceforge.net/tip_view.php?tip_id=

I like to have gvim open atop the current xterm I'm using, rather
like a vim console would.  Here's some Korn shell script for
setting up a function "gv" which queries X for the current window's
geometry and adjusts the window for the current fontsize, borders,
and menu region.

Admittedly the adjustments for that vary with border sizes, etc,
so you'll likely need to adjust x,y,w,h in the Adjustments section.

Usage:  gv files, options, etc

# =======================================
# gv: gvim covers starting console window
function gv
{
if [[ "${WINDOWID}" = "" ]]; then
 echo "***error*** unknown window id!"
 return
fi
xwi=$(xwininfo -id $WINDOWID)
xyposn=${xwi##*Corners:  }
xyposn=${xyposn%% -*}
wh=${xwi##*geometry }
wh=${wh%+0+0}
integer x y w h
x=${xyposn%+[0-9]*}
y=${xyposn#+[0-9]*}
w=${wh%x*}
hh=${wh#*x}
h=${hh%[-+]*}
# ----------------------------
# Adjustments:
#   x,y in pixels
#   w,h in characters
# ----------------------------
# for RH8 Linux, GTK, courier-12-r
h=h-4
x=4
y=y-18
# ----------------------------

# invoke gvim
gvim -geometry "${w}x${h}+${x}+${y}" $*
}
# =======================================

VimTip 608: Evaluate current line (or pease of line) using Python
http://vim.sourceforge.net/tip_view.php?tip_id=

Pyhton language has more powerfull evaluation functions than vim editor. If you have need to evaluate some by python you can use command

:py print 2*2

(see :help :if_pyth.txt)
But I can tell you more pleasant example. Write in your .vimrc file followings:

=== begin paste ========
python << EOL
import vim
# do not say from vim import * beacuse this instraction
# delete builtins function eval
def EvaluateCurrentLine(*args):
	cur_str = vim.current.line
	action, symb = None, None
	for i in args:
		if i in ["r","p"]: action = i
		else:              symb   = i
	try:    start = cur_str.rindex(symb)+len(symb)
	except: start = 0
	result = eval(cur_str[start:],globals())
	if action == "r":
		vim.current.line = cur_str[:start]+str(result)
	else:
		print result
EOL
command -narg=* PyEv python EvaluateCurrentLine(<f-args>)
=== end paste ============

Be carefull about identation in python part. This text provide command
:PyEv
This command evaluate expression in line under cursor and print result in echo area. With r argument
:PyEv r
evaluate expression and replased it by resalt of evaluation. And other arg in argument searching the arg backword from the end of current line and evaluate followed expression. For example: let we have string
\setlength{\textwidth}{450-63
:PyEv r {
\setlength{\textwidth}{387

VimTip 609: Execute python from within current file
http://vim.sourceforge.net/tip_view.php?tip_id=

Inspired by vimtip #608.

To execute python from a range within the current text file and write the output to that file (replacing the python), add the snippet below to .vimrc (or other suitable *rc file).

Requires a 'proper' python setup so that the imported modules can be found.

I find it a handy intermediate step between using the python interpreter on command line and running a complete script. Can be used for easy buffer manipulation, filtering input, preprocessing text and templating-like tasks.

def PyExecReplace(line1,line2):
    r = vim.current.buffer.range(int(line1),int(line2))
    redirected = cStringIO.StringIO()
    sys.stdout = redirected
    exec('\n'.join(r[:]) + '\n')
    sys.stdout = sys.__stdout__
    output = redirected.getvalue().split('\n')
    r[:] = output[:-1] # the -1 is to remove the final blank line
    redirected.close()
EOL
command -range Pyer python PyExecReplace(<f-line1>,<f-line2>)

Some examples of use:
Simple
------
print 2 + 2
:Pyer
(if cursor is on the 'print' line, replaces line with 4)

Filter
------
for line in vim.current.buffer:
    if line[0] != '\t':
        print line
:%Pyer
(filters out lines beginning with a tab in the current buffer)

Inserting time
--------------
import time
print time.ctime()
:%Pyer
(replaces line with date/time)

Getting web content without tags
-------------------------------
import urllib2,htmllib,formatter
h = htmllib.HTMLParser(formatter.AbstractFormatter(formatter.DumbWriter()))
h.feed(urllib2.urlopen('http://www.somesite.com').read())
:%Pyer
(inserts the web page text, but not the html tags, for a given site)

I also use a slightly modified version that appends the output, leaving the python intact.

VimTip 610: Saves you frequent typings of certain words.
http://vim.sourceforge.net/tip_view.php?tip_id=

You can use VIM's autocomplete feature in insert mode. Just edit the .vimrc file and add this lines

iab <key> <expansion>
<key> is the letter which should be expanded to <expansion>

Example:
              iab #i #include          ( typing "#i" and space will be expanded to "#include")
              iab #d #define           ( typing "#d" and spacet will be expanded to "#define")
              iab s struct               (typing  "s" and space will be expanded to "struct")
              iab t typedef           ( typing "t" and space  will be expanded to "typedef")

You can add your custon expansion words.

PITFALLS:
                  In some cases VIM expands a letter automatically you dont want. You have to take care of that. But this is a good utility.

VimTip 611: Open big files and work fast
http://vim.sourceforge.net/tip_view.php?tip_id=

When opening big files, having no swap file and no undo levels speeds up Vim dramatically.  Here are lines to set that up automatically beyond a given file size threshold (BufSizeThreshold):

let g:SaveUndoLevels = &undolevels
let g:BufSizeThreshold = 1000000
if has("autocmd")
    " Store preferred undo levels
    au VimEnter * let g:SaveUndoLevels = &undolevels
    " Don't use a swap file for big files
    au BufReadPre * if getfsize(expand(<afile>)) >= g:BufSizeThreshold | setlocal noswapfile | endif
    " Upon entering a buffer, set or restore the number of undo levels
    au BufEnter   * if getfsize(expand(<afile>)) < g:BufSizeThreshold | let &undolevels=g:SaveUndoLevels | hi Cursor term=reverse ctermbg=black guibg=black | else | set undolevels=-1 | hi Cursor term=underline ctermbg=red guibg=red | endif
endif

Many thanks to Antoine and Chip, and to Ron who triggered the thread on vim@vim.org.

William

PS: I have not done a search for big file handling tips...
PPS: we could also disable syntax highlighting and restore it for small files, but I just thought about it now.

VimTip 612: save a nanosecond with marks
http://vim.sourceforge.net/tip_view.php?tip_id=

Instead of marking all the time with "ma", mark with "ml".  When you need to return to the mark, `l is a little quicker to type than `a.

If you save a fraction of a second many times, you'll have saved as much time as it took to read this tip!

VimTip 613: open last edited file, AKA lvim for bash
http://vim.sourceforge.net/tip_view.php?tip_id=

The starting.txt help file (http://vim.org/htmldoc/starting.html) tells you how to open the last edited file in csh. In bash, do it like so:

alias lvim='vim -c "normal '\''0"'

VimTip 614: perldoc function and module keyboard mappings
http://vim.sourceforge.net/tip_view.php?tip_id=

" put the cursor over a perl function and try backslash-pf to see perldoc
:nmap <Leader>pf :!perldoc -f <cword><CR>

" put the cursor over a perl module name and try backslash-pd to see perldoc
:nmap <Leader>pd :e `perldoc -ml <cword>`<CR>

" see ':help mapleader' for more info... default is backslash.

VimTip 615: Moving to the next word in insert mode
http://vim.sourceforge.net/tip_view.php?tip_id=

You can move to the next word in insert mode using <shift> <right arrow key>
You can move to the next word in command mode using w

You can move to the previous word in insert mode using <shift> <left arrow key>

VimTip 616: Have Vim check automatically if the file has changed externally
http://vim.sourceforge.net/tip_view.php?tip_id=

You can place this in your vimrc file, and then run:
:CheckForUpdates

This will toggle the behaviour for the given buffer.

" If you are using a console version of Vim, or dealing
" with a file that changes externally (ie a web server log)
" then Vim does not always check to see if the file has been changed.
" The GUI version of Vim will check more often (for example on Focus change),
" and prompt you if you want to reload the file.
"
" There can be cases where you can be working away, and Vim does not
" realize the file has changed.
"
" This function will force Vim to check more often.
"
" The function will turn on the :checktime command so that the
" file is checked based on the CursorHold event.
"
" Thanks to Jürgen Krämer, Antoine J. Mechelynck for the help.
"
" CheckForUpdates will toggle the behaviour on the current buffer.
function! CheckForUpdates()

    " Save the current default register
    let saveB=@"

    " Check to see if the checkforupdates autocommand exists
    redir @"
    silent! exec 'au checkforupdates'
    redir END

    if @" =~ 'E216'
        augroup checkforupdates
        if has("win32")
            " will do this except for file paths that contain spaces -- and if
            " you are on Windows, backslashes should be converted to slashes,
            " too:
            exec "au Cursorhold " . escape(
                        \ substitute(expand("%:p"), '\', '/', 'g')
                        \ , ' ') . " :checktime"
        else
            exec "au Cursorhold " . expand("%:p") . " :checktime"
        endif
        augroup END
    else
        " Using a autogroup allows us to remove it easily with the following
        " command.  If we do not use an autogroup, we cannot remove this
        " single :checktime command
        " augroup! checkforupdates
        au! checkforupdates
        augroup! checkforupdates
    endif

    let @"=saveB
endfunction
command! CheckForUpdates :call CheckForUpdates()

VimTip 617: Fun with case twiddling
http://vim.sourceforge.net/tip_view.php?tip_id=

Someone came on #vim asking about "sentence case", meaning Capitalization Of Every Word.

I came up with some bad solutions before learning this:

:s/\(^\|\s\)\([a-z]\)/\1\U\2/g

This inspired me to come up with a silly script for rotating between ALL CAPS, all lower, and Sentence Case.
MiXed Case is set to UPPER.

Then I mapped it (in visual mode) to ~, thus breaking the wonderful tilde :)

Here's the script:

fun! TwiddleCase(str)
	if a:str == toupper(a:str)
		let ans = tolower(a:str)
	elseif a:str == tolower(a:str)
		let ans = substitute(a:str,"\\(^\\|\\s\\)\\([a-z]\\)","\\1\\U\\2","g")
	else
		let ans = toupper(a:str)
	endif
	return ans
endfun

And the mapping:

vmap ~ x:call setreg('"', TwiddleCase(getreg('"')))^MP

VimTip 618: how to make and submit a patch
http://vim.sourceforge.net/tip_view.php?tip_id=

     Vim is developed using an open-source model, and users are encouraged to contribute to its development.  Users with programming experience should have a look at the to-do list from time to time (:help todo), and even beginners can help by asking and answering questions on the mailing lists, adding tips to this database, and suggesting improvements to the documentation.  (IMHO, if you get a question answered on one of the lists, a good way to repay the Vim community is by posting the answer as a tip here.)  Even rating tips and scripts on the vim web site helps others, by pointing them to the most useful ones.

     Another way to give back to the community is to support vim's charity:

:help uganda

     Here is how to make a patch.  Make a local copy of the file you are going to change, and edit it.  Then, change to the directory (such as vim62/) containing the src/ source directory.  If you are editing one of the help files and do not have the vim source files, change to your $VIMRUNTIME directory (usually /usr/local/share/vim/vimxx/ on *NIX systems).  Use the diff program to make the patch like this:

$ diff -c /src/eval.c path/to/my/eval.c > /tmp/eval.c.diff

for a patch to the source or (assuming you do not have the sources)

$ diff -c doc/help.txt path/to/my/help.txt > /tmp/help.txt.diff

The directory and file name for the patches are just suggestions.  If you change more than one file, you can concatenate the patches or read the man page for diff to create one big patch.

     If you are on a Windows system that does not have the diff program, you may be able to get one from http://gnuwin32.sourceforge.net/ .  (I have not used Windows for a while now, so I have not tried this.)  If the usage is substantially different from the above, perhaps someine will be kind enough to add a comment below explaining this.

      The -c option produces a "context diff."  This is fairly easy for both humans and machines to read, and all official patches for vim are released in this form.

     Once you have your patch, you can submit it to the vim-dev mailing list.

:help vim-dev

or

http://www.vim.org/maillist.php#vim-dev

VimTip 619: HowTo make a keymap
http://vim.sourceforge.net/tip_view.php?tip_id=

The present tip explains how to make a keymap for yourself. It is based on what is said under

    :help mbyte-keymap
    :help keymap-file-format

and you'll also find relevant information under

    :help 'keymap'
    :help 'iminsert'
    :help language-mapping
    :help <Char>

*1*  How to name the file and where to place it.

Keymaps reside in the "keymap" subdirectory of the directories named in 'runtimepath'. Their names are of one of the forms

    <keymap>.vim
    <keymap>_<encoding>.vim

so if you need keymaps for Czech and Norwegian, and want to use them under UTF-8, you will probably create two keymaps, named, for instance, "czech_utf8.vim" and "norwegian_utf8.vim". If those names collide with names already present in $VIMRUNTIME/keymap/, then either use slightly different names before the underline, or put them in the "keymap" subdirectory of a directory named earlier than $VIMRUNTIME in 'runtimepath', so yours will be found first (but in the latter case you won't be able to use the default keymap of the same name). Create the needed directory if it doesn't exist yet.

*2* What a keymap consists of.

A keymap consists of three parts:

a) a Vim script

b) a line containing only the word "loadkeymap" (without quotes)

c) the key mappings themselves.

*3* First part of a keymap: the Vim script.

This may contain any Ex-commands and Vim comments germane to the use of the keymap. In particular, the following Ex-commands are useful:

a) If this keymap is only a slight modification of another, preexisting one: a "source" statement for the keymap on which this one is based. Then you will only have to code the changes.

b) A short name, for instance in a keymap for Czech

    let b:keymap_name="cz"

This will appear as <cz> near the right end of the standard status line for any window where the keymap in question is enabled (by having its long name set ot setlocal'ed in 'keymap' and 'iminsert' setlocal'ed to 1).

c) A cursor color for when keymaps are in use. This one is more controversial (Bram comments it out in published keymaps) but I find it useful in my "private" ones.

    highlight lCursor ctermbg=red guibg=red

Use any color that pleases you, and beware that highlight groups are global for the whole of Vim, so it is possible to use different keymaps in split windows of a single Vim instance, but not different language cursor colors, unless you set up an autocommand to change the lCursor highlight at the WinEnter event. (How to make that work is outside the scope of this HowTo.)

*4* Second part: the "loadkeymap" command.

This is just to tell Vim that whatever comes after, to the end of the file, is a series of language-mappings, in a special format which will be described hereafter.

*5* Third part: The mappings themselves.

Each key mapping line consists of three parts; the optional third one may contain spaces but not the first two:

    {lhs}    {rhs}    [comment]

Vim interprets this line as if (in a standard Vim script) there had been

    lmap    <buffer>    {lhs}    {rhs}

The {lhs} is what you press, as interpreted by your default (English) keyboard. It is usually a single character, but it may be more than one: in that case all of them but the last act as "dead keys". For instance, in a German keymap, you may want to use the colon as a prefix to tell that the following vowel gets an umlaut (so that :A maps to Ä, :a to ä etc.)
Any key or key combination which does not appear as an {lhs} keeps its "English" meaning in the target language. (This will usually be the case for the space bar :-) and for any punctuation, or even letters, that you don't want to move about on the keyboard.) This means that if, for instance, you map the sz letter pair to the German eszet, you'll still be able to use the small-s letter with its usual meaning whenever it is not followed by z. Similarly, if you map the colon as above, a colon remains a colon if followed by anything other than a vowel, for instance a space or a digit.
In all cases, you can force the initial key(s) of a mapping to keep their original meaning, either by waiting for the mapping to time out, or by moving the cursor about, for instance with <Left><Right>.

The {rhs} is what it translates to, in the target language. For UTF-8 the {rhs} may be of the form <Char-0> to <Char-2347483647> (decimal), or <Char-0x0> to <Char-0x7FFFFFFF> (hex), or <Char-00> to <Char-017777777777> (octal) -- see ":help <Char>". For other encoding targets, the <Char> notation may also be used, but of course only as far as the target permits: e.g. in 8-bit encodings, only till 255 / 0xFF / 0377.

The [comment] is the easiest: it's for the human reader of the keymap, not for Vim.

VimTip 620: getting to know the function prototypes
http://vim.sourceforge.net/tip_view.php?tip_id=

Use "[ i" for display of function prototypes at bottom or "[ ctl i" for jumping to the file containing the prototype. also can use " I" for listing of proto.

VimTip 621: Vim as a syntax highlighting engine for web publishing
http://vim.sourceforge.net/tip_view.php?tip_id=

Geoff Richards has written a Perl module to turn Vim into a highlighting
engine for the web.
Text::VimColor (http://search.cpan.org/perldoc?Text::VimColor).

See some basic usage at http://www.perlmonks.org/index.pl?node_id=314528
where I also show a caching module to improve Text::VimColor performance.

Enjoy

gmax

VimTip 622: Deleting a buffer without changing your window layout
http://vim.sourceforge.net/tip_view.php?tip_id=

Here's a small command for your <.vimrc>:

    com! Kwbd let kwbd_bn= bufnr("%")|enew|exe "bdel ".kwbd_bn|unlet kwbd_bn

To use it, type   :Kwbd

Kwbd stands for:  Keep window (layout) and delete the associated buffer.

VimTip 623: External Paste Buffer
http://vim.sourceforge.net/tip_view.php?tip_id=

We are forever using copy and paste to copy information from application to application. Inevitably however we need to edit/reformat the buffer contents . This tip allows you to quickly open a separate VIM containing just the paste contents. You may then edit these contents as required, writing or closing VIM automatically causes the changed contents to be rewritten to the paste buffer.

The following is a CygWin script (could just as easily be a Win32 batch file)

function vxp
{
# description : Edit paste contents
gvim -c 'normal ggdG"*p' c:/aaa/xp
}

Such that I just type vxp and it opens a new Vim just containing the
current paste buffer.

To automatically cause the rewriting of the paste buffer add the following to your .vimrc

autocmd bufWritePost c:/aaa/xp normal ggVG"*y

(Thanks to Bob Chan et al from comp.editors)

VimTip 624: Insert template files into buffer ( HTML editing for example)
http://vim.sourceforge.net/tip_view.php?tip_id=

While editing HTML I want to use template files to be expanded on my html pages. Say for example I have something like this on my html file:

<!--"header.html"-->
<p>html code here</p>
<p>more html code here...</p>
<!--"footer.tml"-->

I want the files "header.html" and "footer.html" to be inserted on my page, you can do this with the following global command:

:g%<!--"\w\+.\w\+"--\>%exe ":r " . matchstr(getline("."), "\\w\\+\\.\\w\\+")

VimTip 625: Typing print statements faster and more ergonomically (esp in C++)
http://vim.sourceforge.net/tip_view.php?tip_id=

Guess what the most common word is in the C++ language? I wager it is 'cout'.

Interactive debuggers and logging libraries are all very well, but most of us still have in our debugging toolboxes the technique of adding short-lived statements to our programs whose only purpose is to help us figure out the bug currently occupying us by printing the value of a variable. If you find yourself often typing such statements they are worth optimizing for.

For example, strings in most languages are surrounded by double quotes which require an extra motion and keystroke for the left shift key. With my coding style I multiply that motion towards the shift key by 4-6 times per print statement and 10-100 print statements everyday. The result is to significant slow me down and bring me closer to the Home for the Aged Wrist. The analogous cout statement in c++ is even more egregious in this regard. Consider statements like the following that I frequently find myself typing:

cout << "AAA: " << someVarName << ": " << someOtherVarName << "\n" ;

That's *12* times my left hand moves towards the shift key for *one* statement! Unacceptable. My solution is to remap keys to interchange '<' and ',' as well as double quotes and single quotes. Rather than force myself to learn a new keyboard mapping within vim I cause the mappings to trigger in a context-sensitive mannter, within only a cout statement, from the time I type 'cout' to the time I type the ';' in the end.

Here's my code fragment to do this:
function! CppSetupCout ()
    inoremap , <Space><<
    inoremap < ,
    inoremap ' "
    inoremap " '
    imap ; <Esc>:call CppResetCout ()<CR>a;
    map <Esc>, :call CppResetCout ()<CR>
    imap <Esc>, <C-o>:call CppResetCout ()<CR>
endf
function! CppResetCout ()
    iunmap ,
    iunmap <
    iunmap '
    iunmap "
    iunmap ;
    imap <Esc>, <C-o>:call CppSetupCout ()<CR>
    map <Esc>, :call CppSetupCout ()<CR>
endfunction

function! AuCpp ()
    inoremap cout <End><Esc>:call CppSetupCout ()<CR>acout <<
    imap <Esc>, <C-o>:call CppSetupCout ()<CR>
    map <Esc>, :call CppSetupCout ()<CR>
endfunction

autocmd FileType cpp call AuCpp()

Notice that I use <Esc>, (or Alt-,) to quickly toggle these mappings on or off in other situations.

For some other languages it's prob sufficient to simply switch single- and double-quotes. Java might call for switching '+' and '=' within system.out.println. Come to think of it:

autocmd FileType java iabbrev sop system.out.println

You get the idea.

VimTip 626: open vimrc file
http://vim.sourceforge.net/tip_view.php?tip_id=

I edit my _vimrc file on a frequent basis.
I usually browse for the file then select it, but this can be a bit tedious so I made command that loads the file into a new window
Put this line into your _vimrc file
:com Openvimrc :new c:\vim\_vimrc

adjust the path as necessary - this assumes win32 platform
So now you can just  go ':Openvimrc' and you get the file to edit.

VimTip 627: Customizing ftplugin, syntax etc. (eg for TeX)
http://vim.sourceforge.net/tip_view.php?tip_id=



It is possible to customize the default environment that vim
provides (based on filetype).  In older versions of vim (5.x),
this was done with a "myfiletypefile" file.  In newer versions,
one customizes by adding files to the appropriate subdirectory
under the vimfiles directory.

For example, to customize the default TeX environment (of 6.1),
I added the following ftplugin and syntax files:

"--------------------------
" vimfiles/ftplugin/tex.vim
"--------------------------
if exists("b:did_myftplugin")
  finish
endif
let b:did_myftplugin = 1

" Set 'formatoptions' to break comment lines but not other lines,
" and insert the comment leader when hitting <CR> or using "o".
setlocal fo-=t fo+=croql

" Allow "[d" to be used to find a macro definition:
" Recognize plain TeX \def, \gdef, \let and \font
setlocal define=\\\\def\\\\|\\\\gdef\\\\|\\\\let\\\\|\\\\font\\\\|\\\\\\(re\\)\\=newcommand{
"---*---*---*---*---*---

"--------------------------
" vimfiles/syntax/tex.vim
"--------------------------
if exists("b:did_mysyntax")
  finish
endif
let b:did_mysyntax = 1
"hilight 1 true in, 1truein, 1 truein, 1true in, 1in, 1 in, 1.1 truein, etc.
syn match  texTrueLength	"\<\d\+\(\.\d\+\)\=\(\ *true\ *\|\ *\)\
                                             \(\ *pt\|\
                                               \ *he\|\
                                               \ *bp\|\
                                               \ *cc\|\
                                               \ *cm\|\
                                               \ *dd\|\
                                               \ *em\|\
                                               \ *ex\|\
                                               \ *in\|\
                                               \ *mm\|\
                                               \ *pc\|\
                                               \ *pt\|\
                                               \ *sp\)\>"

if version >= 508 || !exists("did_c_syn_inits")
  if version < 508
    let did_c_syn_inits = 1
    command -nargs=+ HiLink hi link <args>
  else
    command -nargs=+ HiLink hi def link <args>
  endif

  HiLink texTrueLength	Number

  delcommand HiLink
endif
"---*---*---*---*---*---



VimTip 628: Execut "things" in Win98 from within VIM
http://vim.sourceforge.net/tip_view.php?tip_id=



The following mappings help to execute "things" in win98.

1) If you are editing a file (eg, html file) file and want
   to view it, the mapping \xf will do it.

2) If you want to execute the string under the cursor (<cWORD>):

        The mapping \x executes the <cWORD> "as is", whereas
        the mapping \xl executes it after pre-pending it with the
        full path to the current file.

Example for \xf -- viewing an html file while editing it.

Example for \x -- the string under the cursor can be a google
search for the word mail on this web-site:

http://www.google.com/search?q=mail+site:vim.sourceforge.net

(It can also be things such as the name of a file (foo.pdf,
foo.bat) or directory etc.)

"__________________________________________
"The mappings:

" eXecute File being edited
nmap \xf  :silent !start rundll32 url.dll,FileProtocolHandler %:p <CR>

"eXecute string below cursor
nmap \x   :silent !start rundll32 url.dll,FileProtocolHandler <cWORD> <CR>

" eXecute string below cursor after prepending it with path to file
nmap \xl  :silent !start rundll32 url.dll,FileProtocolHandler %:p:h/<cWORD> <CR>

"__________________________________________
See:
  help  filename-modifiers
  help  <cWORD>



VimTip 629: After quitting VIM, comeback to the same file position where you were while quitting.
http://vim.sourceforge.net/tip_view.php?tip_id=

many a times while editing a big file we may temporarily want to go to command prompt and
open the same file again. Then again you will be in the first character of the file. This is a smarter tip for
taking the cursor to the same position where you were while quitting.

Just when you want to quit VIM instead of pressing ESC :q   just press ctrl+z. You can see this
[1]+  Stopped                 vim <filename>

you are in command prompt now. Do your work and when u want to return to VIm press fg.

Thats it.

VimTip 630: usefull for  programming
http://vim.sourceforge.net/tip_view.php?tip_id=

Hello,

I was looking for that feature for the very long time.

I use vim for programming and I always keep forgetting about closing the parents, quotes etc.

I wanted to remap the keyboard in insert mode in that way that when I open a quote or parent I will get the closing one and the cursor would be placed between these two characters.

here is the stuff I put in my ~/.vimrc file
<pre>
:imap ( ()<Left>
:imap [ []<Left>
:imap " <C-V>"<C-V>"<left>
</pre>

I had to use <C-V> to avoid recursive mapping of the " character.

Maybe there is the feature build in vim already but I couldn't find it :)

Every comment is welcome :)

VimTip 631: Disabling IME input in Windows
http://vim.sourceforge.net/tip_view.php?tip_id=

Often, your Windows locale will reflect a foreign country (e.g. Japan) so you can write text in another character set, but you don't want Vim to do that by default. It is annoying to have to disable IME input every time you start up Vim. But it's much easier than that. Simply add this line to your vimrc (usually at C:\vim\_vimrc):

set iminsert=0

Now, you will start out in regular Roman input mode, without IME. Enjoy!

VimTip 632: Setting the font in the GUI
http://vim.sourceforge.net/tip_view.php?tip_id=

This tip concerns the setting of the 'guifont' option. It is assumed that 'guifontset" and 'guifontwide' will, if available, be left empty or set to a non-conflicting value. Of course, this apples only to the GUI, since the font for 'console' vim is determined by the particular terminal or terminal emulator being used.

Background
----------

1. As of this writing (January 2004) there are 3 different possible formats for the 'guifont' option, namely GTK+2, other-X11 and other. Each version of the GUI accepts only one of them.

2. Some versions allow selecting the font by means of a menu, using

    :set guifont=*

However, the result is usually too restrictive.

3. Most versions allow setting an option by editing the current value, using

    :set guifont=<Tab>        (if 'nocompatible'), or
    :set guifont=<Ctrl-E>     (if 'compatible')

The current value appears, with escaping backslashes if and where needed. Change what you want to change, write it down so you can later enter it in your vimrc if you find out that you like it, then press <Enter> to accept the new result.

How to proceed
--------------

The default value for 'guifont' is the null string. However, a default or system vimrc may already have set some value. If what you see is "almost" what you want, use method 3 above. If the current value is empty, you will have to proceed in some other way. In that case, press <Esc> to leave command-line mode.

If the current value is empty, or if the current font has neither the shape nor the size that you want, try method 2 above. If it doesn't work, copy the code snippet found at the end of this tip into your vimrc and start from there, changing one thing at a time until you're satisfied.

If your version of vim allows selecting fonts via a menu, I recommend (for X11 without GTK+2) keeping only what is required to have a working font and replacing the rest (including, most especially, the last parameter, which is the encoding) by dash-separated asterisks; or (for other systems) keeping the font name and size and removing the rest (or, for non-X11, setting the encoding to cDEFAULT). See the examples below.

Now here is a snippet of code, applicable (I hope) to all versions of gvim. The only reason I haven't tested them all is I don't have them all. Start with that, change the "set" statements as needed, and put it in your vimrc.

    if has("gui_running")
        if has("gui_gtk2")
            set guifont=Courier\ New\ 11
        elseif has("x11")
            set guifont=-*-courier-medium-r-normal-*-*-180-*-*-m-*-*
        else
            set guifont=Courier_New:h11:cDEFAULT
        endif
    endif

Happy Vimming!
Tony.

VimTip 633: spell check of word below cursor
http://vim.sourceforge.net/tip_view.php?tip_id=

poor man's grep of spell checking for unix based systems

requires aspell/ispell to be available in path or use full path in map command

map <A-e> :!echo <cword> \| ispell -d british -a -- <return>
map <A-d> :!echo <cword> \| ispell -d danish -a -- <return>

spell check words in either english or danish

VimTip 634: To view all colours available to gvim
http://vim.sourceforge.net/tip_view.php?tip_id=

What: To see all the colours available in gvim, with their names.

How:  Save this tip and open in gvim and do ':source %'

Caveats: some colours appear wrong in gvim,
         but are correct in opera/eudora/emacs.

See: Color names are from X11/rgb.txt, see also $VIM/syntax/colortest.vim

- http://www.cs.albany.edu/~mosh

---- cut-here -------

/\ssnow/,$ g/^" \\w/ exec 'hi col_'.expand("<cword>").' guifg='.expand("<cword>")|
           \\ exec 'syn keyword col_'.expand("<cword>")." ".expand("<cword>")

" snow
" GhostWhite
" WhiteSmoke
" gainsboro
" FloralWhite
" OldLace
" linen
" AntiqueWhite
" PapayaWhip
" BlanchedAlmond
" bisque
" PeachPuff
" NavajoWhite
" moccasin
" cornsilk
" ivory
" LemonChiffon
" seashell
" honeydew
" MintCream
" azure
" AliceBlue
" lavender
" LavenderBlush
" MistyRose
" white
" black
" DarkSlateGray
" DarkSlateGrey
" DimGray
" DimGrey
" SlateGray
" SlateGrey
" LightSlateGray
" LightSlateGrey
" gray
" grey
" LightGrey
" LightGray
" MidnightBlue
" navy
" NavyBlue
" CornflowerBlue
" DarkSlateBlue
" SlateBlue
" MediumSlateBlue
" LightSlateBlue
" MediumBlue
" RoyalBlue
" blue
" DodgerBlue
" DeepSkyBlue
" SkyBlue
" LightSkyBlue
" SteelBlue
" LightSteelBlue
" LightBlue
" PowderBlue
" PaleTurquoise
" DarkTurquoise
" MediumTurquoise
" turquoise
" cyan
" LightCyan
" CadetBlue
" MediumAquamarine
" aquamarine
" DarkGreen
" DarkOliveGreen
" DarkSeaGreen
" SeaGreen
" MediumSeaGreen
" LightSeaGreen
" PaleGreen
" SpringGreen
" LawnGreen
" green
" chartreuse
" MediumSpringGreen
" GreenYellow
" LimeGreen
" YellowGreen
" ForestGreen
" OliveDrab
" DarkKhaki
" khaki
" PaleGoldenrod
" LightGoldenrodYellow
" LightYellow
" yellow
" gold
" LightGoldenrod
" goldenrod
" DarkGoldenrod
" RosyBrown
" IndianRed
" SaddleBrown
" sienna
" peru
" burlywood
" beige
" wheat
" SandyBrown
" tan
" chocolate
" firebrick
" brown
" DarkSalmon
" salmon
" LightSalmon
" orange
" DarkOrange
" coral
" LightCoral
" tomato
" OrangeRed
" red
" HotPink
" DeepPink
" pink
" LightPink
" PaleVioletRed
" maroon
" MediumVioletRed
" VioletRed
" magenta
" violet
" plum
" orchid
" MediumOrchid
" DarkOrchid
" DarkViolet
" BlueViolet
" purple
" MediumPurple
" thistle
" snow1
" snow2
" snow3
" snow4
" seashell1
" seashell2
" seashell3
" seashell4
" AntiqueWhite1
" AntiqueWhite2
" AntiqueWhite3
" AntiqueWhite4
" bisque1
" bisque2
" bisque3
" bisque4
" PeachPuff1
" PeachPuff2
" PeachPuff3
" PeachPuff4
" NavajoWhite1
" NavajoWhite2
" NavajoWhite3
" NavajoWhite4
" LemonChiffon1
" LemonChiffon2
" LemonChiffon3
" LemonChiffon4
" cornsilk1
" cornsilk2
" cornsilk3
" cornsilk4
" ivory1
" ivory2
" ivory3
" ivory4
" honeydew1
" honeydew2
" honeydew3
" honeydew4
" LavenderBlush1
" LavenderBlush2
" LavenderBlush3
" LavenderBlush4
" MistyRose1
" MistyRose2
" MistyRose3
" MistyRose4
" azure1
" azure2
" azure3
" azure4
" SlateBlue1
" SlateBlue2
" SlateBlue3
" SlateBlue4
" RoyalBlue1
" RoyalBlue2
" RoyalBlue3
" RoyalBlue4
" blue1
" blue2
" blue3
" blue4
" DodgerBlue1
" DodgerBlue2
" DodgerBlue3
" DodgerBlue4
" SteelBlue1
" SteelBlue2
" SteelBlue3
" SteelBlue4
" DeepSkyBlue1
" DeepSkyBlue2
" DeepSkyBlue3
" DeepSkyBlue4
" SkyBlue1
" SkyBlue2
" SkyBlue3
" SkyBlue4
" LightSkyBlue1
" LightSkyBlue2
" LightSkyBlue3
" LightSkyBlue4
" SlateGray1
" SlateGray2
" SlateGray3
" SlateGray4
" LightSteelBlue1
" LightSteelBlue2
" LightSteelBlue3
" LightSteelBlue4
" LightBlue1
" LightBlue2
" LightBlue3
" LightBlue4
" LightCyan1
" LightCyan2
" LightCyan3
" LightCyan4
" PaleTurquoise1
" PaleTurquoise2
" PaleTurquoise3
" PaleTurquoise4
" CadetBlue1
" CadetBlue2
" CadetBlue3
" CadetBlue4
" turquoise1
" turquoise2
" turquoise3
" turquoise4
" cyan1
" cyan2
" cyan3
" cyan4
" DarkSlateGray1
" DarkSlateGray2
" DarkSlateGray3
" DarkSlateGray4
" aquamarine1
" aquamarine2
" aquamarine3
" aquamarine4
" DarkSeaGreen1
" DarkSeaGreen2
" DarkSeaGreen3
" DarkSeaGreen4
" SeaGreen1
" SeaGreen2
" SeaGreen3
" SeaGreen4
" PaleGreen1
" PaleGreen2
" PaleGreen3
" PaleGreen4
" SpringGreen1
" SpringGreen2
" SpringGreen3
" SpringGreen4
" green1
" green2
" green3
" green4
" chartreuse1
" chartreuse2
" chartreuse3
" chartreuse4
" OliveDrab1
" OliveDrab2
" OliveDrab3
" OliveDrab4
" DarkOliveGreen1
" DarkOliveGreen2
" DarkOliveGreen3
" DarkOliveGreen4
" khaki1
" khaki2
" khaki3
" khaki4
" LightGoldenrod1
" LightGoldenrod2
" LightGoldenrod3
" LightGoldenrod4
" LightYellow1
" LightYellow2
" LightYellow3
" LightYellow4
" yellow1
" yellow2
" yellow3
" yellow4
" gold1
" gold2
" gold3
" gold4
" goldenrod1
" goldenrod2
" goldenrod3
" goldenrod4
" DarkGoldenrod1
" DarkGoldenrod2
" DarkGoldenrod3
" DarkGoldenrod4
" RosyBrown1
" RosyBrown2
" RosyBrown3
" RosyBrown4
" IndianRed1
" IndianRed2
" IndianRed3
" IndianRed4
" sienna1
" sienna2
" sienna3
" sienna4
" burlywood1
" burlywood2
" burlywood3
" burlywood4
" wheat1
" wheat2
" wheat3
" wheat4
" tan1
" tan2
" tan3
" tan4
" chocolate1
" chocolate2
" chocolate3
" chocolate4
" firebrick1
" firebrick2
" firebrick3
" firebrick4
" brown1
" brown2
" brown3
" brown4
" salmon1
" salmon2
" salmon3
" salmon4
" LightSalmon1
" LightSalmon2
" LightSalmon3
" LightSalmon4
" orange1
" orange2
" orange3
" orange4
" DarkOrange1
" DarkOrange2
" DarkOrange3
" DarkOrange4
" coral1
" coral2
" coral3
" coral4
" tomato1
" tomato2
" tomato3
" tomato4
" OrangeRed1
" OrangeRed2
" OrangeRed3
" OrangeRed4
" red1
" red2
" red3
" red4
" DeepPink1
" DeepPink2
" DeepPink3
" DeepPink4
" HotPink1
" HotPink2
" HotPink3
" HotPink4
" pink1
" pink2
" pink3
" pink4
" LightPink1
" LightPink2
" LightPink3
" LightPink4
" PaleVioletRed1
" PaleVioletRed2
" PaleVioletRed3
" PaleVioletRed4
" maroon1
" maroon2
" maroon3
" maroon4
" VioletRed1
" VioletRed2
" VioletRed3
" VioletRed4
" magenta1
" magenta2
" magenta3
" magenta4
" orchid1
" orchid2
" orchid3
" orchid4
" plum1
" plum2
" plum3
" plum4
" MediumOrchid1
" MediumOrchid2
" MediumOrchid3
" MediumOrchid4
" DarkOrchid1
" DarkOrchid2
" DarkOrchid3
" DarkOrchid4
" purple1
" purple2
" purple3
" purple4
" MediumPurple1
" MediumPurple2
" MediumPurple3
" MediumPurple4
" thistle1
" thistle2
" thistle3
" thistle4
" gray0
" grey0
" gray1
" grey1
" gray2
" grey2
" gray3
" grey3
" gray4
" grey4
" gray5
" grey5
" gray6
" grey6
" gray7
" grey7
" gray8
" grey8
" gray9
" grey9
" gray10
" grey10
" gray11
" grey11
" gray12
" grey12
" gray13
" grey13
" gray14
" grey14
" gray15
" grey15
" gray16
" grey16
" gray17
" grey17
" gray18
" grey18
" gray19
" grey19
" gray20
" grey20
" gray21
" grey21
" gray22
" grey22
" gray23
" grey23
" gray24
" grey24
" gray25
" grey25
" gray26
" grey26
" gray27
" grey27
" gray28
" grey28
" gray29
" grey29
" gray30
" grey30
" gray31
" grey31
" gray32
" grey32
" gray33
" grey33
" gray34
" grey34
" gray35
" grey35
" gray36
" grey36
" gray37
" grey37
" gray38
" grey38
" gray39
" grey39
" gray40
" grey40
" gray41
" grey41
" gray42
" grey42
" gray43
" grey43
" gray44
" grey44
" gray45
" grey45
" gray46
" grey46
" gray47
" grey47
" gray48
" grey48
" gray49
" grey49
" gray50
" grey50
" gray51
" grey51
" gray52
" grey52
" gray53
" grey53
" gray54
" grey54
" gray55
" grey55
" gray56
" grey56
" gray57
" grey57
" gray58
" grey58
" gray59
" grey59
" gray60
" grey60
" gray61
" grey61
" gray62
" grey62
" gray63
" grey63
" gray64
" grey64
" gray65
" grey65
" gray66
" grey66
" gray67
" grey67
" gray68
" grey68
" gray69
" grey69
" gray70
" grey70
" gray71
" grey71
" gray72
" grey72
" gray73
" grey73
" gray74
" grey74
" gray75
" grey75
" gray76
" grey76
" gray77
" grey77
" gray78
" grey78
" gray79
" grey79
" gray80
" grey80
" gray81
" grey81
" gray82
" grey82
" gray83
" grey83
" gray84
" grey84
" gray85
" grey85
" gray86
" grey86
" gray87
" grey87
" gray88
" grey88
" gray89
" grey89
" gray90
" grey90
" gray91
" grey91
" gray92
" grey92
" gray93
" grey93
" gray94
" grey94
" gray95
" grey95
" gray96
" grey96
" gray97
" grey97
" gray98
" grey98
" gray99
" grey99
" gray100
" grey100
" DarkGrey
" DarkGray
" DarkBlue
" DarkCyan
" DarkMagenta
" DarkRed
" LightGreen

VimTip 635: getting colors to work on solaris
http://vim.sourceforge.net/tip_view.php?tip_id=

You need to get the latest ncurses package available at http://www.sunfreeware.com/ and then configure with this option:
--with-tlib=ncurses

This will link to ncurses which fully supports the color codes.  Then make sure your display is exported as a  color capable terminal.

VimTip 636: Adding Vim to MS-Windows File Explorer Menu
http://vim.sourceforge.net/tip_view.php?tip_id=

What:  To Add 'Edit with Vim' to 'Windows File Explorer'
'right click Menu'

1. Save this file as edit-with-vim.reg,
2. Make sure the paths are right for your machine
3. Change each fowardslash to backslash
   with the vim command :%s,/,\\,g
4. Click on it in explorer or import this file in regedit.exe
   voila, your explorer right-click menu will have extra action items,
   it's better than the send-to.
5. The double quotes are needed for filenames with spaces.
6. The '*' means 'for all files'.

REGEDIT4
[HKEY_CLASSES_ROOT/*/shell]
[HKEY_CLASSES_ROOT/*/shell/vim]
@="Edit with &vim"
[HKEY_CLASSES_ROOT/*/shell/vim/command]
@="c://bin32//gvim.exe /"%1/""
[HKEY_CLASSES_ROOT/*/shell/_emacs]
@="Edit with &Emacs"
[HKEY_CLASSES_ROOT/*/shell/_emacs/command]
@="c://emacs//bin//runemacs.exe /"%1/""




VimTip 637: execute accidently inserted commands
http://vim.sourceforge.net/tip_view.php?tip_id=

If you are in insert mode and typed an command for normal mode, you can use it.

inoremap <somekey> <esc>u@.

This mapping switches to normal mode, undo'es the last insertion and takes it as a command.

Most times I need it, if I typed dd and the line still remains because of Insert-Mode and the unwanted 'dd' ist somewhere
in my text.

VimTip 638: Editing ActiveState Perl batch files
http://vim.sourceforge.net/tip_view.php?tip_id=

To run Perl scripts under Windows, you can either add the .pl extension to the PATHEXT env variable, or use pl2bat, which comes with ActiveState's Perl and makes a very nice batch file.  A quirk of Perl under Win32 is that piping doesn't work with .pl files (as in bar.pl | foo.pl) but works fine with the batch files.  It has something to do with how Windows loads files.  Anyway, this all works fine, but every time I do any extensive edits to a perl/batch file, I have to set cindent and syntax=perl or it drives me crazy.  This tip modifies filetype.vim to check batch files to see if they're really perl scripts in disguise.

--->First, find these lines:

" Batch file for MSDOS (*.cmd is close enough)
au BufNewFile,BufRead *.bat,*.cmd,*.sys		setf dosbatch

--->Then change them to this:

" Batch file for MSDOS (*.cmd is close enough)
au BufNewFile,BufRead *.bat,*.cmd,*.sys		call FTCheck_bat()

" Perl scripts converted to bat by pl2bat have a unique string that
" identifies the file.  It should be the first line.
fun! FTCheck_bat()
  if exists("g:filetype_bat")
    exe "setf " . g:filetype_bat
  else
    let l = getline(nextnonblank(1))
    if l =~ '--\*-Perl-\*--'
      setf perl
    else
      setf dosbatch
    endif
  endif
endfun

--->That's it!  This is very specific to look for the string pl2bat adds to the file, but can be easily modified to your needs.

VimTip 639: Comment highlight #ifdef DEBUG for code-read ease (C/C++)
http://vim.sourceforge.net/tip_view.php?tip_id=

Hi all,

If your C/C++ code is scattered with statements like
#ifdef DEBUG
   // Some code..
   cout << "Debug output: blah" << endl;
#endif

and you would like to highlight these segments in a different colour (so that
you can skip them visually), add the following code in your .vimrc (colouring
follows that of comments)

CODE STARTS
syn region MySkip contained start="^\s*#\s*\(if\>\|ifdef\>\|ifndef\>\)" skip="\\$" end="^\s*#\s*endif\>" contains=MySkip

let g:CommentDefines = ""

hi link MyCommentOut2 MyCommentOut
hi link MySkip MyCommentOut
hi link MyCommentOut Comment

map <silent> ,a :call AddCommentDefine()<CR>
map <silent> ,x :call ClearCommentDefine()<CR>

function! AddCommentDefine()
   let g:CommentDefines = "\\(" . expand("<cword>") . "\\)"
   syn clear MyCommentOut
   syn clear MyCommentOut2
   exe 'syn region MyCommentOut start="^\s*#\s*ifdef\s\+' . g:CommentDefines . '\>" end=".\|$" contains=MyCommentOut2'
   exe 'syn region MyCommentOut2 contained start="' . g:CommentDefines . '" end="^\s*#\s*\(endif\>\|else\>\|elif\>\)" contains=MySkip'
endfunction

function! ClearCommentDefine()
   let g:ClearCommentDefine = ""
   syn clear MyCommentOut
   syn clear MyCommentOut2
endfunction

CODE ENDS

To see the effect, position the cursor on the word DEBUG in the C code snippet above and type ,a

VimTip 640: See your vim templates in Windows Explorer's New context menu
http://vim.sourceforge.net/tip_view.php?tip_id=

Do you wish you had your own vim settings for a file appear automatically when
you right click in Windows Explorer? If so then read on, following these steps
sequentially:

- Create a template file where the last few lines control vim. See below for a
  sample:

	-[sample template file begins below this line]-

--------------------------------End of Text----------------------------------
The line below controls vim, which you can get free from: http://www.vim.org/
vim:tw=80:ai:ft=txt:norl:
	-[sample template file ends above this line]-

- Call the above sample template file GVIM.vtd and save it in
  "C:\Windows\ShellNew\" directory.  You may use another extension, but I
  played it safe and used one that wasn't being used on my system. Moreover, I
  did not change the default location of Windows installation, but you may
  need to do so if your system does not match mine.

- Open Explorer and click on Tools->Folder Options... in the dialog box that
  appears, click on File Types and then scroll the file types until you reach
  VTD.  Click on the file extension VTD and click on Change; now associate
  gvim.exe with this file extension.

- Next, open the registry with regedit by clicking on Start->Run and typing
  regedit in the Run dialog box

- In the registry, scroll  HKEY_CLASSES_ROOT until you get to Vim.Application
		- then add a key; call it "shell"
		- next scroll into:
			[HKEY_CLASSES_ROOT\Vim.Application\shell]
		- and add a key; call it "open"
		- once more scroll into:
		  	[HKEY_CLASSES_ROOT\Vim.Application\shell\open]
		- and add yet another key; call it "command"
		- now change, by double clicking on, the "(Default)" value of
		  "command" to point it to the location of gvim.exe on your
		  hard drive. On my system, I entered the following in the text
		  field "Value data"
		  	C:\PROGRA~1\Vim\vim62\gvim.exe "%1"


- Finally open up Explorer and navigate to any directory on your hard drive.
  Now, right click on, the pane displaying the files, to see "Vim" as one of
  your options. When you choose Vim, you will create a file called "New
  Vim.vtd" in that directory. When you open "New Vim.vtd" you should see the
  above sample text and Vim uses the settings used in the last line of the file.

- Any changes made to the original template in C:\Windows\ShellNew appear in
  the new files that you create.

I tried to get this to work with using TweakUI but that did not help in Windows
XP, so I had to do it the long way. So, I hope this tip helps at least a few of
you,

Enjoy!

VimTip 641: Highlighting of method names in the definition (C++)
http://vim.sourceforge.net/tip_view.php?tip_id=

When editing big cpp files, it can be very convenient to highlight the method name
(the part after "::") in a method definition.

--> I use the following function in my .vimrc:

" Add highlighting for function definition in C++
function! EnhanceCppSyntax()
    syn match cppFuncDef "::\~\?\zs\h\w*\ze([^)]*\()\s*\(const\)\?\)\?$"
    hi def link cppFuncDef Special
endfunction

--> I have another line to call this function automatically when editing a C++ file:

autocmd Syntax cpp call EnhanceCppSyntax()

--> That's it! This doesn't work in all cases (for instance, it doesn't highlight constructors
using an initialization list on the same line) but it shouldn't highlight function calls
(such as "MyClass::MyStaticMethod( int foo );" )
Don't hesitate to extend the regular expression for a more accurate matching...

VimTip 642: Windows: Get K to not display a DOS box that needs closing
http://vim.sourceforge.net/tip_view.php?tip_id=

To get the K command to open a Windows program without creating DOS box that needs to be closed you can do the following:

In your _vimrc add the following:

map K yiw:exec "silent !".&kp." ".@0<CR>

You can then set the keywordprg (abbreviated kp above) to the program you want to run.

Thanks to Jacob Lerner, Tim Chase, and Suresh Govindachar for coming up with this.

VimTip 643: Disable built-in command
http://vim.sourceforge.net/tip_view.php?tip_id=

If there's a built-in key command in vim that you just can't stand, find annoying, and/or often hit by accident(for me it's "K", with ">" a close second), then you can disable it using ":map".  You can't use ":unmap", as you might think.  Instead, you can map it to nothing, like:

:map K <Nop>

(<Nop> is not the "Nop" key on your keyboards, but literal letters inside literal pointy brackets.)

Of course, you can always

:unmap K

if you start doing C programming and want to instantly "man" things under the cursor again.

VimTip 644: restoring indent for '#'
http://vim.sourceforge.net/tip_view.php?tip_id=

In 'smatrindent' mode '#' removes the indent if it is the first char on the line.
Very annoying for me.

From Vim's help:
        When typing '#' as the first character in a new line, the indent for
        that line is removed, the '#' is put in the first column.  The indent
        is restored for the next line.  If you don't want this, use this
        mapping: ":inoremap # X^H#", where ^H is entered with CTRL-V CTRL-H.

This helps, but it failes to work when placed in ~/.vimrc.
The fillowing mapping work in any case:

:inoremap # a#^Oh^Ox^OA, where ^O is entered with CTRL-V CTRL-O.

VimTip 645: Enabling Windows shortcuts (eg alt+space, F10 etc) for gvim window
http://vim.sourceforge.net/tip_view.php?tip_id=

I was trying to figure out why Alt+space would not work, as i would have to use the mouse to maximize/restore/minimize my gvim window (on Win32) which was a pain
and found that i needed to
     set winaltkeys=yes
to make this work. Now I can use
Alt+Space followed by 'x to maximize
Alt+Space followed by 'n' to minimize
Alt+Space followed by 'r' to restore!
See
help winaltkeys

Also see this:
vimtip #494

VimTip 646: moving lines up/down in a file
http://vim.sourceforge.net/tip_view.php?tip_id=

The following mappings in .vimrc provide a quick way to move a line of text up or down within a file:

    map <C-Up> dd-P
    map <C-Down> ddp

Hold down the Control key, and the <Up> and <Down> arrow keys move the line.  Check it out!

This is particularly useful when editing a file consisting of single-line items in a particular order (such as priority) - it makes it easy to change the relative position of items in the list.

VimTip 647: Single letter insert
http://vim.sourceforge.net/tip_view.php?tip_id=

 Often I have to insert only one character ( typically a paren)
:map <C-x> ylpr

VimTip 648: Uniq - Removing duplicate lines
http://vim.sourceforge.net/tip_view.php?tip_id=

There are two versions, the first leaves only the last line, the second leaves only the first line.

g/^\(.*\)$\n\1$/d

g/\%(^\1$\n\)\@<=\(.*\)$/d

Breakdown of the second version:

g//d    <-- Delete the lines matching the regexp

\@<=    <-- If the bit following matches, make sure the bit preceding this symbol directly precedes the match

\(.*\)$   <-- Match the line into subst register 1

\%( )     <--- Group without placing in a subst register.
^\1$\n   <--- Match subst register 1 followed by end of line and the new line between the 2 lines

In this simple format (matching the whole line), it's not going to make much difference, but it will start to matter if you want to do stuff like match the first word only

This does a uniq on the first word in the line, and deletes all but the first line:

g/\%(^\1\>.*$\n\)\@<=\(\k\+\).*$/d

VimTip 649: expand existing abbreviation
http://vim.sourceforge.net/tip_view.php?tip_id=

This mapping expands existing abbreviation

map <C-X><C-X> diw:exe "normal i".@"<cr>

VimTip 650: abbreviation that prompts whether to expand it or not
http://vim.sourceforge.net/tip_view.php?tip_id=

You can define abbreviation in such a way that it will ask whether to expand it or not. The trick is to define it as insert-mode mapping with special body, not as abbreviation.
Here is how to define it:

   function! MyExpand(abbr,expansion)
     let answer=confirm("Expand '".a:abbr."' [y] ", "&Yes\n&No")
     if answer==2
        exec "normal! a".a:abbr
     else
         exec "normal! a".a:expansion
     endif
   endfunction

imap ABC <esc>:call AskExpand("ABC","...expansion for ABC ...")<cr>a
imap XYZ <esc>:call AskExpand("XYZ","...expansion for XYZ ...")<cr>a

VimTip 651: Edit gnupg-encrypted files.
http://vim.sourceforge.net/tip_view.php?tip_id=

It can be somewhat laborious to edit a file which you have encrypted: first you have to decrypt to plaintext, then use vim and save; then encrypt again.  The method below lets vim take care of some of the dirty work.

First, be sure you have gnupg setup to the point where you can ascii-armor encrypt a file using your own public key, and decrypt it again.

Then put this into your .vimrc (don't duplicate the 'if has("autocmd")' part if it is already there):
  if has("autocmd")
      augroup GPGASCII
         au!
         au BufReadPost *.asc  :%!gpg -q -d
         au BufReadPost *.asc  |redraw
         au BufWritePre *.asc  :%!gpg -q -e -a
         au BufWritePost *.asc u
         au VimLeave *.asc :!clear
      augroup END
  endif " has ("autocmd")


you might also want to add these options to your ~/.gnupg/options file to decrease the messages gnupg outputs:
    no-greeting
    quiet
    default-recipient-self  #to always encrypt for yourself.

Now vim a new file, the name of which ends with .asc:
     vim important.asc
and edit.  When you save and quit, gnupg may prompt for gnupg ids to encrypt for (if you don't have default-recipient-self set).  Enter your own.  To edit, just vim it again and you'll be prompted for your passphrase.

This isn't perfect -- in particular, you occasionally have to tell vim to redraw with ctrl-L to get rid of gnupg crud -- but it works pretty well for me.  I'd love to hear about improvements!

VimTip 652: save all open buffers at once
http://vim.sourceforge.net/tip_view.php?tip_id=

Since i like to work with more than one buffer, i always have had the problem
that i left one of them unsaved by mistake. For this purpose i wrote this
small function which saves all open buffers (only if changes were made).
If you map the function to a key (e.g. F12), this is quite a convenient way.

add this to your .vimrc:

function! SaveBuffers()
  if !buflisted(bufnr('%'))
    return
  end
  let myBufferNumber = bufnr('%')
  exec("bufdo update")
  exec("b".myBufferNumber)
endfunction

nmap <F12> :call SaveBuffers()<CR>

VimTip 653: doxygen '///' :comments setting
http://vim.sourceforge.net/tip_view.php?tip_id=

This will continue lines of '///' doxygen comments when you reach the end of a line while typing a comment.  It also works if you use 'o' to open a new line while on a comment starting with '///'.  It only works if there is a space between the last '/' and the first letter of the comment, that is no big deal, since it lends itself to readability.  So for example:
/// This will work.
///This won't.

Here is the magic line.  Make sure you put it somewhere that will get sourced whenever you open a file you want to use with doxygen.  I have it in ~/.vim/after/ftplugin/c/c.vim, so it gets sourced for all C and C++ files.

set comments=sO:*\ -,mO:*\ \ ,exO:*/,s1:/*,mb:*,ex:*/,bO:///,O://

All other comments will continue to work as expected.

- Michael

VimTip 654: special characters in VIM substitution
http://vim.sourceforge.net/tip_view.php?tip_id=

Let's think about the code below

void
howdy(void)
{
   M00 =
   M01 =
   M10 =
   M11 =
   M20 =
   M21 = 0;
}

Now you want to change the code like

void
howdy(void)
{
   M[0][0] =
   M[0][1] =
   M[1][0] =
   M[1][1] =
   M[2][0] =
   M[2][1] = 0;
}

You can easily do that with

:g/\(M\)\([0-9]\)\([0-9]\)/s//\1[\2][\3]/g

Here,
   \1 is a special substitute character meaning first pair of the search pattern.

To specify a pair in your search pattern,
simply enclose your search pattern with "\(" and "\)".

Thus, in the above example
\(M\) corresponds to \1, and
\([0-9]\) to \2 and etc...

And substitute pattern "\1[\2][\3]" means
"1st pair" + "[" + "2nd pair" + "]" + "[" + "3rd pair" + "]",
which is what we want here.

For more information on special substitute characters, simply do :help substitute.
Happy Vim-ing!

VimTip 655: search with one key
http://vim.sourceforge.net/tip_view.php?tip_id=

* is 2 keys (shift and press 8)
I found it simpler to map these to a single key.

put these mappings in your _vimrc file

:nmap  <F8> :execute ":normal #"<CR>

:nmap  <F9> :execute ":normal *"<CR>

Now you can search for the word under the cursor in normal mode with the F8 key backwards and the F9 key forwards.

Can this be done in insert mode?

VimTip 656: Recursive mappings - (2 examples to learn from)
http://vim.sourceforge.net/tip_view.php?tip_id=

Recursive mappings are fun to learn and really handy when you want to do repetitive tasks.  One way to do this is Tip#144 (recording).  This is another way when you find that you are using the same **editing pattern** again and again.  Recursion may seem a bit complicated at first but it is very intuitive once you get the hang of it.   Here are two examples for you to learn from.

For example, you have a file with the following contents -

aaa.txt
bbbbbb.txt
ccc.txt

You want to change the file as follows -

wc aaa.txt> aaa.log
echo "HelloWorld"
wc bbbbbb.txt > bbbbbb.log
echo "HelloWorld"
wc ccc.txt> ccc.log
echo "HelloWorld"

A simple recursive mapping that will do the job is
:map z Iwc <Esc>lyawA><Esc>pa.log<CR>echo "HelloWorld"<Esc>jz

Now type z in the first line and everything else is magic.

Here is the breakup where {} contain the vim commands.
1.  Goto the beginning of the line and type "wc " and then come back to normal mode {Iwc <Esc>}
2.  Copy the word aaa (or bbbb or ccc).  We do this by going right one character and copying the word under it. {lyaw}
3.  Goto the end of the line and append > and then come back to normal mode.   {A><Esc>}
4.  Paste what we had copied {p}
5.  Append .log<CR>echo "HelloWorld" to the line.  {a.log<CR>echo "HelloWorld"}
6.  Goto the next line but first we switch to the normal mode. {<Esc>j}
7.  Do steps 1 to 7 all overagain {z}

The recursion terminates when the j cannot take you one more line further.  If you manually execute a command for one line, you will find it very intuitive to create recursive mappings.

Here is another example.

Say you want to change
#define myid   199
#define myid2 200
#define myid3 201

To
#define myid   201
#define myid2 202
#define myid3 203

The simple  mapping would be -
:map z 2^Ajz

Where ^A is CTRL_V+A

1.  Add 2 to the number in the line
2.  Go down one line.
3.  Do steps 1 to 3 again.

Also see
:help recursive_mapping
:help CTRL-A
:help nowrapscan  // when using recursion with searching.

There may be many ways to solve the above problems... this is just another way which I like to use.  Recursion is very powerful espcially when I manipulate many open windows where the content of one is to be used in another.

VimTip 658: Switching to unit test module for python
http://vim.sourceforge.net/tip_view.php?tip_id=

Doing a lot of programming in Python, I need to switch quickly between Python module and corresponding unit-test module. Often there is one unit-testing module for multiple python modules.

This function allows you to switch to correct unit testing module quickly, using the filename hardcoded at the end of the file. Idea is stolen from Twisted sources.

Put this to your ftplugin/python.vim:

nmap <buffer> <F5> :call JumpToTestFile()<CR>

fun! JumpToTestFile()
	let line = getline("$")
	if line =~ "^### testfile: "
		let filename = strpart(line, 14)
		execute ":e " . filename
	else
		echo "TEST PATTERN ### testfile: NOT FOUND!"
	endif
endfun

VimTip 659: Collect filenames of current subtree
http://vim.sourceforge.net/tip_view.php?tip_id=

In vim you can edit directories, but sometimes for me it is more convenienant to have the names of all files in the complete subtree listed in one buffer. The below function does just this. In essential, it globs the file names of the current directory and iterates throught all the names, globbing it again if it is a directory.
The following mapping abbreviates the invocation to pressing '_L':

map _L :call ListTree('.')<CR>

function! ListTree(dir)
  new
  set buftype=nofile
  set bufhidden=hide
  set noswapfile
  normal i.
  while 1
    let file = expand("<cWORD>")
    if (file == '')
      normal dd
    elseif (isdirectory(file))
      normal dd
      let @" = glob(file . "/*")
      normal O
      normal P
      let @" = glob(file . "/.[^.]*")
      if (@" != '')
      normal O
      normal P
      endif
    else
      if (line('.') == line('$'))
	return
      else
	normal j
      endif
    endif
  endwhile
endfunction

VimTip 660: Comment lines in different filetypes
http://vim.sourceforge.net/tip_view.php?tip_id=

This code snippet is a part of .vimrc (_vimrc 4 Win) file to set comments in various filetypes. The funtion CommentIt() decides itself, according to the current file's type which variant of comments to use.

--> IMPORTANT this function should be started with "autocmd BufEnter * call CommentIt ()" some where after its declaration to be involved every time user enters a new buffer.

function CommentIt ()
if &filetype == "vim"
	vmap +# :s/^/"/<CR>
	vmap -# :s/^"//<CR>
elseif &filetype == "tcl"
	vmap +# :s/^/#/<CR>
	vmap -# :s/^#//<CR>
elseif &filetype == "c"
	vmap +# I/*<Esc>gv<End><Esc>a*/<Esc>
	vmap -# I<Esc>2xgv$<Esc>h2x<Esc>
elseif &filetype == "cpp"
	vmap +# A<End><CR><Esc>gv:s/^/ *<CR>gvI<Esc>ko<Home>/*<Esc>gvA<Esc>ji */
	vmap -# :s/^..//<CR>gvI<Esc>ddgvA<Esc>dd
elseif &filetype == "dosbatch"
	vmap +# :s/^/rem /<CR>
	vmap -# :s/^rem //<CR>
endif
endfunction
...
autocmd BufEnter * call CommentIt ()

VimTip 661: LaTeX: Addition to latex-suite: folds the preamble
http://vim.sourceforge.net/tip_view.php?tip_id=

In /ftplugin/latex-suite/folding.vim I added the lines you see below, so that the latex-suite folding \rf also folds the preamble (the part between \documentclass and \begin{document}.

	" {{{ Preamble
	call AddSyntaxFoldItem (
		\ '^\s*\\documentclass',
		\ '^\s*\\begin{document}',
		\ 0,
		\ 0
		\ )
	" }}}

happy LaTeXing

chris

VimTip 662: Quote unquoted HTML attributes
http://vim.sourceforge.net/tip_view.php?tip_id=

This is a simple regex that can be used to search an HTML file and replace all unquoted attributes with their quoted version.

map <F9> :%s/\([^&^?]\)\(\<[[:alnum:]-]\{-}\)=\([[:alnum:]-#%]\+\)/\1\2="\3"/g<Return>

VimTip 663: Annoyed that some stuff is reset during GUI init?
http://vim.sourceforge.net/tip_view.php?tip_id=

I've always been. t_vb is one of those things that forced me to have a separate
.vimrc and .gvimrc or to fudge around with $GVIMINIT. And while not documented
as such, guioptions seems to get reset as well. Be annoyed no longer:

	if has("gui_running")
		autocmd GUIEnter * source ~/.vimrc
	endif

Make sure your .vimrc is safe for multiple sourcings. autocmds should be
cleared, in particular.

	autocmd!

There may also be more things to take into account I'm not aware of.

Now you can keep all your settings neatly in a single place.

VimTip 664: Vim Easter Egg??
http://vim.sourceforge.net/tip_view.php?tip_id=

I could not successfully verify this on my 6.2 win32 Install. Maybe, I should not believe everything I read! Or does it work for you??

From   http://linuxgazette.net/issue89/vinayak.html
-------
 Easter Egg # 3 (Credit Listing in VIM)
This is a easter egg I recently discovered in the popular editor VIM. Follow the steps and you are in for a surprise.
   1. On the command line edit a file programmers.txt
   2. Get into insert mode by pressing i
   3. Press enter 11 times
   4. Now that you are on the 12th line, type the name Bram Moolenaar
   5. Open a new buffer using the key sequence CTRL+W followed by N
   6. In the new buffer you will see the names of all the people who have contributed to VIM

VimTip 665: Hide & Toggle GUI widgets
http://vim.sourceforge.net/tip_view.php?tip_id=

If you like your GUI clean, but want the option to access all its power, then you might like this tip.

The variable "guioptions" determines what GUI widgets are visible (see :help guioptions).  I personally prefer to have as few widgets visible as possible, until I need them.  To that end, I have the following in my vimrc (thanks to Tim Chase):

"  Turn off useless toolbar
set guioptions-=T

"  Turn off menu bar (toggle with CTRL+F11)
set guioptions-=m

"  Turn off right-hand scroll-bar (toggle with CTRL+F7)
set guioptions-=r

" CTRL+F11 to toggle the menu bar
nmap <C-F11> :if &guioptions=~'m' \| set guioptions-=m \| else \| set guioptions+=m \| endif<cr>

"  CTRL+F7 to toggle the right-hand scroll bar
nmap <C-F7> :if &guioptions=~'r' \| set guioptions-=r \| else \| set guioptions+=r \| endif<cr>

Opera browser fans will find the bindings familiar.

VimTip 666: switch between a *.cpp and matching .h file
http://vim.sourceforge.net/tip_view.php?tip_id=

For programmers, that want to switch from foo.cpp to foo.h (or vice versa)
on a single key stroke, this might help:

map <F4> :e %:p:s,.h$,.X123X,:s,.cpp$,.h,:s,.X123X$,.cpp,<CR>

it maps (on F4) the change of the current filename. The endings
".h" and ".cpp" are exchanged (via the magic ending ".X123X").
You could use ".hpp" or ".c" filename endings by changing
it in the replacement statemtents.

    comments are welcome
    Joerg (j.beyer@web.de)

VimTip 667: Navigate large CSV files more easily
http://vim.sourceforge.net/tip_view.php?tip_id=



I often work with csv files that have dozens or hundreds of items on a line.  Scrolling around to find the 34th item is very hard, specially when the items are of varying lengths -- but this small script makes it a bit easier.

function! CSVH(x)
    execute 'match Keyword /^\([^,]*,\)\{'.a:x.'}\zs[^,]*/'
    execute 'normal ^'.a:x.'f,'
endfunction

command! -nargs=1 Csv :call CSVH(<args>)

Now you can do ':Csv 23' to hilite the 23rd entry in each line and go to the 23rd entry in the current line.

There's also a great tip at http://www.rayninfo.co.uk/vimtips.html about how to make the columns in csv files line up.

VimTip 668: Re-indenting sections : ={motion}
http://vim.sourceforge.net/tip_view.php?tip_id=

It's simple and documented, but I needed some time to find it: when the right indenting (:he indenting) is
chosen, ={motion} re-indents the block. Maybe this could be mentioned in indenting.

VimTip 669: nice window resizing
http://vim.sourceforge.net/tip_view.php?tip_id=

" Map F1 for gvim window resizing
" Put this snippet of code in you .vimrc for nice window resizing.
" Press F1 key to toggle between the three settings .

nmap <F1>    :call ResizeWindow()<CR>
imap <F1>    <ESC><F1>a   " for insert mode

function! ResizeWindow()
    if (has("gui"))
        if s:selectedsize == 1
            let s:selectedsize = 2
	    set number
            set columns=88  " 88 is exactly 80 with :set number
            set lines=35
        elseif s:selectedsize == 2
	    set number
            let s:selectedsize = 3
            set columns=98
            set lines=45
        else  " old school console goodness
            let s:selectedsize = 1
	    set nonumber
            set columns=80
            set lines=25
        endif
    endif
endfunction
let s:selectedsize=1
call ResizeWindow()

VimTip 670: Filtering: deleting some lines with some exeptions
http://vim.sourceforge.net/tip_view.php?tip_id=

I have several hundred file path names in a buffer, each filling a line, e.g. created with vim tip # 659.
About half of them are help files, starting with './help/'  which I want to delete, but I want to keep
the german ones, starting with './help/de/'. Here comes how I do it with VIM:

   :global:^./help/:if (match(getline(line(".")), '^./help/de/') == -1) | delete | endif

VimTip 671: Add a newline after given pattern(s)
http://vim.sourceforge.net/tip_view.php?tip_id=

After having gone numb when trying to de parse HTML source code w/
very long lines, i created the following function, thus macro and
command.  It takes a list of one or more patterns/strings, and adds a
newline after each.  (Wrapping/Indentation is controlled by your own
settings.)

  <code>
  "  Intentionally left incomplete to be complete as needed
  nnoremap ,nl :NewLine

  "  Add line breaks in after given strings/regex
  com! -nargs=+ -range -bar NewLine <line1>,<line2>call AddNewLine(<f-args>)

  function! AddNewLine(...) range
    let str_no = 1

    while str_no <= a:0
      exec 'let var = a:' . str_no

        " ` (backquote) is used as delimiters for s///, which is hard
        "  to distinguish but also is much rarer than delimiters.
        "
        "  And, "No Match found" messages are suppressed (s///e)
        "
        "  (The "exec..." is one long line.)
        exec a:firstline . "," . a:lastline . 's`\(' . var . '\)\($\)\@!`\1\r`ge'

      let str_no = str_no +1
    endwhile

    unlet! var
    unlet str_no
  endfunction
  </code>

VimTip 672: Buffer Bar
http://vim.sourceforge.net/tip_view.php?tip_id=

Hello,

GVim does not have a buffer bar (i.e. a toolbar with buffer names listed), but we can make a simple one
by using (GUI only)

:tearoff Buffers

this will float (:help tearoff) the Buffers menu, giving an easier access to switching buffers. The advantage of
using this floating menu is that we does not have to switch mode and giving commands
everytime we want to switch buffer also it gives the list of files currently being edited.

The problem is that when you switch buffer, the floating menu disappear. To make it always
appear, we can put this command in the .vimrc

autocmd VimEnter * tearoff Buffers

The floating menu will become quite lenghty if we open many buffers, to make it somehow smaller,
we can edit the file menu.vim in $VIMRUNTIME to make it (1) show only the filename,
not with the path and (2) not showing
the delete, refresh, etc, since these command can easily done from command mode (:help buffer).

For the first one, we can set this variable to 0

:let g:bmenu_max_pathlen=0

in our .vimrc

and for the second one, we can use this command (assuming the commands are around lines 563-573,
in my menu.vim -> may differ to yours)

:563-573s/"/'/g
:563-573s/exe/"exe/

the order of these commands does matter. You should check if the command are really located
in those lines, the commands to be commented are

exe 'an <silent> ' . g:bmenu_priority . ".2 &Buffers.&Refresh\\ menu :call <SID>BMShow()<CR>"
exe 'an ' . g:bmenu_priority . ".4 &Buffers.&Delete :bd<CR>"
exe 'an ' . g:bmenu_priority . ".6 &Buffers.&Alternate :b #<CR>"
exe 'an ' . g:bmenu_priority . ".7 &Buffers.&Next :bnext<CR>"
exe 'an ' . g:bmenu_priority . ".8 &Buffers.&Previous :bprev<CR>"
exe 'an ' . g:bmenu_priority . ".9 &Buffers.-SEP- :"

After that, restart gVim.

Thanks.

VimTip 673: dealing with typing ":wq" in insert-mode
http://vim.sourceforge.net/tip_view.php?tip_id=

\" I find myself typing \":wq\" in insert-mode many a time.
\" Add this to your .vimrc.

function WQHelper()
    let x = confirm(\"Current Mode ==  Insert-Mode!\\n Would you like \':wq\'?\",\" &Yes \\n &No\",1,1)
    if x == 1
    silent! :wq
    else
        \"???
    endif
endfunction
iab wq <bs><esc>:call WQHelper()<CR>

VimTip 674: One-liner Replacement for ':sb(uffer) | e(dit) somefile'
http://vim.sourceforge.net/tip_view.php?tip_id=

I prefer to use buffers and split windows [unlike a coworker who shall remain nameless (Bob) who insists on having many, many gvim instances open ;) ].

While rather tedious and error-prone, I was satisfied with the built-in method of splitting the buffer and editing a file... Until today, that is.

Critical mass was achieved after I fat-fingered ':sb | e somefile' four times in a row, leading to these, my first user commands:

"Put this in your .vimrc
command! -nargs=1 -complete=file Sedit sbuffer | edit <args>
command! -nargs=1 -complete=file Vedit vsplit | edit <args>

---------------
Help References
---------------
"User Commands
:help user-commands

"Argument Handling
:help E175

"Command Completion
:help command-completion

Enjoy!

VimTip 675: How to turn off all colors
http://vim.sourceforge.net/tip_view.php?tip_id=

     If you're like me, you don't want a colorful editor.  I spent hours looking for a "turn off all those colors right now!!" command and I couldn't find any help.  After some poking around for a while, I found the commands you need.  Just put these at the end of  your .vimrc file.

syntax off
set nohlsearch
set t_Co=0

     If you don't have a .vimrc file, simply create one in your home directory.
     The commands I have described will work for version 6.1.  If you have some other version, try them and see if they work.
     -mdmiller

VimTip 676: Shortcut key for gvim in Windows XP
http://vim.sourceforge.net/tip_view.php?tip_id=

Purpose: I want to open gvim, in Windows XP, using a shortcut key.
HowTo: I made a shortcut to gvim, and I assigned a shortcut key in the "ProperTies" menu.

Issue: I can start the first instance of gvim, but the same combination will not allow me to start the second instance; it will just display the first one.
HowToFixIssue: I created a shortcut in the Start Menu. Now, I press and release the "WIN" key, and after that, I press "g" once. It can launch an unlimited number of instances of vim. Sometimes, I need to write a script in one instance and to see the output in another.

VimTip 677: quick way to insert opening and closing braces for programmers
http://vim.sourceforge.net/tip_view.php?tip_id=

This insert-mode map is fairly easy.  I will save a lot of keystrokes for
opening and closing braces when programming.  It works best with cindent
on (:set cindent) since vim will automatically indent to the right tabstop.

I mapped it to insert-mode Ctrl-F. (The few unmapped left.)

Example:
<code>
int main() Ctrl-F

will produce:

int main() {
    |
}
</code>

insert the following in your .vimrc file
============================

" Opening and closing braces
imap <C-F> {<CR>}<C-O>O

VimTip 678: Get Diff to Work with SFU 3.5 on Windows XP
http://vim.sourceforge.net/tip_view.php?tip_id=

I was having problems getting the diff utility to work running version 6.2 of VIM from within windows.  I loaded SFU 3.5, Services for Unix, onto Windows XP SP1, to try and take advantage of the included diff utility.  Basically what I have found is that it works out of the box, so long as you DO NOT specify the "icase" parameter with diffopt.

That is, if you have:

diffopt=filler,context:2,icase,iwhite

you will receive E97: Cannot create diffs.  However, if you simply remove the icase parameter and have:

diffopt=filler,context:2,iwhite

Diff will work just fine with SFU 3.5, no special functions or scripts required.  Unless, of cource, you want to ignore case.

VimTip 679: Findlast occurrence of an item
http://vim.sourceforge.net/tip_view.php?tip_id=

Find the last occurrence of an item.

com! -nargs=1 Findlast :execute'normal G<cr>' | :execute':normal ?' . <arg> . '?<cr>'

Put that in your vimrc file.

Usage:
:Findlast item
e.g.
:Findlast 123

with a regular expression, put the regex  inside single quotes
e.g.

:Findlast '\d\d\d'

Explanation:
G   =  Goto line [count], default last line, on the first
			non-blank character (linewise)
? =  Search backward for the [count]'th previous
			occurrence of {pattern} (exclusive)
. = string concatenation

VimTip 680: 'Verbose' vs. "File not found"
http://vim.sourceforge.net/tip_view.php?tip_id=

Problem
-------
I want to run vim with 'verbose' set, but then it gives out a lot of "file not found" messages at startup and at closedown. I'd like to avoid those messages, while still seeing where an option was set whenever I interrogate its value.

Solution
--------
Instead of setting 'verbose' in your vimrc, use autocommands, as follows (for instance)

if &cmdheight == 1
    set cmdheight=2
endif
if &verbose == 0
    augroup late-verbose
        autocmd    VimEnter    *    set verbose=1
        autocmd    VimLeave    *    set verbose=0
    augroup END
endif

Notes
-----
- The idea of the "if" statement is to avoid interfering with a -V argument which might be set in the command-line for debugging.
- The command-line is widened to at least two lines to avoid Hit-Enter prompts on ":set option?" ":edit existing/filename" etc.

VimTip 681: Enhanced Command Window (ECW)
http://vim.sourceforge.net/tip_view.php?tip_id=

"
"Enhanced Command Window
"     Suresh Govindachar March 18, 2004
"
"If you are comfortable
"
"  1) with Vim's modes and
"  2) with using the <ESC> key (meaning
"     you rarely hit <ESC> unnecessarily)
"
"and you
"
"  3) would prefer entering : commands in a modal
"     command window rather than on the command line
"
"Then this tip is for you.

"_____________________________________________________
"Some key features of the command window (see ;help cmdwin)
"that would lead one to be interested in it are:
"
" - One can edit the buffer any way one wants
" - Hitting <CR> results in the line one was one being executed
" - (editing in the command window is much nicer than editing
"   on the command line)

"_____________________________________________________
"Begin with some mappings:

   nmap <ESC> q:<C-W>_
   nmap q/    q/<C-W>_
   nmap q?    q?<C-W>_

   augroup ECW_au
     au!
     au CmdwinEnter * nmap   <ESC> :q<CR>
     au CmdwinLeave * nmap   <ESC> q:<C-W>_

   augroup END

"Simple observation:  with these mappings, one can go
"from normal-mode to cmdwin and back via escape (<ESC>)!

"_____________________________________________________
"Some nice things about the command line that are not present
"in the usual command window are:
"
" - The <UP> and <DOWN> arrow find all the commands that match
"        the text entered to the left of the cursor
" - Hitting <C-D> shows the ways in which the typed text can be
"        completed (see :help cmdline-completion)
"
"It is possible to have similar features in the command-window too.

"For the <UP> <DOWN> feature, add the following au-command event
"triggered maps:
   augroup ECW_au
     " musn't do au! again


     au CmdwinEnter : imap   <UP>    <C-O>y0<C-O>:let@/='^'.@0<CR><C-O>?<ESC><ESC>
     au CmdwinLeave : iunmap <UP>
     au CmdwinEnter : imap   <DOWN>  <C-O>y0<C-O>:let@/='^'.@0<CR><C-O>/<ESC><ESC>
     au CmdwinLeave : iunmap <DOWN>

     au CmdwinLeave : :let @/=""
   augroup END

"Now, while in the command window, going to insert mode and hitting
"the <UP> arrow followed by the n key results in one visiting all
"the commands that match the text to the left of the cursor when
"the <UP> key was hit -- then hitting <CR> while on any line causes
"it to be executed.  Likewise, for the <DOWN> arrow.

"_____________________________________________________
"Next for the <C-D> feature.  This is slightly more complex.
"Begin by adding the following autocommand event triggered maps:

   augroup ECW_au
     " musn't do au! again
     au CmdwinEnter : imap   <C-D> <C-O>y0<C-O>:ECWCtrlD<CR><ESC>
     au CmdwinLeave : iunmap <C-D>
   augroup END

"Then provide this function:  function! s:ECWCtrlD()
"With this function, hitting <C-D> while in insert mode in the
"command window results in more information about the text to
"the left of the cursor appearing on the lines below the cursor.
"This information can left on the command window or removed
"by typing u (undo).
"
"The nature of the information provided by <C-D> depends on what
"is to the left of the cursor:
"
"  If the stuff to the left of the cursor looks, essentially
"  like "map " or "map  foo" then the information provided by
"  <C-D> is the same as the information that appears when the
"  the same stuff is typed on the command line and return is hit.
"
"  If the stuff to the left of the cursor begins, essentially
"  like "sf " or like "find " then what is displayed on <C-D> is
"  the glob of the remaining stuff (after appending the remaining
"  stuff with a *)
"
"  If the stuff to the left of the cursor looks like neither of
"  the above two cases then what is displayed is the glob of the
"  very last non-space separated "word" (after appending that "word"
"  with a *)
"
function! s:ECWCtrlD()

   if (match(@", '^ *[a-z]\?map\s\s*\(\S\S*\)\?\s*$') >=0 )


       let s:foo = @"
       let save_more=&more
       set nomore
       execute ':redir @" |'.s:foo.'|redir END'
       let &more = save_more
       put=@"

       "Keep this next command even though Vim comlains -- it is
       "a work-around for some "unknown bad thing"
       silent normal

       return
   endif

   "sf and find can have space separated arguments
   if (match(@", '^ *\(\(sf\)\|\(find\)\)\ *') >=0 )
       let s:foo = substitute(@", '^ *\(\(sf\)\|\(find\)\)\ *', '', '')
   else  "pick the trailing non-space separated stuff
       let s:foo = substitute(@", '\(.\{-}\)\(\S\S*\s*\)$', '\2', '')
   endif

   let s:foo = substitute(s:foo, '\s*$', '*', '') "OK if ending has two wild-cards
   let @"=glob(s:foo)
   if(@" == "") | let @"='no match' | endif
   put=@"

endfunction
if !exists(":ECWCtrlD")
  command  -nargs=0 ECWCtrlD call s:ECWCtrlD()
endif

"If one wants to get even more fancy, one can start with the map
"
" nmap <S-ESC> :ECWtobedefined
"
" wherein the function ECWtobedefined opens up a new buffer
" in which one can do anything one likes.  Even if this new
" buffer merely mimics the command window, it will the feature
" of co-existing with other buffers -- which is a feature that
" the command window does not have!
"
" That's all for now.
"
" --Suresh
"
finish

VimTip 682: errorformat for Intel ifort 8.0
http://vim.sourceforge.net/tip_view.php?tip_id=

Intel changed the errorformat for their fortran compiler with version 8.0. An errorformat string that works with the new compiler is:

set efm=%E%.%#rror:\ %f\\,\ line\ %l:\ %m,\%-C%.%#,\%-Z\%p^

VimTip 683: HOWTO - Integrate MS .NET and gvim.exe
http://vim.sourceforge.net/tip_view.php?tip_id=

HOWTO: Integrate MS Visual Studio .NET and gvim.exe

[Disclaimer: This is NOT a tip on how to get Vim to run inside of MS Visual Studio .NET. I have not yet found anyone who can make that work, so this is the next best thing. VisVim.dll seems to only work with VS6.]

If you are someone who prefers Vim and uses ( or must use ) MS Visual Studio .NET for development and you have been struggling with a less than perfect integration of the two, this tip may help you tighten that up. I've been working with the two together since .NET came out and this tip is a compilation of all the tricks and setup I use.

THE KEY: Before you do anything else, do this. goto Tools > External Tools > Add:
	Title: &Vim
	Command: C:\Vim\vim62\gvim.exe
	Arguments: +$(CurLine) -- $(ItemPath)
	Initial directory: $(TargetDir)
This will allow you to use the key combination Alt-t-v to open the current file at the current line in a new vim browser. The browser will start at the directory of that file, so ':e .' will edit the directory of that file.

THE SECOND KEY: In order to effectively use the two together and make sure .NET does not complain about it's files changing, goto Tools > Options > Environment > Documents and ensure these two options are checked:
	+ Detect when file is changed outside the environment
	+ Auto-load changes (if not currently modified inside the environment)

CTAGS: This is an obligatory statement, but a lot of MS developers do not know about ctags. Google for it and use it. This enables you to jump to tags, preview function declarations, use tab completion, and ton of things you can't live without. My personal mappings are:
	map <C-[> <C-T>        " use C-] to goto a tag and C-[ to come back up the tag stack
	noremap <C-P> <C-W>}   " use C-P to preview a tag in a small window
For tag completion, there are a TON of options, but i use vimtip #102 because it's simple and does the job:
	inoremap <tab>   <c-r>=InsertTabWrapper("forward")<CR>
	inoremap <s-tab> <c-r>=InsertTabWrapper("backward")<CR>
One snag for ctags on MS is that the tag pathnames require the old dos style pathnames. Use the appropriate DIR switches to figure yours out:
	set tags=./tags,tags,c:/projects/tags,c:/PROGRA~1/MIEEF7~1/tags

If you must use make at the command line ( I don't compile at command line for .NET but i've gotten it working. not sure where this tip was ), use:
	set autowrite
	setlocal errorformat=\ %#%f(%l)\ :\ %#%t%[A-z]%#\ %m
	setlocal makeprg=devenv\ c:/Projects/MySolution.sln\ -build\ release

Lastly, if you are afraid to leave the IDE because you like Visual Assist's file browser, I'm maintaining a script to emulate that behavior [ProjectBrowse.vim]. It requires the unix find command which can be easily obtained via the cygwin win-unix set of utils.
	map <A-o> :ProjectBrowse c:\Projects\<CR>

May the Vim be with you --heina

VimTip 684: Preview Current HTML in Browser on Mac OS X
http://vim.sourceforge.net/tip_view.php?tip_id=

There are a few tips on previewing current HTML documents in a Windows browser, but none I could find for Mac OS X. By studying the others, though, I stumbled on a mapping that works. The <Enter> at the end anticipates the "Hit ENTER or type command to continue" message.

:map <Leader>p :!open -a Safari %<CR><Enter>

VimTip 685: Search without need to escape frontslashes
http://vim.sourceforge.net/tip_view.php?tip_id=

This comes in handy if you have the full path of a file in your clipboard, and want to find it in your current buffer.
Instead of using "/" to search, use "?" then paste.  You don't need to escape the frontslashes, so no need to edit the pattern.
If you wish to search forward, just hit "/" and Enter.

If you want to use it again, use the "?" history, not the "/".

If someone knows an easier way, please let me know!

:help /
:help ?

VimTip 686: Easier Buffer Switching
http://vim.sourceforge.net/tip_view.php?tip_id=

The <C-^> command is very handy for fast buffer switching.  Used by itself, it switches you to the previous buffer you were editing.  With a number before it, it switches to that buffer number.  However, I find it's location on the keyboard inconvenient.

With a few extra mappings, buffer switching can be easy indeed.  Pick an unused, easy-to-type char - I picked \ :
   :nnoremap  \  <C-^>

Put that in your .vimrc.  Now to switch to buffer 13, type 13\.  You can also toggle between 2 buffers by simply pressing \.  This is also handy in insert mode: hit <C-o>13\ and you jump to buffer 13, still in insert mode.

Map it to whatever key you find easiest to press - or simply use <C-^>, it's still useful.

VimTip 687: Mac OS X clipboard sharing
http://vim.sourceforge.net/tip_view.php?tip_id=

As of my knowledge there is no clipboard register for Mac OS X unlike Windows (vimtip #21). However you can use pbcopy/pbpaste command to achieve the same thing.

Example
:.!pbcopy                           "Copy current line clipboard
:4,8!pbcopy                      "Copy line 4 to 8
:!echo "%:p" | pbcopy     "Copy current filename to clipboard

:r !pbpaste                         "Paste clipboard content to current line

For more information, :help filter

VimTip 688: lid & cscope = custom grep
http://vim.sourceforge.net/tip_view.php?tip_id=

Sometimes you want to use quickfix for some other things than grep & make.
You can always replace one of them and then return to what it was.
So, I have in my  .vimrc:
===
fu! Mycscope(func)
    let tmp1=&grepprg
    let tmp2=&grepformat
    set grepformat=%f\ %*[a-zA-Z_0-9]\ %l\ %m
    set grepprg=cscope\ -R\ -L\ -3
    exe "grep ".a:func
    exe "set grepprg=".escape(tmp1,' ')
    exe "set grepformat=".escape(tmp2, ' ')
endf
command -nargs=* CScope :silent call Mycscope("<args>")
===
This will create the command CScope, that does a cscope's "find functions calling this function" with quickfix.
Another example: lid
===
fu! Mylid(arg)
    let tmp1=&grepprg
    set grepprg=lid\ -Rgrep\ -s\ $*
    exe "grep ".a:arg
    exe "set grepprg=".escape(tmp1," ")
endf
command -nargs=* Lid :silent call Mylid("<args>")
===
Bug: sometimes vim is unable to come back from the command, and you have to hit CTRL+C. I have no idea why.

VimTip 689: Word Count
http://vim.sourceforge.net/tip_view.php?tip_id=

To count the words in a file: g<ctrl-g>
To count the words in a block, select the block and once again g<ctrl-g>

The output looks something like this:
  Selected 6 of 358 Lines; 37 of 2281 Words; 186 of 13426 Bytes

For more information, :help 12.5 (http://vimdoc.sourceforge.net/htmldoc/usr_12.html#12.5)

VimTip 690: Reloading a file using a different encoding
http://vim.sourceforge.net/tip_view.php?tip_id=

You can reload a file using a different encoding if vim wasn't able to detect the correct encoding:
    :e ++enc=<encoding>

For example, on Windows in western Europe, the default encoding is latin1. However I often use vim to edit batch files they must be encoded using the console codepage which is is usually cp850 or cp437. So I reload the file using this command:

    :e ++enc=cp850

VimTip 691: gf for standard URL, like file:///C:/myfile.txt
http://vim.sourceforge.net/tip_view.php?tip_id=

To make gf worked for URL, say, file:///C:/myfile.txt
I copy the following to my _vimrc on Windows

au BufReadCmd file:///* exe "bd!|edit ".substitute(expand("<afile>"),"file:/*","","")

Thanks for Bram to offer me such a tip:
http://groups.yahoo.com/group/vim/message/49108

VimTip 692: runtime syntax check for php
http://vim.sourceforge.net/tip_view.php?tip_id=

Ever wanted to just check your php script to see if it had any syntax errors ? Similar to perl -c ?.  You could always do it by doing php -l, with this little macro, you can do it in your buffer.

Just add the following line in your .vimrc, and whenever you want to test, press ctrl b

voila.

map <C-B> :!php -l %<CR>

VimTip 693: One page summary of color schemes
http://vim.sourceforge.net/tip_view.php?tip_id=

With so many color schemes on vim.org to choose from, sometimes it's hard to decide which one(s) to use. I have created a page to show off all the color schemes that I have downloaded from here. Hopefully this page will be useful to the rest of the vim community.

http://www.cs.cmu.edu/~maverick/VimColorSchemeTest/

The page will be updated as I collect more color schemes.

VimTip 694: Really *QUICK SAVE* and back to edit
http://vim.sourceforge.net/tip_view.php?tip_id=

You are about the modify an important file.   You want to save this original file
under a different name (and keep the file view).   Quick, think of a new name...
-- oh, time wasted, for you could have quickly typed in ";s" and got back
to the modification at hand...
________________________

map ;s   :up \| saveas! %:p:r-<C-R>=strftime("%y%m%d")<CR>-bak.txt \| 3sleep \| e #<CR>
"    Dated-BAKUP                    date number format,                re-edit original
"               first update, else changes get lost on re-edit,
"               saves view (attn: write alone does not save view)
"               thus better than generic copy at OS level,
"               but be careful when split editing

_________________________

The above saves the original file with a date-stamp as part of the filename.
Note that it overwrites throughout a single day.   If you want a more
narrow period of time for overwrites, then supplement above map with hour,
min, or seconds. The 3sleep is there just to visually verify that the
save has taken place.

Happy Vimming...

VimTip 695: Naviguer dans l'aide avec un clavier AZERTY
http://vim.sourceforge.net/tip_view.php?tip_id=

Pour naviguer dans l'aide en ligne de Vim, la touche documentée dans l'aide pour suivre les liens (tags) est Ctrl+].
Sur un clavier français, la combinaison de touches est Ctrl+$ (le même code de touche est envoyé à Vim).

PS: This tip is in french because it is only useful for AZERTY keyboard users, which are AFAIK french speaking people.

VimTip 696: Make mouse drag not select text or go into visual mode
http://vim.sourceforge.net/tip_view.php?tip_id=

It drives me crazy that frequently when I click in a window, it goes into visual mode for a few characters and thus I can't type normal command mode commands.  I'm finding I always have to press "v" to exit visual mode before I can use vim again.

I finally figured out how to disable visual mode using the mouse:

noremap <LeftDrag> <LeftMouse>
noremap! <LeftDrag> <LeftMouse>

VimTip 697: FRENCH character maps (not phrenology!)
http://vim.sourceforge.net/tip_view.php?tip_id=

This illustrates the Power of the Pinkie finger...
(ie. the semi-colon for QWERTY keyboards).

I wanted a scheme which was easy to
memorize for French characters.

Take a couple of minutes to study the
pattern below, and its "logical" ordering
alphabetically...  once understood, I
hope it will serve you a lifetime of
writing « les belles lettres  ».

Happy Vimming!
______________

"                   FRENCH Mappings
"  scheme in alphabetic order
"  where _ denotes primary letter
"
"        à _â  ä
"          _ç
"        è _ê  ë  é
"          _î  ï
"          _ô  ö
"        ù _û  ü
"
"         For capital letters, use the ~ or U operator.
"  Note:  French usage does not require putting accents
"  on capital letters, with the exception of Ç, unless
"  you're typing all caps, e.g., Ecoutez ! vs. ÉCOUTEZ !
"
"  Note:  map! for Insert and Command-line, i.e. imap & cmap
"
map! ;z à
map! ;a â
map! ;b ä
map! ;c ç
map! ;d è
map! ;e ê
map! ;f ë
map! ;g é
map! ;i î
map! ;j ï
map! ;o ô
map! ;p ö
imap ;q «  »<Esc>hi
"         ^inserts within Quotations
map! ;t ù
map! ;u û
map! ;v ü

VimTip 698: mbox archive emails
http://vim.sourceforge.net/tip_view.php?tip_id=

1. First see:

http://www.vim.org/maillist.php#help

Follow the instructions to get hold of the archive messages you need. For example, I sent an email to the following address to retrieve mails 43413 to 43512:

vim-get.43413_43512@vim.org

They will be returned as individual attachments to a single mail, one reply per request.

2. Save all the attachments in a new temporary directory, say /tmp/temp.

3. Download the following script:

http://kmail.kde.org/unsupported/xfmail2mbox.sh

4. Run the script, passing the aforementioned directory as an argument:

$ xfmail2mbox /tmp/temp

(where $ indicates a shell command).

This will create a file called /tmp/temp.mbox, an mbox format file of emails found in /tmp/temp

VimTip 699: enable servername capability in vim/xterm
http://vim.sourceforge.net/tip_view.php?tip_id=

This tip applies only to non-GUI vim running in xterm under X11/XWindows (linux, unix or cygwin).

1. When you want to use vim's 'clientserver' features, you have this problem with non-GUI vim under xterm:
  - in vim under xterm, 'servername' is disabled by default even when 'clientserver' feature is compiled into vim.
This is different from GUI gvim, where 'servername' is enabled by default.

2. If you want to enable 'servername' for vim/xterm, the first thing to check is whether vim has
'clientserver' feature compiled-in: do ':version' and check for +clientserver; or do
'vim -h| grep servername' in shell.  If 'clientserver' is compiled in, proceed to step 3.

  If 'clientserver' is not compiled in, you have several choices:
  - symlink vim to gvim (if you have gvim installed).
  - install vim with 'clientserver' support from binaries
  - build vim from sources with clientserver support and install it

3. After you checked that vim has 'clientserver' compiled in, there are several methods to
enable 'servername' for vim/xterm. Methods are listed below:

Method (A) If you the want simplest solution, just define shell aliases:

For csh/tcsh:       alias vim 'vim --servername vim'
For bash/ksh:         alias vim='vim --servername vim'

The drawback of this method is that when vim will not have
servername enabled when started from a script.

Method (B) When you're non-root user and vim is installed system-wide by sysadmin:

- create directory $HOME/myvim: mkdir $HOME/myvim
- add directory $HOME/myvim to your $PATH, but make sure it appears in
the PATH the first, before all other directories, or at least before the directory
where vim is installed (command 'which vim' tells you where)
- do 'which vim'. Remember directory where system-wide vim is installed.
You'll use name of this directory in the next step, in the 2nd line of the script.
- create script called 'vim' in directory $HOME/myvim, with these 2 lines:
#!/bin/sh
exec /usr/local/bin/vim --servername vim "$@"
- nb: you *must* use full pathname in the 2nd line of the script
- chmod a+x $HOME/myvim/vim
- if your shell is tcsh/csh, do 'unhash'

Method (C) When you are root user and you want to enable 'server' for all users;
or when you are non-root user and you installed vim yourself under your $HOME:

- find out where vim is installed: % which vim
- cd to the directory where vim is installed
- remember name of this directory, you'll use in the nest step
in the 2nd line of the script:
- in same directory, create script called 'vim.s' with this contents:
#!/bin/sh
exec /usr/local/bin/vim.bin --servername vim "$@"
- nb: you *must* use full pathname in the 2nd line of the script
- chmod a+x vim.s
- mv vim vim.bin
- mv vim.s vim
Done.
The drawback of this method is that when you reinstall vim, you need to repeat
the renaming and

VimTip 700: indenting for Java
http://vim.sourceforge.net/tip_view.php?tip_id=

I needed to do a few tweaks to .vimrc get Java code looking smooth in vim and I'm passing the joy.  This is probably good for at least 80% of Java programmers.  Hope this helps my fellow Java/Vim peeps.

Randy Solomonson

My .vimrc file:
"Take care of indents for Java.
set autoindent
set si
set shiftwidth=4

"Java annonymous classes.  Sometimes, you have to use them.
set cinoptions+=j1

VimTip 701: Simple code beautifier
http://vim.sourceforge.net/tip_view.php?tip_id=

Occasionally, I get code from other people who, for instance, don't like to put spaces in the for-loops or assignments.
For example, what I get looks like
     for(int j=0;j<size;j++)
            if(vector[j]>d)
and what I would like to see is
     for ( int j = 0; j < size; j ++ )
            if ( vector[j] > d )

Here are a few vimrc lines, that can help. Put them in your .vimrc, or .vim/after/ftplugin/cpp.vim (or whatever language you are using),
then you can beautify at least single lines using one mouse click.

nmenu Misc.Beautify.For          :s/for\s*(\s*/for ( /<CR>:s/\s*)\s*$/ )/<CR>:s/\(\i\+\)\s*=\s*/\1 = /<CR>:s/\s*\([=<>!]=\\|[<>]\)\s*/ \1 /<CR>:s/\s*\(--\\|++\)/\1/<CR>:s/\s*;\s*/; /g<CR>
nmenu Misc.Beautify.Func        :s/\s*)/ )/g<CR>:s/\s*\([(,]\)\s*/\1 /g<CR>:s/(\s\+)/()/g<CR>
nmenu Misc.Beautify.If              :s/if\s*(\s*/if ( /<CR>:s/\s*)\s*$/ )/<CR>:silent s/\s*\([=<>!]=\\|[<>]\)\s*/ \1 /<CR>
nmenu Misc.Beautify.Assign      :s/\s*\([-+*\/&\|]\?\)\s*=\s*/ \1= /g<CR>

(Each nmenu-line must be one single line!)

Tip: if you need to beautify several lines, tear of the menu.

Of course, being simple regexp's, these little helpers can be fooled pretty easily by complicated code, but they should work for 90% of your code.

HTH,
Gabriel.

VimTip 703: Make html auto-readable in vim
http://vim.sourceforge.net/tip_view.php?tip_id=

REPOSTING, all the HTML on LHS of regexp got converted by the WEB server:

function! Mosh_html2text()
    :silent! %s/\&lt;/</g
    :silent! %s/\&gt;/>/g
    :silent! %s/\&amp;/&/g
    :silent! %s/\&quot;/"/g
    :silent! %s/\&nbsp;/ /g
    :silent! %s/\&ntilde;/\~/g
    :silent! %s/\<P>//g
    :silent! %s/\<BR>/ /g
    :silent! %s/\</\?[BI]>/ /g
    :set readonly
endfun
:autocmd BufRead *.htm* :call Mosh_html2text()

" -- Mohsin Ahmed, http://www.cs.albany.edu/~mosh

VimTip 705: Make html auto-readable in vim
http://vim.sourceforge.net/tip_view.php?tip_id=

Make html readable in gvim:

function! Mosh_html2text()
    :silent! %s/&amp;lt;/</g
    :silent! %s/&amp;gt;/>/g
    :silent! %s/&amp;amp;/&/g
    :silent! %s/&amp;quot;/"/g
    :silent! %s/&amp;nbsp;/ /g
    :silent! %s/&amp;ntilde;/\~/g
    :silent! %s/<P>//g
    :silent! %s/<BR>/ /g
    :silent! %s/</\?[BI]>/ /g
    :set readonly
endfun
:autocmd BufRead *.htm* :call Mosh_html2text()

" -- Mohsin Ahmed, http://www.cs.albany.edu/~mosh

VimTip 706: Make html auto-readable in vim
http://vim.sourceforge.net/tip_view.php?tip_id=

Make html readable in gvim, add this to your ~/_vimrc

function! Mosh_html2text()
    :silent! %s/&amp;lt;/</g
    :silent! %s/&amp;gt;/>/g
    :silent! %s/&amp;amp;/&/g
    :silent! %s/&amp;quot;/"/g
    :silent! %s/&amp;nbsp;/ /g
    :silent! %s/&amp;ntilde;/\~/g
    :silent! %s/<P>//g
    :silent! %s/<BR>/^M/g
    :silent! %s/</\?[BI]>/ /g
    :set readonly
endfun
:autocmd BufRead *.htm* :call Mosh_html2text()

" -- Mohsin Ahmed, http://www.cs.albany.edu/~mosh

VimTip 707: Map xmmsctrl commandos in you vimrc file
http://vim.sourceforge.net/tip_view.php?tip_id=

In case you haven't installed xmmsctrl, you can get it by clicking download on this page:

http://user.it.uu.se/~adavid/utils

Add the following to your vimrc file:

"XMMS mappings
map <silent> <F8> :echo substitute(system('xmmsctrl title'), "\n", "", "")<cr>
map <silent> <F9> :call system("xmmsctrl launch")<cr>
map <silent> <S-F9> :call system("xmmsctrl quit")<cr>
map <silent> <F10> :call system("xmmsctrl play")<cr>
map <silent> <S-F10> :call system("xmmsctrl stop")<cr>
map <silent> <F11> :call system("xmmsctrl pause")<cr>
map <silent> <S-F11> :call system("xmmsctrl shuffle")<cr>
map <silent> <F12> :call system("xmmsctrl next")<cr>
map <silent> <S-F12> :call system("xmmsctrl previous")<cr>

VimTip 708: Converting LANG to UTF-8
http://vim.sourceforge.net/tip_view.php?tip_id=

On my system I converted from a single byte character set (any of ISO-8859-15 type sets) to use a variable multi-byte UTF-8 encoding.  When I did so my mappings that used to work that were set in my ~/.vimrc were wrong because my ~/.vimrc was written to assume ISO-8859-1/latin1.  The LANG environment variable set during user login tells GNU libc6 and most programs written for Unix to use a different character encoding by default.  My new setting of LANG=en_US.UTF-8 incorrectly made vim assume that my ~/.vimrc was also written in UTF-8 and stored as if fileencoding=utf-8.  This was a problem for <M-k> meta key bindings.  Also any character code above 127 in UTF-8 is represented by two bytes instead of only one, so any characters above 127 will be misinterpreted after converting.  A quick solution to make your old file work exactly as intended is to wrap your ~/.vimrc at the top and bottom with 'encoding' commands like this:

set encoding=iso-8859-1

[ bulk of ~/.vimrc file]

set encoding=utf-8

This allows the keys to be correctly assigned as intended when the .vimrc was created.  In my case this was before I changed my LANG setting.

In addition to using a new LANG environment variable set in ~/.bashrc (vim correctly reads it and changes to :set encoding=utf-8) I have also set fileencodings=iso-8859-1 in ~/.vimrc so that it matches the system-default locale setting of libc6.  This is so that all old (and new) files on my disk match up with what is expected by the rest of my system.  Vim will automatically do a file conversion upon reading and writing each file.  This seems safe but more testing is required.  The best reference I found for these issues is:

http://www.cl.cam.ac.uk/~mgk25/unicode.html

related vimtips include vimtip #246 vimtip #546 and vimtip #576

VimTip 709: if you create lots of shell scripts
http://vim.sourceforge.net/tip_view.php?tip_id=

If you create lot of shell scripts, then you'll find this useful:

" automatically give executable permissions if filename is *.sh
au BufWritePost *.sh :!chmod a+x <afile>
" automatically insert "#!/bin/sh" line for *.sh files
au BufEnter *.sh if getline(1) == "" | :call setline(1, "#!/bin/sh") | endif
" automatically give executable permissions if file begins with #!/bin/sh
au BufWritePost * if getline(1) =~ "^#!/bin/[a-z]*sh" | silent !chmod a+x <afile> | endif

Yakov Lerner

VimTip 710: Save time by typing and running templates instead of routine code.
http://vim.sourceforge.net/tip_view.php?tip_id=

The idea is pretty simple.
1.There's template script written in perl (see sources below.)
2. and  mapping in visual mode:
vnoremap <F6> :!perl E:\\Devtools\\vim\\vimfiles\\template\truler.pl<CR>

The template markers are:
TS:<Single string template here>
TB:
<multistring template here>
TE:
TF: <template file name >

So now we are typing following templates and get them transformed :-).

Typing this :
TS:public final static int PROXY_TYPE_{$p2}={$p1};
1;HTTP
2;SOCKS
3;SSH
4;HTTPS
5;NOPROXY

Now select this template with values below,  press magic button and 'ta-da',
we have this code :

public final static int PROXY_TYPE_HTTP=1;
public final static int PROXY_TYPE_SOCKS=2;
public final static int PROXY_TYPE_SSH=3;
public final static int PROXY_TYPE_HTTPS=4;
public final static int PROXY_TYPE_NOPROXY=5;

Here's the same with multiline template, type following:
TB:
public {$p1} is{$p2}Established() \{
    return m{$p2};
\}
TE:
boolean;DirectConnection
boolean;SockConnection
boolean;HTTPConnection

and after transforming we'll got this :
protected boolean isDirectConnectionEstablished() {
    return m_DirectConnection;
}

protected boolean isSockConnectionEstablished() {
    return m_SockConnection;
}

protected boolean isHTTPConnectionEstablished() {
    return m_HTTPConnection;
}

I know it's stupid 'copy-paste' and I don't like it, but sometimes  It's required
and that simple script saving my time. Everthing working under Windoze.
Text::Template you can download it from http://search.cpan.org.

Source below:
---truler.pl-------
use Text::Template;
$tb=0; $te=0;$template_str="";
$template_dir="E:\\Devtools\\vim\\vimfiles\\template\\";
while (<STDIN>){

	if (/^TF:.*/){#file


		$_=~/^TF:(.*?)$/;
		$template_file=$1;
		$template = Text::Template->new(SOURCE => $template_dir.$template_file)
		or die "Couldn't construct template: $Text::Template::ERROR";

	}elsif (/^TS:.*/){#line
		$_=~/^TS:(.*?)$/;
		$template_str=$1;
		$template = Text::Template->new(TYPE=> STRING ,SOURCE => "$template_str\n")
		or die "Couldn't construct template: $Text::Template::ERROR";

	}elsif (/^TB:.*/){#line
		$tb=1;
	}elsif (/^TE:.*/){#line
		$te=1;
		$template = Text::Template->new(TYPE=> STRING ,SOURCE => "$template_str\n")
		or die "Couldn't construct template: $Text::Template::ERROR";
	}elsif ($tb==1 && $te==0 ) {
		$template_str.="$_";
	}else {


		if (defined $template) {
			chomp($_);
			@p=split /;/;
			#if ($p > 0) { print "$_\n";


				my %vars = (
					p1 => $p[0],
					p2 => $p[1],
					p3 => $p[2],
					p4 => $p[3],
					p5 => $p[4],
					p6 => $p[5],
					p7 => $p[6],
					p8 => $p[7],
					p9 => $p[8]
				   );
				my $result = $template->fill_in(HASH => \%vars);
				if (defined $result) { print $result }
			#}
	 	} #template_file defined
	}#else of TF
}#end while
--- truler.pl-------

VimTip 711: dynamic tag generation for currect file
http://vim.sourceforge.net/tip_view.php?tip_id=

Ctags will allow to search for a tag associated with identifier(under cursor and/or named).

This script  allows to search for an identifier in current open file without using an identifier, that is
displays the tags file for current opened file.

Shell script:

cat /usr/local/bin/vimlocal.sh
echo | /usr/bin/ctags --extra=+fq --if0=yes --file-scope=yes --fields=+afmikKlnsz --c-types=+cdefgmnpstuvx --c++-types=+cdefgmnpstuvx -x -n --filter "$@"   |  tr -s '[ \t]' '@' |sed -e "s,^\([_-~:A-Za-z]\+\)@\([_-~:A-Za-z]\+\)@\([0-9]\+\).*, \3  \1," | sed -e "s,[_-~A-Za-z]\+::,,"|sort -k1 -n  |uniq

Vim mapping :
map <M-l> <ESC>:!/usr/local/bin/vimlocals.sh % <CR>:

Note :
1. ctags options probably don't have to be so many ... :-)

2. There are more complex alternatives like excellent taglist.vim which will open and IDE type
environment but I prefer simple solutions based on unix command-lines.

VimTip 712: Invert a selection (reverse the letters)
http://vim.sourceforge.net/tip_view.php?tip_id=

The subsitute command is courtesy of Preben 'Peppe' Guldberg

I wrapped the visual mapping around it, to make it simple to use.
Simply enable visual mode (v), highlight the characters you want inverted, and his \is.

For a single workd you can use vw (or viw):
viw\is

vnoremap <silent> <Leader>is :<C-U>let old_reg_a=@a<cr>
                  \\:let old_reg=@"<cr>
                  \\gv"ay
                  \\:let @a=substitute(@a, '.\\(.*\\)\\@=',
                  \\        '\\=@a[strlen(submatch(1))]', 'g')<cr>
                  \\gvc<C-R>a<ESC>
                  \\:let @a=old_reg_a<cr>
                  \\:let @"=old_reg<cr>

For the tip I doubled up all backslashes in the hope this will post correctly.
All backslashes should be single backslashes (depending on how it is displayed).

VimTip 713: Console vs. GUI mappings
http://vim.sourceforge.net/tip_view.php?tip_id=

This is a way to set mappings based on whether GUI or console Vim is running:

function! ModeMapping( guiLhs, termLhs, rhs, ... )
  let mapCommand='map'

  if ( a:0 > 0 )
    let mapCommand=a:1
  endif

  if ( has( "gui_running" ) )
    echo mapCommand . " " . a:guiLhs . " " . a:rhs
  else
    echo mapCommand . " " . a:termLhs . " " . a:rhs
  endif
endfunction

Sample use 1:
	call ModeMapping( "<leader>b", "<leader>c", ":echo 'Salman'<cr>" )

This means that if GUI is running, <leader>b becomes the lhs and the :echo bit becomes the rhs; if no GUI is running, you get <leader>c as the lhs instead.

Sample use 2:
	call ModeMapping( "<leader>a", "<leader>d", "<esc>:echo 'Halim'<cr>gv", 'vmap <buffer>' )

If the GUI is running, <leader>a is the lhs, <esc>:echo etc. is the rhs and the mapp command used is 'vmap <buffer>' (a buffer-specific visual mode mapping).  Note that the last argument is optional (and wasn't there in the last example).

VimTip 714: Version independent installation of (g)vim on MS-Windows
http://vim.sourceforge.net/tip_view.php?tip_id=

Version independent installation of (g)vim on MS-Windows

The installer and the zip versions of the (g)vim distributions for
MS-Windows install (g)vim in a directory hierarchy rooted at vim\vimxy\
where xy in the directory name is the version number. For example, vimxy
would be vim62 for version 6.2. This setup means that the location of
(g)vim.exe is different for every version. This setup makes good sense
if you maintain several versions of vim on your computer. However, if
you only keep one version of (g)vim at a time, it can be convenient to
always have it in the same location. The following shows you one way to
achieve this.

Set up a directory hierarchy as follows
vim\
vim\runtime\
vim\runtime\syntax\
vim\runtime\plugin\
vim\runtime\ftplugin\
vim\runtime\indent\
vim\runtime\doc\
vim\runtime\colors\
vim\runtime\compiler\
vim\runtime\macros\
vim\runtime\tools\
vim\runtime\tutor\
vim\vimfiles\
vim\vimfiles\syntax\
vim\vimfiles\plugin\
vim\vimfiles\ftplugin\
vim\vimfiles\indent\
vim\vimfiles\doc\
vim\vimfiles\colors\
vim\vimfiles\compiler\

1. Put gvim.exe and/or vim.exe, vimrun.exe, xxd.exe, gvimext.dll into vim\

2. Put all the remaining .vim, .txt, and other non-executable files that
are distributed under vim\vimxy\ in to vim\runtime\

3. Put the contents of the distributed vim\vimxy\plugin\ in to
vim\runtime\plugin\ and so on for all the other subdirectories of
vim\vimxy\ including syntax, ftplugin, indent, doc, colors, compiler,
macros, tools, tutor.

4. Put your _vimrc and _gvimrc files in vim\ with the executables.

5. Either ensure that vim\ is in your path, or create shortcuts and/or
batch (bat or cmd) files that can start vim\(g)vim.exe for you.

6. If you have downloaded any scripts from vim.sf.net or elsewhere, put
them in the appropriate spot in the vim\vimfiles\ hierarchy where they
stay separate from the official distribution files in vim\runtime\. In
this way, when you upgrade (g)vim to a newer version, you will not have
to copy, move or do anything with these extra files. For example,
plugins from vim.sf.net go into vim\vimfiles\plugin\ and color scheme
files go into vim\vimfiles\colors\ etc.

7. You are all done. $VIM and $VIMRUNTIME will be set automatically for
you. They will point to vim\ and vim\runtime\ respectively.

VimTip 715: Ignore whitespace in diff operations
http://vim.sourceforge.net/tip_view.php?tip_id=

Because I'm kinda anal about readability in my source files, I end up changing the whitespace in them quite a bit.  For example, I like var declarations to line up, so I have things like:

private static final String      SOME_VAR1   = "This is a var";
private static final String[]    SOME_VAR2   = { "This is a var", "This is a var", "This is a var" };

If I add something that pushes the tab over one, then all these lines get an extra tab stuck in there, meaning that the lines show up as changed in the default VIM set up.

To make this not so, add the "w" command-line option to the MyDiff() function in your _vimrc file.  This file is like in either C:\Vim\Vim62 or C:\Program Files\Vim\Vim62 (if it's not, you should be clever enough to figure out where it is :^).  The default diff call in that function looks like this:

silent execute '!C:\Vim\vim62\diff -a ' . opt . '"' . v:fname_in . '" "' . v:fname_new . '" > "' . v:fname_out . '"'

Just change this to look like this:

silent execute '!C:\Vim\vim62\diff -aw ' . opt . '"' . v:fname_in . '" "' . v:fname_new . '" > "' . v:fname_out . '"'

Just that one option change can make a world of difference!

VimTip 716: calling gvim from vc++ for windows.
http://vim.sourceforge.net/tip_view.php?tip_id=

To bring up gvim from vc++ conviniently (which I do all day,
so I ended up mapping these to function keys with gvim62):

In vc++ do menu->tools->customize->tools:

This allows single gvim window to open any file from msdev:
Name=sendtovim
Command=sendtovim.exe
Argument=<c-z>:cd $(FileDir)<CR>:e $(FilePath)<CR>:$(CurLine)<CR>
Initial Dir=$(FileDir)

If you dont like to use sendtovim.exe, try the --remote option below.

Note: <c-z> brings gvim to foreground - on win2k, gvim gets focus
but won't bring itself to foreground otherwise. You can remove it
if you dont have this bring-to-foreground problem.

Other possible commands you may like are:

To open a new gvim for each file:
Command=gvim.exe
Arguments=+$(CurLine) "$(FilePath)"

Notes: use quotes, when your path/files have spaces in them.

Arguments=:cd $(FileDir)<CR>:e $(FilePath)<CR>:$(CurLine)<CR>/\<$(CurText)\><CR>$(CurCol)|:

This will open vim on the definition of the word under text,
for this you need to have tags file in your source tree:

Arguments=":cd $(FileDir)<CR>:ta $(CurText)<CR>/$(CurText)"

This is the client-server way:

Arguments=--remote +/"\%$(CurLine)l\%$(CurCol)v"  $(FilePath)"

This lets you launch vim with a single key:

In vc++ do menu->tools->customize->keyboard->Tools->UserTool1
Current-key=<Press Pause>

To keep files in sync:
msdev->tools->options->editor select
   1. save files before running tools
   2. Automatically load externally modified files.
   3. Unselect prompt before saving file.

In ~/_vimrc to update externally modified files:
  :set autoread

- Mohsin
http://www.cs.albany.edu/~mosh

VimTip 717: Executing shell command in Explorer's current viewing directory
http://vim.sourceforge.net/tip_view.php?tip_id=

Even thought I can press "c" to switch directory if I want to execute a command in the directory that I am viewing with the explorer.vim plugin, but sometimes I don't want to actually change to that directory to execute it because I want to remain in whatever directory I am in such as a root directory of source files.  So I opened up explorer.vim to see if I can add it directly to the plugin, but I found out that it can call a variable g:explFileHandler that stores the user defined function whenever the key 'x' is pressed on a file or directory.  So I used that to implement executing a command in the viewing directory in my .vimrc as follows:

function! MyFileHandler(filename)
  let oldpath = getcwd()
  let currentdirectory = ""
  if(isdirectory(a:filename))
    let currentdirectory = strpart(a:filename, 0, strlen(a:filename) - 1)
  else
    let currentdirectory = a:filename
  endif
  let lastslash = strridx(currentdirectory, "/")
  let currentdirectory = strpart(currentdirectory, 0, lastslash)
  let usercommand = input(currentdirectory . "# ")
  if(strlen(usercommand) > 0)
    execute "cd " . currentdirectory
    execute "!" . usercommand
    execute "cd " . oldpath
  endif
endfunction

let g:explFileHandler = "MyFileHandler"

It will prompt the user with the directory mimicking a shell prompt where the user can enter the command.

VimTip 718: Use useful title on exit instead of "Thanks for Flying"
http://vim.sourceforge.net/tip_view.php?tip_id=

If you're like me, you go to all the trouble of setting up your shell to put useful information
in your xterm title.  But on quitting VIM, there is no longer ANY useful information in the
xterm title-- only "Thanks for Flying VIM"

Adding this line to your .vimrc will make VIM put the current working directory in the
xterm title on exit.

let &titleold=getcwd()

Should be simple to extend to include other information as well.

VimTip 719: vc6 with python
http://vim.sourceforge.net/tip_view.php?tip_id=

Hi,

== tip 1 ==
This tip has some similarities with http://vim.sourceforge.net/scripts/script.php?script_id=864

If you want to rebuild the entire project in Visual Studio 6++:

function! RebuildAllVC()
python << EOF
   import win32com.client
   obj = win32com.client.GetActiveObject('MSDev.Application')
   obj.RebuildAll()
EOF
endfunction

There are alot more things you can do, check out: http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcug98/html/_asug_application_object.asp
the application in that link is the "obj" in the code.

== tip 2 ==
using VisVim and the new VIM6.3 *-P* option you can get vim to be your default editor inside VS6.

example:
"gvim -P Microsoft Visual C++"

Note: If VS6 hangs VIM won't close, as a consequence there will still be an instance in the taskbar. Kill it if you wan't to restart VS6 and use VIM!

VimTip 720: delete word in FRONT of cursor
http://vim.sourceforge.net/tip_view.php?tip_id=

I usually use the windows shortcut CTRL-DEL which I couldn't find i VIM. I created this

imap <something> <esc>ldei

which will _almost_ do the trick.
The problem occur when the cursor is on column=1. The problem is due to when pressing esc from insert mode the cursor will appear to jump back (try iterating esc->i->esc->i). But when at col=1 the "jump back" will not occur.

VimTip 721: Auto remove white space when saving
http://vim.sourceforge.net/tip_view.php?tip_id=

I think it would be convenient to have Vim automatically remove the white spaces before saving to a file.

Just put the following line in your vimrc file. Everytime you issue a :w command, Vim will automatically have white spaces removed before saving.

autocmd BufWritePre * :%s/\s\+$//

I've tried using FileWritePre, but didn't work. Anybody know why?

VimTip 722: useful mapping for <space> in normal mode: :nnoremap <space> i<space><esc>
http://vim.sourceforge.net/tip_view.php?tip_id=

:nnoremap <space> i<space><esc>

If you manually align things vertically (declarations, ascii tables,
trailing comments), you'll find this simple mapping useful and
keypress-saving.

It makes space in normal mode to push rest of the line to the right.
It inserts space,  leaving cursor in same position.

Example.

We want to align m_foo to be aligned with m_bar:

                 int     m_foo; //  ...
                 mytype_t    m_bar;   // ...

Set cursor right after 'int'. Press space until 'm_foo'
is aligned with 'm_bar'. I like it.

VimTip 723: Sasser security & VIEWFILE names
http://vim.sourceforge.net/tip_view.php?tip_id=

The Microsoft "Security Update" for the Sasser worm has caused the
naming convention of vim VIEW FILES to change.
(Yeah, it is very annoying.  Any good explanations?)

The most obvious shock will be the absence of manually set FOLDS.

Tip:  goto C:\Program Files\Vim\vimfiles\view
and replace the "~" at the start of view file names with
"C=-=+Documents and Settings=+USERNAME"
where USERNAME is set to your username.

For example, for Mr. Molar:

                                 "~=+My Documents=+project.txt=1.vim"
          was renamed to

"C=-=+Documents and Settings=+molar=+My Documents=+project.txt=1.vim"

The naming convention of view files
changed just after the installation of the
following on a PC running XP.
Check your timestamps carefully.
See also
:h mkview
:h loadview

Microsoft Security Bulletin MS04-011
Security Update for Microsoft Windows (835732)
Issued: April 13, 2004
Updated: May 4, 2004
Version: 1.3

File Name: WindowsXP-KB835732-x86-ENU.EXE
Download Size: 2647 KB
Date Published: 4/12/2004
Version: 835732

     Sasser worm (W32.Sasser.A and its variants) is currently circulating on the
     Internet. Microsoft has verified that the worm exploits the Local Security
     Authority Subsystem Service (LSASS).   Be sure to use a FIREWALL to protect
     port 445.

VimTip 724: Add a dashed line under a title in text documents
http://vim.sourceforge.net/tip_view.php?tip_id=

This little map that you can put in your vimrc will format sub-titles in text documents easy.

For example if you type:

This Is A Title
This is not

Using this tip place the curser on the title line and hit \H will produce:

This Is A Title
---------------

This is not

Mapping:

" For convinent headers in text files
nnoremap <Leader>H yypVr-o<Esc>

VimTip 725: Quick mapping for backing up the file
http://vim.sourceforge.net/tip_view.php?tip_id=

Add this simple mapping into your vimrc to make a quick way to backup your document.

" For safe measures lets make a quick backup mapping.
noremap <Leader>b :let x=&backup<Bar>set backup<Bar>write<Bar>let &backup=x<Bar>unlet x<Cr>

VimTip 726: A simple "boss key" mapping or panic button
http://vim.sourceforge.net/tip_view.php?tip_id=

" A panic button! So no one accidentally sees words they arn't supposed to.
noremap <Leader>r ggg?G``

with this in your vimrc you can hit \r in a panic and all the text goes to gibberish. So in case you can't type :wqa! fast enough or :mksession

running this again reverses it. Basically it uses VIM's rot13 command on the whole file. quick simple and easy.

VimTip 727: Helpfiles and avoiding E21: error with fileencoding for *.txt
http://vim.sourceforge.net/tip_view.php?tip_id=

In 1:6.2-532+1 helpfiles was changed back to not beeing compressed anymore since that broke :helpg[rep]. That ment that instead of having the suffix .txt.gz they where back to just .txt. Naturally the helpfiles (opened by :help with friends) opens with 'nomodifiable' set since you are supposed to read them and not edit them. For me that made a problem since i had an :au (auto command) in my .vimrc setting *.txt to have the iso-8859-1 (latin-1) fileencoding. Now I got an error everytime I wanted to use the help system. To overcome this I changed my .vimrc from this:

au BufNewFile,BufRead mutt*,*.txt,*/.followup set tw=77 ai nocindent fileencoding=iso-8859-1

to this:

" 'nomodifiable' disallows changes to 'fileformat' and 'fileencoding' so remove those entries in the else clause
function! Noma_workaround()
  if exists("modifiable")
    set tw=77 ai nocindent fileencoding=iso-8859-1
  else
    set tw=77 ai nocindent
  endif
endfunction

au BufNewFile,BufRead mutt*,*.txt,*/.followup call Noma_workaround()

In short this just mean that I call the Noma_workaround() function to determine if I can set the fileencoding or if that will give an error. In that case I jsut set the other options.

VimTip 731: ObjectiveC in vim (create ctags and use Cocoa syntax file)
http://vim.sourceforge.net/tip_view.php?tip_id=

I have put some explanations on how to create exuberant ctags for ObjectiveC files (".m") here : http://teti.ch/share/cocovim.php
(ctags are used to get a list of methods, classes, etc for fast navigation through files)

On the same page you will find a Cocoa (Mac OS X OpenStep) syntax file.

VimTip 732: On Windows, Quick Launch html and other Microsoft files(Excel,Word) from Vim
http://vim.sourceforge.net/tip_view.php?tip_id=

First, try the following command in your vim.
  :!start explorer http://www.vim.org/
You wll see the vim home page in the brouser. That's OK.

Then, it'll be much quicker if menu icon is defined like ...
Triple crick on url and crick icon then you'll get the url in your brouser.
But inserting new icon is not easy work so replace existing one.

Following is the part of "$VIM_HOME\vim\vim61\menu.vim" that shows
"Open New" icon replaced with "Start Explore" definition.

if 1    " disabled; These are in the Windows menu               " Repaced 0 to 1.
  an 1.135 ToolBar.-sep4-               <Nop>
  "an 1.140 ToolBar.New                 <C-W>n                  " Commented.
  vnoremenu 1.140 ToolBar.New   "wy:!start explorer <C-R>w<CR>  " Added.
  tmenu ToolBar.New             Start Exploler                  " Tool tip added.
  an 1.150 ToolBar.WinSplit             <C-W>s
  ...
  ...
endif

Note:
The named buffer "w" is used for not disturbing clip board.
Remove comment on Tool tip line.

Enjoy vimming on Windows...

VimTip 733: Python the SciTe way...
http://vim.sourceforge.net/tip_view.php?tip_id=

I just discovered vim, I really liked 'split' capability, I'm so used to edit Python source code on SciTe editor, I really missed the default CTRL-1 to check the sintax and F5 to run the script...

So, this is my suggestion, add these lines to your _vimrc file:

autocmd BufRead *.py set makeprg=python\ -c\ \"import\ py_compile,sys;\ sys.stderr=sys.stdout;\ py_compile.compile(r'%')\"
autocmd BufRead *.py set efm=%C\ %.%#,%A\ \ File\ \"%f\"\\,\ line\ %l%.%#,%Z%[%^\ ]%\\@=%m
autocmd BufRead *.py nmap <F5> :!python %<cr>

Make your that python is in your path, now when you open any python file just type ":make" to get the syntax errors, use ":cnext", to move to next error, check the help on make (":help make") for more info on how to navigate errors.

As you are checking now, <F5> is mapped to execute the current script. Also I suggest you to use add the following lines to _vimrc:

autocmd BufRead *.py set tabstop=4
autocmd BufRead *.py set nowrap
autocmd BufRead *.py set go+=b

That will make to use a 4 spaces for you tabstop (only visually), it avoids wrapping your code and will add a bottom scrollbar. Now I like vim a litle bit more.

VimTip 734: fix 'x' command in virtualedit mode (past end-of-file)
http://vim.sourceforge.net/tip_view.php?tip_id=

This tip is useful only for those who use virtualedit mode (set virtualedit=all, or set ve=all).

I like virtualedit mode except for behaviour of 'x' (delete character).
When 'x' is used past end-of-line, it does nothing. I wanted it to jump left
to the actual end-of-line so as to start deleting characters there. Below is
'x' redefinition that does exactly this; and it does not break 'x' in non-virtualedit mode:

" redefine x for virtualEdit so that past end of line, it jumps left to end-of-line
function! Redefine_x_ForVirtualEdit()
    if &ve != "" && col('.') >= col('$')
	 normal $
    endif
endfu!
silent! unmap x
:nnoremap <silent>x x:call Redefine_x_ForVirtualEdit()<cr>

VimTip 735: Mentioning 'fileencoding' and 'bomb' values on the status line
http://vim.sourceforge.net/tip_view.php?tip_id=

This stems with a discussion on the vim-list yesterday and today (27/28 May 2004). It is a modification on one of the examples given under ":help 'statusline'", which is where its workings are explained. (See also ":help expr1" for the if?then:else expression construct).

The (long) line below comes from my vimrc. I recommend copy-paste if you want to use it. It adds, at the left of the right-hand part of the status line, a pair of square brackets containing the value of 'fileencoding' for the file you are editing (or that of 'encoding' if 'fileencoding' is empty). The file's encoding is followed by a comma and B if 'bomb' is functional and has the value 1 (TRUE). Examples are [latin1], [iso-8859-15], [utf-8,B], etc.

The complexity of the value is due in large part to the necessity of (a) specifying explicitly the fields used implicitly when 'statusline' is empty (I hope I didn't forget any of them), and (b) backslash-escaping all spaces and quotation marks.

Now here it is:

if has("statusline")
	set statusline=%<%f\ %h%m%r%=%{\"[\".(&fenc==\"\"?&enc:&fenc).((exists(\"+bomb\")\ &&\ &bomb)?\",B\":\"\").\"]\ \"}%k\ %-14.(%l,%c%V%)\ %P
endif

N.B.
1. The command from "set" to "%P" should be all on one line.
2. This tip is rated as "of Vim 5.7" because I think it uses nothing that is new in version 6. But I've never had any version of Vim earlier than 6.1, which means that I cannot be 100% sure of what works, or not, on version 5. (IMHO, if you still have a version 5 Vim, you should upgrade to a more recent version anyway if it is at all possible.)

Happy Vimming !
Tony.

VimTip 736: non-native fileformat for your statusline
http://vim.sourceforge.net/tip_view.php?tip_id=

I like knowing when a file I open is detected as having a non-native file format.
The way to provide this is a function called from within your statusline.  Add the
following lines to your .vimrc and modify as you prefer.  I run unix, but this can
be slightly altered for other platforms too.  If you are on the mac or dos platforms,
simply substitute unix for your platform name in the fuction.

function ShowFileFormatFlag(var)
        if ( a:var == 'dos' )
                return '[dos]'
        elseif ( a:var == 'mac' )
                return '[mac]'
        else
                return ''
        endif
endfunction
hi  User1 term=bold cterm=bold ctermfg=red ctermbg=darkblue

I call it and color the output of this function red with a blue background. Add
the following string to your :set statusline= line in your .vimrc.

        %1*%{ShowFileFormatFlag(&fileformat)}%*

The %* returns the highlighting to normal,  whatever happens to be set at the time.
This is a function that is called each time the statusline is drawn.  It passes in the
value of the variable fileformat, used locally in the function above via the a:var
variable.

Related tips include #145 and #735.  related help items include :help statusline
:help *hl-User1..9* and :help user-functions.  A wiki page that speaks to vim's
auto-detection of fileformat is located at
http://www.vi-improved.org/wiki/index.php/FileFormat

VimTip 737: Fine tuning syntax colors
http://vim.sourceforge.net/tip_view.php?tip_id=

If you want to change just one or two colors in your syntax highlighting, there is a simpler way other than editing color files (or creating new ones).  For example, I wanted to tweak the default colors a bit, so I added the following lines to my vimrc file:

highlight comment ctermfg=lightblue
highlight constant ctermfg=red

This made the comments and constants easier to read on my screen.  Replace "comment" or "constant" with whatever text type you want to change the color of.  Try experimenting with different colors to see what looks best to you.  (This was NOT gone in the gui vim, as I don't use it/have it installed).

For more info see
/usr/share/vim/doc/usr_06.txt

VimTip 738: fix META-keys when META-keys break out of Insert mode
http://vim.sourceforge.net/tip_view.php?tip_id=

Q: My META-keys don't work. When I press META-key in insert mode,
they break me out out of insert mode and execute some normal-mode
commands.

A: This happens with non-GUI vim under some terminal
emulators -- those which generate escape-sequences for META-characters.
The actually generated escape-sequences are <ESC>a .. <ESC>z.
You must manually configure vim to recognize these escape-sequences
as META-characters, see below. Terminal emulators which are known to
generate these sequences for META-keys are: rxvt (unix), putty (PC),
teraterm (PC). Vim expects characters 225-250 for META-keys.

Here's how to fix META-keys on vim side:
--
- check what your META-keys generate:
  i<press Ctrl-V><press Meta-A>

if you see ^[a (that is, escape character followed by something),
then add this snippet to your vimrc:

--
" fix meta-keys which generate <esc>a .. <esc>z
let c='a'
while c != 'z'
    exec "set <M-".toupper(c).">=\e".c
    exec "imap \e".c." <M-".toupper(c).">"
    let c = nr2char(1+char2nr(c))
endw
--

To fix META-keys definitions manually key-by-key:
   set <M-A>=<press Ctrl-V><press Meta-A>
   :imap <press ctrl-v><press Esc>a <M-A>
; repeat each META-key.

VimTip 739: Writing a valid statusline
http://vim.sourceforge.net/tip_view.php?tip_id=

I wanted to write a good looking statusline, grouping all the informations I need about a file and the environment. The needed things were the filename, the format of this file, its type, the position (line, column) of the cursor, the relative position in the file (%) and the date (day/month/year - hours:minutes).

There is *one* thing to always remember when you write a statusline. You have to escape all the blank characters and the " characters. To escape a character you have to use \, so if you want a whitespace you have to do "\ ".

Now here is the statusline:
set statusline=%F%m%r%h%w\ [FORMAT=%{&ff}]\ [TYPE=%Y]\ [POS=%l,%v][%p%%]\ %{strftime(\"%d/%m/%y\ -\ %H:%M\")}

VimTip 740: vim-vfs wrapper for using vim to edit SFTP and FTP nautilus/gnome-vfs mounts
http://vim.sourceforge.net/tip_view.php?tip_id=

As of at least GNOME 2.6, you can now create a vitural filesystem mount on your nautilus desktop for SFTP and FTP URI's.  Unfortunately,  you can only use applications that support gnome-vfs extensions (namely gedit).   I have created a wrapper script that
will convert the gnome-vfs URI's into pi_netrw compatible ones so that vim can be used
to edit files on these remote mounts.

See http://tjw.org/vim-vfs/

VimTip 741: Outline editing of Python programmes
http://vim.sourceforge.net/tip_view.php?tip_id=

With the folding function of Vim6 (+folding), we can edit the Python programmes similar to outline program editors such as SciTE.

Add follow lines to .vimrc:

 augroup python_prog
  au!
  fun! Python_fold()
    execute 'syntax clear pythonStatement'
    execute 'syntax keyword pythonStatement break continue del'
    execute 'syntax keyword pythonStatement except exec finally'
    execute 'syntax keyword pythonStatement pass print raise'
    execute 'syntax keyword pythonStatement return try'
    execute 'syntax keyword pythonStatement global assert'
    execute 'syntax keyword pythonStatement lambda yield'
    execute 'syntax match pythonStatement /\<def\>/ nextgroup=pythonFunction skipwhite'
    execute 'syntax match pythonStatement /\<class\>/ nextgroup=pythonFunction skipwhite'
    execute 'syntax region pythonFold start="^\z(\s*\)\%(class\|def\)" end="^\%(\n*\z1\s\)\@!" transparent fold'
    execute 'syntax sync minlines=2000 maxlines=4000'
    set autoindent
    set foldmethod=syntax
    " set foldopen=all foldclose=all
    set foldtext=substitute(getline(v:foldstart),'\\t','\ \ \ \ ','g')
    set fillchars=vert:\|,fold:\
    set tabstop=4 shiftwidth=4 nowrap guioptions+=b
  endfun
  autocmd FileType python call Python_fold()
 augroup END

You can use the folding functions (zm, zM, zr, zR, xa, zo, zc, zx...) in editing Python program.

VimTip 742: Change filetype based on directory path
http://vim.sourceforge.net/tip_view.php?tip_id=

I recently installed pyblosxom to do blogging, and I use vim to edit my blog posts.  pyblosxom automatically transforms your .txt files under a certain path into HTML, RSS, or whatever else is appropriate.  Obviously, your .txt files will probably contain HTML, so if you would like to tell vim to use a different syntax highlighting style for files under a directory path, try adding this to your .vimrc:

function SetPathSyntax()
·   if bufname("") =~ "^/path/to/pyblosxom/datadir"
·   ·   set syntax=html
·   endif
endfunction

autocmd BufReadPost * call SetPathSyntax()

VimTip 743: Use Alt+Mouse to select blockwise (MS Word like)
http://vim.sourceforge.net/tip_view.php?tip_id=

If you use mouse to make visual selections, you might have observed that making
blockwise selections is cumbersome (you need to click <LeftMouse> precisely four times). To
make it easier, you can make Vim behave like MS Word using the Alt modifier.

Place the following lines in your vimrc:

  noremap <M-LeftMouse> <LeftMouse><Esc><C-V>
  noremap <M-LeftDrag> <LeftDrag>

You can also change the modifiers and the mousekey to anything else that is valid, e.g:

  noremap <S-RightMouse> <LeftMouse><Esc><C-V>
  noremap <S-RightDrag> <LeftDrag>

VimTip 744: Getting the official distribution's latest: syntax highlighting, runtime, docs, plugins, etc
http://vim.sourceforge.net/tip_view.php?tip_id=

Do you want the latest, official syntax highlighting files, runtime scripts, documents, macros, language support, plugins, etc?  See

	ftp://ftp.home.vim.org/pub/vim/runtime
	ftp://ftp.home.vim.org/pub/vim/runtime/colors
	ftp://ftp.home.vim.org/pub/vim/runtime/compiler
	ftp://ftp.home.vim.org/pub/vim/runtime/doc
	ftp://ftp.home.vim.org/pub/vim/runtime/lang
	ftp://ftp.home.vim.org/pub/vim/runtime/macros
	ftp://ftp.home.vim.org/pub/vim/runtime/syntax
	ftp://ftp.home.vim.org/pub/vim/runtime/tools

Patches and whatnot are distributed on vim-dev, but typically don't contain the updates to files in the directories above.  If you're having a problm with syntax highlighting, for instance, check the syntax repository above just in case its been fixed already.

In my own case, I put experimental versions of syntax highlighting files and plugins that I maintain on http://www.erols.com/astronaut/vim, such as netrw.vim (netrw v46a now supports remote directory listing for example).

VimTip 745: Find $VIMRUNTIME in a bash script
http://vim.sourceforge.net/tip_view.php?tip_id=

I recently needed the value of $VIMRUNTIME in a bash shell script and was forwarded these two terrific solutions I wanted to post publically:

1. by Luc St-Louis

vim --cmd 'echo $VIMRUNTIME' --cmd 'quit' 2> /tmp/VIMRUNTIME.txt
VIMRUNTIME=`perl -pe 's/\r\n//g' /tmp/VIMRUNTIME.txt`
rm -f /tmp/VIMRUNTIME.txt

2. by Jacob Lerner

VIMRUNTIME=`vim -e -T dumb --cmd 'exe "set t_cm=\<C-M>"|echo $VIMRUNTIME|quit' | tr -d '\015' `

Both properly capture Vim's output and handle the trailing line feed, although in remarkable different ways. Feel free to post additional solutions below.

VimTip 746: change cursor color in different modes
http://vim.sourceforge.net/tip_view.php?tip_id=

Sometimes I think I am in insert mode and start writing, then I realize I was in some
other mode when weird thing happen. So I've set a different color and blinking rate for
insert mode and other modes to see at a glance in what mode I am (works only with GUI):

 highlight Cursor   guifg=white  guibg=black
 highlight iCursor  guifg=white  guibg=steelblue
 set guicursor=n-v-c:block-Cursor
 set guicursor+=i:ver100-iCursor
 set guicursor+=n-v-c:blinkon0-Cursor
 set guicursor+=i:blinkwait20-iCursor

see :h guicursor for more options.

VimTip 747: Easily keep runtime files up to date
http://vim.sourceforge.net/tip_view.php?tip_id=

I try to always keep up to date on the latest and greatest patches and runtime files.  It's pretty easy to install the patches against the source code, but there are no patches for the runtime files.

What I do is use an FTP mirroring tool (with a shell script wrapper) that keeps the runtime directory in my source code up-to-date.  I personally use the fmirror tool (from ftp://ftp.sunet.se/pub/nir/ftp/utilities/fmirror/) but I would think any decent tool would work.  Every so often, usually when applying a source patch, I run this script, and watch the output to see if any of the runtime files have been updated.  If so, I change into the vim63/src directory (or whatever version we're at) and do a "make installruntime".

Here's the command I use for fmirror:

/usr/bin/fmirror -k \
    -l $HOME/src/vim63/runtime \
    -p user@domain.com \
    -r /pub/vim/runtime \
    -s ftp.vim.org \
    -S -V3

If there are no changes, I see something like this:

07:36:06 /pub/vim/runtime @ ftp.vim.org -> /home/michael/src/vim63/runtime
07:36:06 Connecting to ftp.vim.org...
07:36:06 Connected.
07:36:08 Remote timezone: -119 minutes from GMT
07:36:11 Mirror finished.

If there are changes, I see the files being downloaded.

Then it's as simple as "cd vim63/src && make installruntime".

Pretty simple and it works for me!  :-)

VimTip 748: Get bright background colors in linux console (framebuffer)
http://vim.sourceforge.net/tip_view.php?tip_id=

To get 16 background colors in a linux framebuffer console to achieve an appearance like in a 16 color xterm, place the following in your .vimrc (you have to use a real escape character instead of <ESC>, try something like <Ctrl-V><ESC>):

if &term =~ "linux"
    if has("terminfo")
        set t_Co=16
        " We use the blink attribute for bright background (console_codes(4)) and the
        " bold attribute for bright foreground. The redefinition of t_AF is necessary
        " for bright "Normal" highlighting to not influence the rest.
	set t_AB=<ESC>[%?%p1%{7}%>%t5%p1%{8}%-%e25%p1%;m<ESC>[4%dm
	set t_AF=<ESC>[%?%p1%{7}%>%t1%p1%{8}%-%e22%p1%;m<ESC>[3%dm
    endif
endif

Pseudo code for the terminfo entry:
    if bgcol > 7
        blink = on (<ESC>[5m)
        bgcolor = bgcol - 8 (<ESC>[4...m)
    else
        blink = off (<ESC>[25m)
        bgcolor = bgcol
    end

    if fgcol > 7
        bold = on (<ESC>[1m)
        fgcolor = fgcol - 8 (<ESC>[3...m)
    else
        bold = off (<ESC>[22m)
        fgcolor = fgcol
    end

VimTip 749: uuencode and uudecode text in Vim
http://vim.sourceforge.net/tip_view.php?tip_id=

Hello, this is a tip for beginners.

When you want to attach something in your email, the uuencode is extremly useful.

This is mapping to uuencode and uudecode in BASE64:
supports normal mode and visual mode.

nnoremap <silent> <Leader>ue :%!uuencode -m /dev/stdout<CR>
nnoremap <silent> <Leader>ud :%!uudecode -o /dev/stdout<CR>
vnoremap <silent> <Leader>ue !uuencode -m /dev/stdout<CR>
vnoremap <silent> <Leader>ud !uudecode -o /dev/stdout<CR>

Assumption: you have uuencode installed in your PATH. (for cygwin it is included in the sharutils package, for unix it should be similar)

Similar mapping can be used to any type of filter, such as the C indenter and C preprosessor.

Hope that helps.

VimTip 750: Underline Using Dashes Automatically
http://vim.sourceforge.net/tip_view.php?tip_id=

I have been using this trick for years but only recently figured out how to add the finishing touch. Basically this technique (best executed as a macro) will take a line of text like this:

A Very Important Tip!!!

and change it to two lines like this

A Very Important Tip!!!
-----------------------

Of course in a constant width editor font, this looks a lot more worthwhile. I use this all the time to highlight headings, etc.

Add this to your .vimrc file:
"cxe- Underline the current line with dashes
map <F5> Yp:s/./-/g^M:let @/=""^M

(Note that ^M's are really returns that you can achieve in Vim with <ctrl-V><ctrl-M>.
The strategy is basically to yank the line you're on with Y, then put it (and your cursor) with p onto the next line. Then comes a single line range substitution that searches for any character and replaces it with a -. The part after the return is only needed by those of us who have hlsearch turned on. I f you don't set the search register to nothing (""), then your whole document will light up and you will need to invest in a seeing eye dog. Note that you can use anything you want instead of - (= and _ spring to mind). Also, I put this under F5, but that's 100% arbitrary and the nice thing about Vim is that you can put it where you want it. And a tip for the tip is that if you use this, you can also easily get a line above AND below the target text. Just do this:
<F5>YkP
Hope someone can find this helpful. (P.S. typing in this form box is torture! The worst thing about Vim is how useless you feel without it!)

VimTip 751: Go to line
http://vim.sourceforge.net/tip_view.php?tip_id=

I do not know if this tips has been given before (not found by searching :-)

A "go to line" mapping, nice if you compile your source code in command prompt and need to go to some specific line quickly while in insert mode

function! GoToLine()
     let ln = inputdialog("Go to line")
     exe ":" . ln
endfunction

imap <C-g> <C-o>:call GoToLine()<CR>
nmap <C-g> :call GoToLine()<CR>

Thanks.

VimTip 752: Make <C-Left> <C-Right> behave like in windows
http://vim.sourceforge.net/tip_view.php?tip_id=

For quite a long time I was annoyed to not be able to use <C-Left> <C-Right> when selecting text in vim. Actually thoses mappings were working but like the W and B keys instead of w and b. The following mappings correct this problem and make those bindings work like in windows.

You may have to enable select-mode for this to work . I personnally source the $VIMRUNTIME/mswin.vim script in my vimrc which make select mode behave like windows. This script is available in the windows distribution of vim. On linux, you may simply put the following command in your vimrc: "behave mswin".
This will make selection work like in windows.

related help topics:
:h select-mode
:h :behave

"editing mapping (make cursor keys work like in windows. ie: <C-Left><C-Right>
"move to next word.
nnoremap <C-Left> b
vnoremap  <C-S-Left> b
nnoremap <C-S-Left> gh<C-O>b
inoremap <C-S-Left> <C-O>gh<C-O>b

nnoremap <C-Right> w
vnoremap  <C-S-Right> w
nnoremap <C-S-Right> gh<C-O>w
inoremap <C-S-Right> <C-O>gh<C-O>w

VimTip 753: Make File|Open dialog track the current file's directory
http://vim.sourceforge.net/tip_view.php?tip_id=

To get the FIle | Open dialog box to default to the current file's directory add:

set browsedir=buffer

to your vimrc file.

VimTip 754: highlighting source between matching curly braces
http://vim.sourceforge.net/tip_view.php?tip_id=

I was getting far too many errors creating ruby cgi-scripts due to missplaced curly braces, so here's my solution.
The following ruby script generates a pattern (see below) used for highlighting a codesection from the curly brace under the cursor to the matching brace. It currently finds 12 recursions, you can generate larger patterns reaching deeper by changing the parameter (n=12) in method "generate".

=== ruby script ===============
def next_iteration(text)
  text.gsub( /#{Regexp.quote("a%(x)*b")}/, "a%(%(a%(x)*b)|%(x))*b" )
end

def generate( text, n )
  1.upto(n){ |i| text = next_iteration( text ) }
  text
end

def to_pattern(text)
  text.gsub(/x/,"\\n|[^ab]").gsub(/a/,"\\{").gsub(/b/,"\\}")
end

ax = generate("a%(x)*b", 12).sub(/b$/,"")
# a = starting brace, b = ending brace, x = characters in between
puts to_pattern( "/\\v%(%##{ax}b)|%(#{ax}%#b)/" )
=== ruby script end ===============
"a" and "b" are synonyms for the starting/ending brace, "x" holds the characters in between, if any. Using recursion, the original pattern "a(x)*b" is expanded to the monstrous pattern seen below.
Btw. - have to use %() for grouping in the pattern, as the normal (captivating) variant cannot be used that often in one pattern...

Append the following to your .vimrc (_vimrc on windows):
highlight ShowMatches guibg=darkgrey guifg=white
au! Cursorhold * exe 'match ShowMatches /\v%(%#\{%(%(\{%(%(\{%(%(\{%(%(\{%(%(\{%(%(\{%(%(\{%(%(\{%(%(\{%(%(\{%(%(\{%(%(\{%(\n|[^\{\}])*\})|%(\n|[^\{\}]))*\})|%(\n|[^\{\}]))*\})|%(\n|[^\{\}]))*\})|%(\n|[^\{\}]))*\})|%(\n|[^\{\}]))*\})|%(\n|[^\{\}]))*\})|%(\n|[^\{\}]))*\})|%(\n|[^\{\}]))*\})|%(\n|[^\{\}]))*\})|%(\n|[^\{\}]))*\})|%(\n|[^\{\}]))*\})|%(\n|[^\{\}]))*\})|%(\{%(%(\{%(%(\{%(%(\{%(%(\{%(%(\{%(%(\{%(%(\{%(%(\{%(%(\{%(%(\{%(%(\{%(%(\{%(\n|[^\{\}])*\})|%(\n|[^\{\}]))*\})|%(\n|[^\{\}]))*\})|%(\n|[^\{\}]))*\})|%(\n|[^\{\}]))*\})|%(\n|[^\{\}]))*\})|%(\n|[^\{\}]))*\})|%(\n|[^\{\}]))*\})|%(\n|[^\{\}]))*\})|%(\n|[^\{\}]))*\})|%(\n|[^\{\}]))*\})|%(\n|[^\{\}]))*\})|%(\n|[^\{\}]))*%#\})/'
set ut=30
vimtip #396, vimtip #177
Up to now, creating a pattern for mixing curly braces and brackets haven't been very successful. The resulting patterns grow far too fast.

VimTip 755: Using an expression in substitute command
http://vim.sourceforge.net/tip_view.php?tip_id=

Hardly a day passes by without teaching me some new trick in vim! Here
is something I stumbled upon recently.

You can use an expression as the replacement string in the substitute
command (:s). When the replacement string starts with "\=" it is
evaluated as an expression. This opens whole new avenue of interesting
possiblities. Here are a few examples:

1. Number all the lines in a file:
:%s/^/\=line('.').'^I'/

2. Number a range of lines (from line 10 to line 20):
:10,20s/^/\=line('.').'^I'/

3. Number a range of lines sequentially starting from 1:
:let counter=0|10,20g//let counter=counter+1|s/^/\=counter.'^I'

4. To number all the paragraphs in range starting from 1:
(assuming the paragraphs are separated by one or more blank lines)
:let counter=0|1,20g/^$\n^\s*[^\s]/let counter=counter+1|+1s/^/\=counter.'^I'

Note: The above command does not work for the first paragraph in the file if
there is no blank line above it.

see also:
:help sub-replace-special
:help sub-replace-expression
Happy vimming :)
:wq

VimTip 756: Windows key as <Esc> in console (FreeBSD)
http://vim.sourceforge.net/tip_view.php?tip_id=

I accidentally found that pressing the Windows key or the right mouse key (present on most modern keyboards for PC's) function as <Esc> in FreeBSD 5.1 in the console version of Vim 6.2 (not tested on other versions or *nixes).

VimTip 757: sample switch between number/nonumber
http://vim.sourceforge.net/tip_view.php?tip_id=

just create 2 functions..
function! NumberNo()
    :set nonumber
    :map <F12> :call NumberYes()<CR>
endfunction

function! NumberYes()
    :set number
    :map <F12> :call NumberNo()<CR>
endfunction
map <F12> :call NumberNo()<CR>

VimTip 758: search and sort by selection
http://vim.sourceforge.net/tip_view.php?tip_id=

Recently I discovered the potential uses of vmap ...

I need to sort log file by some substring (that cannot
be precomputed, because it depends on data).

I would select substring with mouse, then press :g/<S-Insert>/m0
to move matching lines out of the way, it gets tedious,
so here's the automation using vmap:

With tip,
1. you select the any part of the string with
   v<move>
2. then press 0, to move all matching lines to top of the file,
3. or press p, to see other matches.
4. or press $, to move junk to end of file.
5. You figure out more uses.

    " Sort by selection.
    :vmap 0 :<BS><BS><BS><BS><BS>g<M-x>\M<S-Insert><M-x>m0<CR>
    :vmap $ :<BS><BS><BS><BS><BS>g<M-x>\M<S-Insert><M-x>m$<CR>
    :vmap p :<BS><BS><BS><BS><BS>g<M-x>\M<S-Insert><M-x>p<CR>

I used M-x as a delimiter and very non magic \M modifier
to avoid errors on subtrings like 'c:/xyz/*.*'

Mosh

VimTip 759: Selecting your pasted text
http://vim.sourceforge.net/tip_view.php?tip_id=

In my line of work, I often am pasting HTML into a HTML template file. Usually, I'll want to run certain commands on the pasted text to get it indented, formatted and substituted as I like it.

For a while, I would note the line number I was on, pasting the text, entering visual line mode and pressing 18G, or whatever line I wanted to go up to.

But using the special mark, '.  , that you may be familiar with, I was able to select my pasted text much more efficiently. Now I can paste, enter visual mode and press '. . The selection goes back into the document to where the paste began, the place where the last edit took place.

Simple but helpful.

VimTip 760: quickly change to a larger or smaller font (gtk2 gvim)
http://vim.sourceforge.net/tip_view.php?tip_id=

If you regularly switch to a larger or smaller font, for example because someone else looking at your code thinks the letters are too small, or because you want to lay back in your chair while reading a text, this tip is for you.

The following script defines two commands, :LargerFont and :SmallerFont, to allow quick enlargerment of the font used in the gtk2 gui. Adjust the minfontsize and maxfontsize to your needs.

To use this script, put the following code into ~/.vim/plugin/gtk2fontsize.vim or in your ~/.vimrc.

let s:pattern = '^\(.* \)\([1-9][0-9]*\)$'
let s:minfontsize = 6
let s:maxfontsize = 16

function! AdjustFontSize(amount)
	if has("gui_gtk2") && has("gui_running")
		let fontname = substitute(&guifont, s:pattern, '\1', '')
		let cursize = substitute(&guifont, s:pattern, '\2', '')
		let newsize = cursize + a:amount
		if (newsize >= s:minfontsize) && (newsize <= s:maxfontsize)
			let newfont = fontname . newsize
			let &guifont = newfont
		endif
	else
		echoerr "You need to run the GTK2 version of Vim to use this function."
	endif
endfunction

function! LargerFont()
	call AdjustFontSize(1)
endfunction
command! LargerFont call LargerFont()

function! SmallerFont()
	call AdjustFontSize(-1)
endfunction
command! SmallerFont call SmallerFont()

VimTip 761: Reviewing code effectively (using quickfix)
http://vim.sourceforge.net/tip_view.php?tip_id=

Hi,

If you do code reviews on a regular basis, this tip could be of help to you. This tip is about -
1. Helping the reviewer review code
2. Helping the author in collating reviews from various peers
3. Helping the author in fixing the review comments

First learn about quickfix if you don't know about it already (:help quickfix)

If you type your comments in a file in the format as shown below, then the author can use the quickfix mode for zeroing on the exact file/line.
<file_name>:<line_number>: <your comment in a single line>

For filling in the file name/line number automatically, put the following code in your .vimrc/_vimrc/vimrc:
" Code starts
function SavePosition()
   let g:file_name=expand("%:t")
   let g:line_number=line(".")
   let g:reviewer_initials="KG" " Your initials
endfunction
function InsertComment()
   execute "normal i". g:file_name . ":" . g:line_number . ": " . g:reviewer_initials . " - "
   startinsert
endfunction
nmap ,sp :call SavePosition()<CR>
nmap ,ic :call InsertComment()<CR>
" Code ends

Typical review session:
1. A reviewer open the code to review, positions the cursor on the line he wants to comment on and types ",sp"
2. He/She then opens a text file in the same vim session (say my_comment.txt) and types ",ic" - this puts the file name and the line number
3. The comment is typed next to the line number, all in a single line. This makes it possible for the file to be sorted later
4. Send the comments to the author of the code
5. The author collates the inputs from various reviewers into one file (by simply concatenating them) and sorts it. Now the comments are arranged per file, in the order of line numbers (in a file called say, all_comments.txt)
6. Using the :cfile all_comments.txt the author can now navigate through all the comments.

Cheers,
Karthick

VimTip 762: Power FTP coming to Mac!
http://vim.sourceforge.net/tip_view.php?tip_id=

I was really pissed by the lack of VIM support by the FTP applications found on Mac OS X. None of them support VIM as an external editor.

But it's all over!

First off. Download FTPeel (http://freshlysqueezedsoftware.com/products/ftpeel/). It's a great FTP app that has a feature called MagicMirror.
Here is it how it works:
1. Define a local folder as a site root.
2. Define a remote server as the mirror.
3. Drag any files you want mirrored to FTPeel's dock icon!

Well - This features also works from VIM . .! I.e. you open a local file, edit it and press some shortcuts to paste the file to FTPeel - - And FTPeel does it work!

Well, FTPeel had a bug, but I have manually fixed it.

Anyway, to come to the point - Here is what you need to add to your .vimrc:

" FTPeel MagicMirror support
fun! MagicMirrorIt()
    let path = substitute(expand("%:p"), '/', ":", "g")
    let nice_path = substitute(path, "^:", "", "")
    execute('!osascript -e "tell application \"FTPeel\" to open \"' . nice_path . '\""')
endfun

map <C-S> :call MagicMirrorIt()<CR>

Now. First set up FTPeel. Then open your local file and when you want to upload it on the big world wide web - - just hit Control and s!

I think it's pretty smart :-)!

Also as you see it works by doing some Applescript. This is actually a pretty damn smart way of using AppleScript. Maybe there can be made more ways of using Applescript.

Ok, I hope you like my tip!

Kind regards,
Amir
http://amix.dk

VimTip 763: Drag Words with C-left/right.
http://vim.sourceforge.net/tip_view.php?tip_id=

Select a block of chars with C-v <move>, then
press C-l or C-r to drag the selection around.

    :vmap <C-Right> xpgvlolo
    :vmap <C-left>  xhPgvhoho

Just a though, maybe there is already a builtin
way of doing it in vim?



VimTip 764: Unhighlighting searched-for text
http://vim.sourceforge.net/tip_view.php?tip_id=

If you have hlsearch on, you might find it bothersome that a string you've searched for stays highlighted until you make another search or type something like "/asothuse," searching for a random string of characters, as the FAQ recommends.

With a simple mapping, this is a breeze. Add this line to your .vimrc:

:map <F3> :let @/ = "" <CR>

This unsets the "last search pattern" register.

This should be a simpler solution to a common gripe.

VimTip 765: Complete from filetype syntax file
http://vim.sourceforge.net/tip_view.php?tip_id=

I discover nice way to handle completetion from syntax file:

autocmd FileType *  execute "setlocal complete+="."k/usr/share/vim/vim62/syntax/".getbufvar("%","current_syntax").".vim"

Of course substitute "/usr/share/vim/vim62/syntax/" with out path...
Bad of this trick is no ability to handle "-" chars (eg. in XSL) in completetion and
of course complete Vim commands from Syntax file too :(

VimTip 766: Yank last line's content, and trim it to the cursor
http://vim.sourceforge.net/tip_view.php?tip_id=

I often come across these lines below:
                p_ST->localconnectionOption->typeofService = 0;
                p_ST->localconnectionOption->gain = 0;
                p_ST->localconnectionOption->r_reservation = 0
                p_ST->localconnectionOption->r_re

Though Vim has complete mode, it's a wasting time of  repeately typing 'p_ST->local<C-N>->...'. So I write this mapping:

:inoremap <c-f> <ESC>:let g:saved_col=virtcol(".")<CR>ddkYp:exe "normal ".(g:saved_col+1)."\|"<CR>C

Take above lines for example. First, I type one line(with autoindent turn on, the cursor position is shown as "|" after finishing the line with Return):

                p_ST->localconnectionOption->typeofService = 0;
                |

then I use <Tab> and <Space> to move the cursor to the right place:
                p_ST->localconnectionOption->typeofService = 0;
                                                             |

and press <Ctrl>-f, can you see the magic ? It turns out to be:
                p_ST->localconnectionOption->typeofService = 0;
                p_ST->localconnectionOption->|

Fantacy! It saves me lots of time. Hope you like it.

Also, I have something not work out yet. I'd like to position the cursor at the new line according to last line, e.g., use f command to position quickly.

VimTip 767: multiple commands at once
http://vim.sourceforge.net/tip_view.php?tip_id=

you can easily execute more then one command by placing a | between two commands.

e.g. argdo %s/foo/bar/gc | w

by adding | w in tyhe above example the multiple find and replace command doesn't get interupted because the last edited file isn't saved.

VimTip 768: add/change file extension in current buffer
http://vim.sourceforge.net/tip_view.php?tip_id=

-----Original Message-----
From: news [mailto:news@sea.gmane.org]On Behalf Of DogWalker
Sent: Friday, August 13, 2004 7:28 PM
To: vim@vim.org
Subject: saveas copying file path to command line

Say I have a file I have loaded by doing
  :view ~/thud/foo/bar.c
I now want to save it as, say ~/thud/foo/bar.c.txt
Is there some way to copy to the command line
the directory or the full path to bar.c file so I can
save the file with a different name in the same
directory (which is not the working directory)
without having to type in the directory manually?

-----Original Message-----
From: DogWalker [mailto:forestiero@qwest.net]
Sent: Friday, August 13, 2004 10:31 PM
To: Dave Silvia
Subject: Re: saveas copying file path to command line

On Friday 13 August 2004 19:12, you wrote:
> How about:
>
> command! -nargs=1 AddExt execute "saveas ".expand("%:p").<q-args>
> command! -nargs=1 ChgExt execute "saveas ".expand("%:p:r").<q-args>
>
> :AddExt .c
>
> Saves the current buffer's file as the current buffer's filename with '.c'
> appended
>
> :ChgExt .txt
>
> Saves the current buffer's file as the current buffer's filename with the
> extension changed to '.txt'
>
> HTH,
> Dave S.

Thanks a lot for the very helpful response.

-----------------------------------------------------------

see:
:h command
:h <q-args>
:h expand()

VimTip 769: Highlighting Current Line
http://vim.sourceforge.net/tip_view.php?tip_id=

There is another tip vimtip#421 and a script vimscript#555 on how to highlight the current line. But I think that this is much simpler than those.

\%# matches to the current cursor position. Using this one can highlight the whole line

syntax match CurrentLine  /.*\%#.*/
hi link CurrentLine Visual

or

hi CurrentLine guifg=white guibg=lightblue

to switch off the highlightline, simply do

syntax match CurrentLine "NONE"

I have tested this in (g)vim 6.3 on windows XP

VimTip 770: Alternative to the long reach to the <Esc> or the 2 handed <C-]> for insert mode
http://vim.sourceforge.net/tip_view.php?tip_id=

You can use this to toggle between normal and insert mode using the same keystrokes for either.

map <silent> ti :let &insertmode=1-&insertmode<CR>
imap <silent> ti <Esc>:let &insertmode=1-&insertmode<CR>

map <silent> ta :let &insertmode=1-&insertmode ^V| if &insertmode ^V| :startinsert! ^V| endif<CR>
imap <silent> ta <Esc>:let &insertmode=1-&insertmode ^V| if &insertmode ^V| :startinsert! ^V| endif<CR>

The difference between ti and ta is the former toggles inserting at the cursor position while the latter toggles inserting at the end of the line.

Note:  You have to use one pardigm or the other at one time.  Combinations of 'i' and <Esc> work fine.  Combinations of ti and ta also work fine, they just don't mix!

That is, if you ti into insert, you must ti or ta out, <Esc> won't do it.  On the other hand, if you 'i' into insert, ti or ta will take you out and back in again.

See:
  :h map.txt
  :h map-<silent>
  :h map_bar
  :h insertmode
  :h startinsert

VimTip 771: Paste from the clipboard into a new vim
http://vim.sourceforge.net/tip_view.php?tip_id=

Bind a keystroke to "xclip -o | gvim -" ( or "xcb -p 0 | gvim -" or "any command which prints the contents of the clipboard | gvim -")

Pressing that key now captures the contents of the clipboard in a new vim window.

I like to use the key described in sawfish as S-Menu.

VimTip 772: convert numbers, hex to decimal and vice versa via menu
http://vim.sourceforge.net/tip_view.php?tip_id=

A quick way to transform hex numbers to decimal or vice versa.
Visual select the number (no leading '0x' allowed, sorry) and select the menu to transform the number.
You need the calculator 'bc' (standard unix, or cygwin).

UNIX:
vmenu 1.220 PopUp.&nr2hex	<ESC>:exec("!echo \\"obase=16;".@*."\\" \| bc -l -q ")<CR>
vmenu 1.220 PopUp.hex&2nr	<ESC>:exec("!echo \\"ibase=16;".toupper(@*)."\\" \| bc -l -q ")<CR>

Windows:
you have to do somthing like
 <ESC>:!bash -c " <see exec(...) above plus extra escaping> "<CR>

VimTip 773: Make vim and gvim have the same colors
http://vim.sourceforge.net/tip_view.php?tip_id=

" Vim color file
" Maintainer:   Marco Peereboom <slash@peereboom.us>
" Last Change:  August 19, 2004
" Licence:      Public Domain

" Try to emulate standard colors so that gvim == vim

set background=dark
hi clear
if exists("syntax_on")
   syntax reset
endif

let colors_name = "putty2"

hi Normal guifg=White guibg=Black
hi ErrorMsg guibg=Red guifg=White
hi IncSearch gui=reverse
"hi ModeMsg
hi StatusLine gui=reverse
hi StatusLineNC gui=reverse
hi VertSplit gui=reverse
"hi Visual gui=reverse guifg=Red guibg=fg
hi Visual gui=reverse guifg=White guibg=Black
hi VisualNOS gui=underline
hi DiffText guibg=Red
hi Cursor guibg=#004080 guifg=NONE
hi lCursor guibg=Cyan guifg=NONE
hi Directory guifg=Blue
hi LineNr guifg=#BBBB00
hi MoreMsg guifg=SeaGreen
hi NonText guifg=Blue guibg=Black
hi Question guifg=SeaGreen
"hi Search guibg=#BBBB00 guifg=NONE
hi Search guibg=#DDDD00 guifg=NONE
hi SpecialKey guifg=Blue
hi Title guifg=Magenta
hi WarningMsg guifg=Red
hi WildMenu guibg=Cyan guifg=Black
hi Folded guibg=White guifg=DarkBlue
hi FoldColumn guibg=Grey guifg=DarkBlue
hi DiffAdd guibg=LightBlue
hi DiffChange guibg=LightMagenta
hi DiffDelete guifg=Blue guibg=LightCyan
hi Comment guifg=Blue guibg=Black
hi Constant guifg=#BB0000 guibg=Black
hi PreProc guifg=#BB00BB guibg=Black
hi Statement gui=NONE guifg=#BBBB00 guibg=Black
hi Special guifg=#BB00BB guibg=Black
hi Ignore guifg=Grey
hi Identifier guifg=#00BBBB guibg=Black
hi Type guifg=#00BB00 guibg=Black

hi link IncSearch               Visual
hi link String                  Constant
hi link Character               Constant
hi link Number                  Constant
hi link Boolean                 Constant
hi link Float                   Number
hi link Function                Identifier
hi link Conditional             Statement
hi link Repeat                  Statement
hi link Label                   Statement
hi link Operator                Statement
hi link Keyword                 Statement
hi link Exception               Statement
hi link Include                 PreProc
hi link Define                  PreProc
hi link Macro                   PreProc
hi link PreCondit               PreProc
hi link StorageClass            Type
hi link Structure               Type
hi link Typedef                 Type
hi link Tag                     Special
hi link SpecialChar             Special
hi link Delimiter               Special
hi link SpecialComment          Special
hi link Debug                   Special

VimTip 774: gtk gvim and fontconfig
http://vim.sourceforge.net/tip_view.php?tip_id=

I switched over to the GTK version of Vim (because the motif version crashes in
my cygwin environment), and was distressed when I saw that my favorite 6x13 and
7x13 fonts could not be found in the font selection dialog.  I found discussions
on similar situations, like missing 6x13 in Gnome Terminal.

So, I spent some time reading the limited documentation on fontconfig, followed
the suggestions posted here, and mangled my .fonts.config enough to give me
6x13.  "Great!", I thought, "7x13 should be easy now.".  Nope.  For the life of
me, I couldn't get anything but 6x13 and 8x13.

I sympathize with folks using GTK2 applications who have very specific font
preferences.  Even if it's possible to get my 7x13 by messing with
.fonts.config, it's WAAAAYYYYY too difficult!  My understanding is that the
intent is a font selection mechanism that is less platform dependant.
Unfortunately, power and flexibility, the cornerstones of Unix-like OS's,
suffered.  So, here I was, after many hours over the course of several days of
screwing around with fontconfig, feeling like I was dealing with a Microsloth
app.  But, I digress...

I thought I would contribute my work-around; call it a hack, if you like, but it
gets me what I want.  It might save the average X font user time and
frustration:

If misc-fixed fonts are missing completely from your system's fontconfig, just
copy the 6x13, 6x13B, and 6x13O fonts to your own directory somewhere and add
that directory to your own config, and you're done.  For example:

$ mkdir ~/.fonts
$ cp /usr/X11R6/lib/X11/fonts/misc/6x13{,B,O}.pcf.gz ~/.fonts
->add "<dir>~/.fonts</dir>" to ~/.fonts.conf

Then, fontconfig only has THAT font to choose from in the 'fixed' family, and
you're home free.  Unless you want 7x13 too...

I want 7x13 _and_ 6x13, but I can't get fontconfig to differentiate them.  So, I
(very easily) made my own versions of these fonts and put them in their own
families:

  - Get the bdf sources for the fonts.  I just downloaded the source package for
    the fonts that were installed on my system, but they should also be easy to
    find through an internet search.

    $ mkdir ~/newfonts
    $ cp path/to/source/font/7x13{,B,O}.bdf ~/newfonts

  - Edit each of these files, changing the family portion of FONT (i.e. the word
    "Fixed") and the value of FAMILY_NAME to "7x13".  A quick ed script can do
    this to several fonts in a jiffy.

  - Use the bdftopcf utility to create your new fonts:

    $ for font in 7x13 7x13B 7x13O ; do
    >   bdftopcf ./${font}.bdf -o ~/.fonts/${font}.pcf
    > done

  - Now, as long as ~/.fonts is in your ~/.fonts.conf, 7x13 will show up in the
    GTK font selection dialog!

This is a one time thing for the fonts you want, and it actually makes choosing
them in the app easier.

Hope this helps somebody out there....

VimTip 775: Remapping Caps to Shift
http://vim.sourceforge.net/tip_view.php?tip_id=

In "keyword #166" a tip for mapping Caps_Lock to Esc was posted.  I never liked having Caps_Lock as Escape though.  I didn't want an easier way to hit Escape, I wanted to prevent unexpected things from happening when I accidently hit Caps_Lock when I was trying to hit Shift.  With Caps_Lock mapped to escape i still got unexpected results.  So here is how your bind Caps lock to the Shift key under Xwindows:

Just put this in a file in your home directory called .Xmodmap
remove lock = Caps_Lock
keycode 66 = Shift_R
remove shift = Shift_R
add shift = Shift_R

Much thanks to avlondono on the #vim channel for his help with this.

VimTip 776: Deadkeys / Accented Characters and Mutt integration
http://vim.sourceforge.net/tip_view.php?tip_id=

Using Mutt and VIM for my email,  I need to write in Spanish a few times a week, but I'm using a US key layout.

Deadkeys are used for entering accented and special characters.  First you hit a modifier key like apostrophe ( ' ) and then a vowel to get the accented version :  &#972; .

This tip turns the ' ` ^  and " characters into deadkeys to allow for most all characters used in European languages.
Two functions are added to to turn on deadkeys and turn off deadkeys.  Those functions are then mapped to F-keys.   Finally, an addition to your .muttrc helps start vim in a wordprocessing mode.

The bulk of the work was done by Claudio Fleiner at http://www.fleiner.com/vim/deadkey.html .  I just wrapped them into functions for ease of use.
---------------------------------------------------------------------------
.vimrc
---------------------------------------------------------------------------
nm <F6> :call DeadKeys()<CR>
nm <F7> :call DeadKeysOff()<CR>

function! DeadKeys()
    :echo "Dead Keys: On"
    let g:DeadKeysOn=1
    " map dead keys
    :imap "a    ä
    :imap "A    Ä
    :imap "e    ë
    :imap "E    Ë
    :imap "i    ï
    :imap "I    Ï
    :imap "o    ö
    :imap "O    Ö
    :imap "u    ü
    :imap "U    Ü
    :imap "y    ÿ
    :imap "<space>    ""<bs>
    :imap ""    ""<bs>

    :imap 'a    á
    :imap 'A    Á
    :imap 'e    é
    :imap 'E    É
    :imap 'i    í
    :imap 'I    Í
    :imap 'o    ó
    :imap 'O    Ó
    :imap 'u    ú
    :imap 'U    Ú
    :imap 'y    ý
    :imap ''    ''<bs>
    :imap '<space>    ''<bs>

    :imap 'c    ç
    :imap 'C    Ç

    :imap `a    à
    :imap `A    À
    :imap `e    è
    :imap `E    È
    :imap `i    ì
    :imap `I    Ì
    :imap `o    ò
    :imap 'O    Ó
    :imap 'u    ú
    :imap 'U    Ú
    :imap 'y    ý
    :imap ''    ''<bs>
    :imap '<space>    ''<bs>

    :imap 'c    ç
    :imap 'C    Ç

    :imap `a    à
    :imap `A    À
    :imap `e    è
    :imap `E    È
    :imap `i    ì
    :imap `I    Ì
    :imap `o    ò
    :imap `O    Ò
    :imap `u    ù
    :imap `U    Ù
    :imap ``    ``<bs>
    :imap `<space>    ``<bs>

    :imap ^a    â
    :imap ^A    Â
    :imap ^e    ê
    :imap ^E    Ê
    :imap ^i    î
    :imap ^I    Î
    :imap ^o    ô
    :imap ^O    Ô
    :imap ^u    û
    :imap ^U    Û
    :imap ^y    xxxx
    :iunmap ^y " this one was giving me problems.
    :imap ^^    ^^<bs>
    :imap ^<space>    ^^<bs>

    :imap ~n    ñ
    :imap ~N    Ñ
    :imap ~~    ~~<bs>
    :imap ~<space>    ~~<bs>
endfunction " deadkeys()

function! DeadKeysOff()
    " Make sure turning them off without having turned them on
    " does nothing bad.
    if !exists("g:DeadKeysOn") || !g:DeadKeysOn
        :echo "Dead Keys not on."
        return
    endif
    :echo "Dead Keys: Off"
    let g:DeadKeysOn=0
    :iunmap "a
    :iunmap "A
    :iunmap "e
    :iunmap "E
    :iunmap "i
    :iunmap "I
    :iunmap "o
    :iunmap "O
    :iunmap "u
    :iunmap "U
    :iunmap "y
    :iunmap ""
    :iunmap "<space>

    :iunmap 'a
    :iunmap 'A
    :iunmap 'e
    :iunmap 'E
    :iunmap 'i
    :iunmap 'I
    :iunmap 'o
    :iunmap 'O
    :iunmap 'u
    :iunmap 'U
    :iunmap 'y
    :iunmap '<space>
    :iunmap ''

    :iunmap 'c
    :iunmap 'C

    :iunmap `a
    :iunmap `A
    :iunmap `e
    :iunmap `E
    :iunmap `i
    :iunmap `I
    :iunmap `o
    :iunmap `O
    :iunmap `u
    :iunmap `U
    :iunmap `<space>
    :iunmap ``

    :iunmap ^a
    :iunmap ^A
    :iunmap ^e
    :iunmap ^E
    :iunmap ^i
    :iunmap ^I
    :iunmap ^o
    :iunmap ^O
    :iunmap ^u
    :iunmap ^U
    ":iunmap ^y
    :iunmap ^^
    :iunmap ^<space>

    :iunmap ~n
    :iunmap ~N
    :iunmap ~~
    :iunmap ~<space>

endfunction

---------------------------------------------------------------------------
.muttrc
---------------------------------------------------------------------------
# Make VI into wordprocessor mode -- auto wrap, backspace to previous line
set editor="vim -c 'set tw=76' -c 'set fo=tcq' -c 'set bs=eol' -c 'set wrap'"

VimTip 777: More words searching
http://vim.sourceforge.net/tip_view.php?tip_id=

Searching a word is nice thing. As you could find in Vim tips, you can search it very fast with ' * ' or ' # ', without
typing word in command window. But what about a searching words or lines? Of course, you type ' / ',  and type words
or line like '/a few words', or '/some example line with few words'. Too much typing.

So we can do this much faster. For example, you yank whole line with ' yy ' or ' y$ ', type ' / ' and press <C-R>"
(Control-R and type "). You will see that line pasted. You can even go in visual mode (' v '), select text with move keys, type ' y '
and past it (<C-R>") again; (or you can select text with mouse if you don't like move keys). This is not only for lines, you can select word
or select as many words as you wish.

Here is little bit of explanation for <C-R>. When you type ' / ' (go in search mode), and after that type <C-R>, you will see
' " ' character. Here Vim ask you to type register number or character from whom will paste content. You can type ' " '(temporary
register), 0-9, a-z, etc. even special registers like ' / '(previous search), ' % '(file name), or more better ' . '(register that contain last inserted word). If you want to see all registers and their content, type ' :display ', and paste what you like.

Note, here i placed quotes in ' character, and " character means that you'll need to type it.

Happy searching !

VimTip 778: Speed up Pythoner coding
http://vim.sourceforge.net/tip_view.php?tip_id=

If you are a Pythoner, I introduce two script file: SuperTab(vimscript #182) and pyCallTips(vimscript #1074). I think they can reduce times of typing and speed up Python coding one times at least. the SuperTab is a very cool script that complete automatically word under the cursor. The pyCallTips is a very useful script . It popup  a window at the bottom of vim in where display the calltips of word under your cursor when you type word. if Both of two script are used together, it will generate perfect effect. let me show you how to do.

The first step is that download and install both of them. Then edit complType="\<C-p>" to complType="\<C-n>" in line 21 in the SuperTab script file. This step is to fix SuperTab script searching backward to forward. And the order of searching is the same as display in the pyCallTips script. Now you create a new Python file, and input:
    import os
and  press <F4>, I call it a "refresh key". Then you continue and input:
    os.ch
 when you type word, you'll find changing continually in the bottom window call "Python Calltips  window". When you input "os.ch", it display like this in the calltips window:
    os.chdir            chdir(path) Change the current working directory to the specified path.
    os.chmod            chmod(path, mode) Change the access permissions of a file.

Maybe the first word "os.chdir" is what you want, you can press <Tab> key, and you'll find the word under the cursor is completed automatically. If you want is "os.chmod", you pree <Tab> key again, "os.chmod" will be completed. It is useful, isn't it?

It will work well mostly. But if you type like: (it's a example only)
    import sys
    sys.argv[1:].c

It display in the calltips window:
    sys.argv.count       L.count(value) -> integer -- return number of occurrences of value

It is real what you want, but the <Tab> key can't work. Don't worry, the pyCalltips map five key to solve the problem. It is <Alt-1> ... <Alt-5>. You can press <Alt-1> to select the first word, and <Alt-2> to the second, and so on. if the key is not enough, you can map it yourself in the script file.

If you open an exist python file, you don't press <F4> key until you type new "import xxx" or "from xxx import xxx". you can also remap <F4> to other key.

That's all. I wish you enjoy it.

VimTip 779: OEM to ANSI conversion
http://vim.sourceforge.net/tip_view.php?tip_id=

I am using Windows 2000, US system. I have a bunch of text files coming from a DOS machine (OEM charset), with characters above code 127. I would like to convert those files into ANSI charset, so that I can see those characters appropriately everywhere under windows. I looked in newsgroup and other places on how to do this, but found nothing. I came up with this (took me a while, but this seems to be working):

open the file - with vim of course:)
:set encoding=cp437
:set fileencoding=latin1
:wq

you can now reopen the file and the characters should have been converted. I perfer to quit after the conversion so that encoding and fileencoding are reset, but I supopse you can simply set encoding back to latin1.

cp437 is the code page for the OEM charset.
see :help encoding and :help fileencoding

VimTip 780: Generalized VISUAL CONTENT onto COMMAND-LINE
http://vim.sourceforge.net/tip_view.php?tip_id=

Key idea:  Yank the visual area for use on the command-line.

Key use:  searches, complex substitutions, etc.

Refinement:  Make sure all magic characters are escaped.
(Thanks to vimtip #777 for this.)
Focus on the content of the visual -- independent
of how it was formatted.

Usage:  visual on the area, and hit the TAB key.

DISCUSSION:  imagine searching for this line in your text:
"The price of foobars is $1.89 [see page 7]."

Typing it out literally will not work:

     :/The price of foobars is $1.89 [see page 7]./

The problem is the magic characters.  Escaping them will make it work:

     :/The price of foobars is \$1\.89 \[see page 7\]\./

We really don't have to type it out, just use yank and the " register.
And let vim automatically figure out how to properly escape...

Now suppose elsewhere in the text we have this:
"The price of foobars
is $1.89 [see page 7]."

Will our previous command work?  No.   It's MULTI-LINE.
Here's what would work:
     :/The\_s\+price\_s\+of\_s\+foobars\_s\+is\_s\+\$1\.89\_s\+\[see\_s\+page\_s\+7\]\./

That would work even on this:
"The price
of foobars is     $1.89
[see page 7]."

That's independence from formatting!
The secret is the substitution function using whitespace \_s\+
and the 'one or more' operator.

The CODE which magically puts the discussion
into action (three versions):

"               Yank the " register onto the command-line.
"X- vmap <C-I>  y:/<C-R>"/
"                       ^ plain version without escaping out of magic characters.
"X- vmap <C-I>  y:/<C-R>=escape(@", '\/.*$^~[]')<CR>/
"                        ^ now more fancy.
vmap     <C-I>  y:/<C-R>=substitute(escape(@", '\/.*$^~[]'), "[ \t\n]\\+", "\\\\_s\\\\+", "g")<CR>/
"                                    visual ^ HIGHLIGHTED text placed on the COMMAND LINE.
"                      Input <CR> to perform a SEARCH-,
"                      otherwise EDIT the COMMAND-LINE containing the yanked text.
"                 Function ESCAPE to prevent magic characters.
"                 4-tuple function SUBSTITUTE will generalize white spaces & EOL,
"                                  ^ so that string will be independent of formatting!
"  USAGE:  visual on desired area, and simply hit TAB.
"          To search, follow up by carriage return.
"          Else, you may modify the command line to suit your purpose.

VimTip 781: Changing the hotkey for "&Diff with Vim"
http://vim.sourceforge.net/tip_view.php?tip_id=

"&Diff with Vim" is a handy tool to have in Explorer, but it's more common to "&Delete" multiple files via the File menu or context menu by hitting the 'd' hotkey. Personally, I'd rather have the hotkey be changed to 'f', which isn't occupied, making the command "Di&ff with Vim".

To do this, edit the gvimext.dll file in your vim installation directory (e.g., C:\Program Files\Vim\vim63\gvimext.dll). Note that this is a binary file but you can still get it done with Vim. Look for the string "Diff with Vim", and simply move the '&' from its original position to a new one (in our case, before one of the f's). Restart your computer (or at least the explorer process) and you'll see the new menu item.

VimTip 782: Jump to definition of entity under cursor
http://vim.sourceforge.net/tip_view.php?tip_id=

This is what I use when reading/editing DTDs that make use of entities heavily:

:map <Leader>e yiw ?<!ENTITY % <C-R>"<CR>

That will map <Leader>e to search backwards for the definition of the entity under the cursor, then you can just CTRL-o back to where you were. Makes reading DTDs less painful. A second version of this should support external entities, anyone feel obliged? :)

VimTip 783: Use the return key to get out of insert mode
http://vim.sourceforge.net/tip_view.php?tip_id=

I found myself spending way too much time in insert mode, because it takes so much effort to hit <ESC>, or alternatively <C-[>. To train myself to use insert mode only for what it's meant for - namely inserting text - I wanted to make it as easy as possible for myself to get out of insert mode.

My solution: map <CR> to <ESC>! Pressing the return key at the end of an insert operation feels very natural, and it is one of the more accessible keys on the keyboard. For inserting multiline text, you can use shift-return, which really doesn't take that much getting used to.

If you want to give it a try, put the following in your .vimrc:

inoremap <CR> <ESC>

VimTip 784: Word under cursor for command
http://vim.sourceforge.net/tip_view.php?tip_id=

During editing, there are many situations where one would like to do a command based on the word under cursor. Idea is to yank into a register and then use this register automatically.  Basis of this functionality are two commands
1) Yanking into a register
     e.g: "zyw - will yank the word into z reg, "byy - yanks the line into b reg
 2)  Concatenating the register to a command and executing it.
     e.g:  :exe "/".@z.""<CR>  - searches for string in z reg

Some more e.g:
a) Lets say that you have a file that has a list of files.  You don't want to edit all the files, but selectively.
     :map <F2> "zyw:exe "vs ".@z.""<CR>
      Pressing <F2> will open the file in vertically split window
b) Browsing a text file and saving all those difficult words you want to refer to during leisure
     Open the text file and in a split window open an empty file.
    :map <F2> "zyw<C-w>wo<Esc>"zp<C-w>w
    yank the word under cursor, change window, paste and return
c)  Help in help in help
     :help
     :map <F3> "zyw:exe  "h ".@z.""<CR>
     Press <F3> on any word and we can see vim help for that keyword.

More examples left to the fertile imagination of the reader. Attraction of this, to me, is to use the key strokes that we use normally to automate tasks. We can write these mappings on the fly for new type of tasks, or include in the .vimrc for routine tasks.

Have fun and as Bram says Happy Vimming!!!

VimTip 785: Toggle Between Tabs and Spaces
http://vim.sourceforge.net/tip_view.php?tip_id=

I write code for a large company and often work with other developer's code.  I personally don't choose to use all the language/formatting stuff in Vim, but I do like to quickly switch between using tabs and using spaces when I hit the <TAB> key (to integrate with the "current" file formatting).

Here is a snippit from my .vimrc which enables my default settings (using 4 spaces for every <TAB>) and a mapping to <F9> to toggle the settings:

    " virtual tabstops using spaces
    set shiftwidth=4
    set softtabstop=4
    expandtab

    " allow toggling between local and default mode
    function TabToggle()
        if &expandtab
            set shiftwidth=8
            set softtabstop=0
            noexpandtab
        else
            set shiftwidth=4
            set softtabstop=4
            expandtab
        endif
    endfunction
    nmap <F9> mz:execute TabToggle()<CR>'z

VimTip 786: Character-set translation
http://vim.sourceforge.net/tip_view.php?tip_id=

Benji Fisher's foo.vim (vimscript #72) contains a Transform command that I initially thought would be very helpful:  I tend to swap double and single quotation marks around, as well as other pairs of characters.  Unfortunately, the original command fails in this case.  Below is an updated version which is probably slower, but more powerful, as well as a map for my favorite way to use it.

Also included is a character-switching function I developed in the process, but ended up including inline for efficiency.  It turns out that directly assigning to a character in a string (let string[i] = a:new[pos]) is illegal, probably because the rhs can include more than one byte.  StrSwitchPos() takes care of that, but doesn't enforce a single-byte replacement.

" Translate character sets, either in the current line, on a range, or in a string
" Note that in this version, unmatched characters in old are deleted
command! -nargs=* -range Transform <line1>,<line2> call Transform(<f-args>)
function! Transform(old, new, ...)
  let string = a:0 ? a:1 : getline('.')


  let i = strlen(string)
  while i > 0
    let i = i - 1
    let pos = stridx(a:old, string[i])
    if pos > -1
      let string = strpart(string, 0, i) . a:new[pos] . strpart(string, i + 1)
    endif
  endwhile


  if a:0
    return string
  else
    call setline('.', string)
  endif
endfunction

noremap <silent> "" :Transform "' '"<CR>

" Spin-off from the above: switch a single character specified by index
fun! StrSwitchPos(string, pos, char)
  return strpart(a:string, 0, a:pos) . a:char . strpart(a:string, a:pos + 1)
endfun

VimTip 787: A mapping that invokes a function with a count prefix.
http://vim.sourceforge.net/tip_view.php?tip_id=

" Echoes "Foo: 42" when one types "42,a".

function! Foo(count)
  echo 'Foo: ' . a:count
endfunction

command! -nargs=1 FooCmd call Foo(<args>)

map ,a :<C-U>FooCmd(v:count)<CR>

VimTip 789: Automatically redate file headers
http://vim.sourceforge.net/tip_view.php?tip_id=

I keep forgetting to change the dates in my file headers.  Even though it isn't extremely important before the release time, I found it helpful to automate the process.  The following is tuned more for Rebol headers than anything else, but it works for most types of files.  As a bonus, it increments the last part of a version field; that can be commented out if it isn't desired.

I should probably search for the end of headers marked by comment leaders (such as Vim scripts), but haven't gotten around to it.  It also fails to find version numbers that don't terminate at the end of the line.

  "Redate file headers automatically
  autocmd BufWritePre * call RedateHeader()
  function! RedateHeader()
    " Mark the current position, and find the end of the header (if possible)
    silent! normal! msHmtgg$%
    let lastline = line('.')
    if lastline == 1
      " Header not found, so use fifteen lines or the full file
      let lastline = Min(15, line('$'))
    endif


    " Replace any timestamps discovered, in whatever format
    silent! execute '1,' . lastline . 's/\m\%(date\|changed\?\|modifi\w\+\):\s\+"\?\zs\%(\a\|\d\|[/, :-]\)*/\=strftime("%d-%b-%Y")/ie'


    " Increment the version marker
    silent! execute '1,' . lastline . "g/[Vv]ersion:/normal! $\<C-a>"


    " Restore the marked position
    silent! normal! 'tzt`s
  endf


  function! Min(number, ...)
    let result = a:number
    let index = a:0
    while index > 0
      let result = (a:{index} > result) ? result : a:{index}
      let index = index - 1
    endwhile
    return result
  endf

VimTip 790: ms-word files (viewing and diff'ing)
http://vim.sourceforge.net/tip_view.php?tip_id=

antiword (http://www.winfield.demon.nl/) is written by Adri van Os
windows version can be found at:
(http://www.informatik.uni-frankfurt.de/~markus/antiword/)

download and install it (and put it in your path)

antiword takes a ms-word filename from the command line and spits it out in text/plain. it does not take input from stdin

all you gotta do to get vim to view ms-word files is to add lines to your .vimrc similar to:

autocmd BufReadPre *.doc set ro
autocmd BufReadPre *.doc set hlsearch!
autocmd BufReadPost *.doc %!antiword "%"

now, when you're curious you can do: vim resume.doc to view a text version of your ms-word document (hitting <enter> on .doc file in your .vimprojects list works too)

but that's not too fun on it's own.

one thing ms-word can't do (properly), is do a diff on two versions.
however, if you're on a windows system, in explorer, try -> selecting resume-1.1.doc and resume-1.2.doc -> right click -> "Diff with Vim"

you could probably also do: vim -d resume-1.1.doc resume-1.2.doc
to achieve the same effect

VimTip 791: How to Search for a "non-Ascii Character"
http://vim.sourceforge.net/tip_view.php?tip_id=

Occasionally when you've pasted into VIM from some other application, you get a pesky visible non-ascii character. You can do a ga command to see what it is, but you might want to search for it or substitute it; here's a technique:-

place cursor on the character.

yl            # yank one character into unnamed buffer
/<C-R>"   # pull unnamed buffer contents onto search  (that's Control-R)

:h ga
:h c_ctrl-r

VimTip 792: Preloading registers
http://vim.sourceforge.net/tip_view.php?tip_id=

There never seem to be enough spare keys for maps.

It's possible however to preload VIMs registers in .vimrc with your frequent commands eg

let @m=":'a,'bs/"
let @s=":%!sort -u"

here's a twisted one
let @y='yy@"'

The command is executed by doing a @m

You can overwrite them of course when doing a recording or a plain yank; I prefer to leave registers a-q for yanks or recordings and preload the others

VimTip 793: searching phrases visually module spaces.
http://vim.sourceforge.net/tip_view.php?tip_id=

This builds on two previous tips to search for sentences.

What: To re-search for a phrase again, ignoring space differences.

How: Visually select a phrase with the mouse and press //
 to find the phrase again (modulo spaces).

    :vmap <silent> //    y/<C-R>=substitute(escape(@", '\\/.*$^~[]'),"[ \\t\\r\\n]\\+","\\\\_s\\\\+","g")<CR><CR>

How, it escapes metachars in selection,
and changes spaces in selection to generic space+.

HTTP post might garble the backslashes in the mapping above, it
has 2,2,2,2,2,4,4 backslashes.

- Mosh http://www.cs.albany.edu/~mosh




VimTip 794: Scripting - Indirectly Referencing Variables
http://vim.sourceforge.net/tip_view.php?tip_id=

It is possible to indirectly reference a variable using {} (curly braces) in your VIM script. This give you the ability to build up variable names on-the-fly and subseqnetly reference the data that those variables hold.

For example:

:let richard_name = "Richard"
:let name_pointer="richard_name"
:echo {name_pointer}

will display the string "Richard" on screen

Another example:

:let richard_name = "Richard"
:let alan_name = "Alan"
:let postfix="_name"
:let name_pointer = "richard" . postfix
:echo {name_pointer}
:let name_pointer = "alan" . postfix
:echo {name_pointer}

will display "Richard" then "Alan" on screen.

VimTip 795: Simulating arrays with VIM
http://vim.sourceforge.net/tip_view.php?tip_id=

It is possible to simulate arrays in VIM, without recourse to third party scripts or libraries. This can be done by dynamically constructing variable names, and then referencing their data.

For example, implementing a 1 dimensional array :

:let interests_0="Running"
:let interests_1="Swimming"
:let interests_2="Inline Skating"
:let interests_3="Cycling"
:let j = 0
:while j < 4
:  let entry = 'interests_' . j
:  echo entry . ':'
:  echo {entry}
:  let j = j + 1
:endwhile

This can be extended to 2 or more dimensional arrays :

:let interests_0_0="Walking"
:let interests_0_1="Running"
:let interests_0_2="Jogging"
:let interests_1_0="Backstroke"
:let interests_1_1="Butterfly"
:let interests_1_2="Front Crawl"
:let j = 0
:while j < 2
:  let i = 0
:  while i < 3
:    let entry = 'interests_' . j . '_' . i
:    echo entry . ':'
:    echo {entry}
:    let i = i + 1
:  endwhile
:  let j = j + 1
:endwhile

Or arrays of records :

:let academic_0_graduation_year="1995"
:let academic_0_college="Bristol Polytechnic"
:let academic_1_graduation_year="1998"
:let academic_1_college="Bristol University"
:let j = 0
:while j < 2
:  let year = 'academic_' . j . '_graduation_year'
:  echo {year}
:  let college = 'academic_' . j . '_college'
:  echo {college}
:  let j = j + 1
:endwhile

VimTip 796: Search only over a visual range
http://vim.sourceforge.net/tip_view.php?tip_id=

If you want to be able to select an area of text within a file and then search for occurrences of a string only within that selection.  Then you can add the following to your .vimrc.

This creates 2 visual maps, / and ?, the same command you would use in normal mode.  Visually select a range and press /, enter your usual regex and hit enter.

function! RangeSearch(direction)
  call inputsave()
  let g:srchstr = input(a:direction)
  call inputrestore()
  if strlen(g:srchstr) > 0
      let g:srchstr = g:srchstr.
                  \ '\%>'.(line("'<")-1).'l'.
                  \ '\%<'.(line("'>")+1).'l'
  else
      let g:srchstr = ''
  endif
endfunction
" Each map should be on a single line
vnoremap <silent> / :<C-U>call RangeSearch('/')<CR>:if strlen(g:srchstr) > 0\|exec '/'.g:srchstr\|endif<CR>
vnoremap <silent> ? :<C-U>call RangeSearch('?')<CR>:if strlen(g:srchstr) > 0\|exec '?'.g:srchstr\|endif<CR>

The execute is performed outside of the function so that the values remain highlighted (based on the hlsearch option), and the search history is automatically updated.  So if you press / (in normal mode instead of visual mode) and press the up arrow, you will see your previous search which can be easily modified.

VimTip 797: All folds open at startup or just openen file
http://vim.sourceforge.net/tip_view.php?tip_id=

when you set foldmethod=indent all folds are closed when you open a file. If you set the foldlevel to a high setting files are always started with opened folds. Put the settings below in your .vimrc

set foldmethod=indent
set foldlevel=20

VimTip 798: Split current window and search for word under cursor in new window
http://vim.sourceforge.net/tip_view.php?tip_id=

:map zm :let @/=expand("<cword>") <BAR> split <BAR> execute 'normal n'<CR>

See
:h cword
:h <BAR>
:h split

*** -----Original Message-----
*** From: Chandrasekaran V. [mailto:chandrasekaran_v@hotmail.com]
*** Sent: Friday, October 01, 2004 6:58 PM
*** To: vim@vim.org
*** Subject: Searching in another (split) window
***
***
*** Hi all,
***     Is it possible through a key mapping sequence, to do the following:
***
*** I have a file open in split windows. ie., only two windows are
*** active and
*** both have the same file.
*** I want to initiate a search of a word under the cursor in one
*** window and let
*** the other window
*** show the place where the search-hit happened, while the current window
*** doesn't change its
*** view. Is this possible to do using some key mapping? Please let me know.
***
***    Thanks a lot,
***    chandra.

This is rather rudimentary, but it works.  Feel free to enhance to your liking:

	:map zm :let @/=expand("<cword>") <BAR> wincmd w <BAR> execute 'normal n'<CR>

Then for successive matches, just type 'n' or '/<CR>', etc.  Use normal window motion command to return to original window.  E.G.:

	:wincmd w

	<C-W>w

	[mouse click on desired window]

Or, better still:

	:map zm :let @/=expand("<cword>") <BAR> split <BAR> execute 'normal n'<CR>

This just splits the current window and starts you at the next occurrence of the word under the cursor in the new split.  Repeat search as usual.  Close the split window when you're done.  You return to the original window at the cursor position you left.

HTH:

thx,
Dave S.

VimTip 799: Searching for files
http://vim.sourceforge.net/tip_view.php?tip_id=

You can add the following to you .vimrc file:

" find files
fun! FindFiles()
  let $filename =  input("Enter file name to find: ")
  let $error_file = $HOME."/.findfile.output"
  silent! exe "!find . -iname \"".$filename."\" \| xargs file \| perl -pe 's/:/:1:/' > ".$error_file
  cfile $error_file
  copen
  redraw!
endfun
nmap \f :call FindFiles()<CR>

Then, when in normal mode, type "\f" (or any other mapping that you prefer). This will give a prompt for a file name pattern to search for. Then, all the file names that match this pattern (under the current directory) will be displayed in the quich fix window, along with a description of each of one of them.

Notice, the search is done in a recursive manner. It is case insensitive, and you can use wildcards. If you want to use a regular expression, you can call "find" with the "-regex" or "-iregex" flags.

Background:
The function uses some standard gnu *nix utitlities: find, file.
You also need perl to be installed.

VimTip 800: Sorting lines in a file based on the number of words in each line
http://vim.sourceforge.net/tip_view.php?tip_id=

Here is one use of the substitute with an expression (:help
sub-replace-expression) I needed to sort a file according to the number of
words in each line. Using the :s command, at the begining of each line, I
insert the number of words it contains.

To simplify sorting (using the excellent VisSort, see
http://mysite.verizon.net/astronaut/vim/), instead of inserting a number, I put
the corresponding character (plus 64, to start with A).

Here is the expression I use:

"%s/^.*/\=nr2char(strlen((substitute(substitute(submatch(0), "\\S\\+", "x", "g"), "\\s","","g")))+64) . "\t" . submatch(0)

Now decomposed in parts, from the inside out:
part 1 = substitute(submatch(0), "\\S\\+", "x", "g")
  replace all consecutive non space by a single x (each word is now a single x)

part 2 = (substitute(part 1),"\\s","","g")
  remove the spaces between "x"


part 3 =  (strlen(part 2)
  count the number of "x"

part 4 = nr2char(part 3)+64
  get the ASCII char representing the number of words + 64


I replace all lines (^.*) by that ASCII char, followed by a tab and the initial line itself.

I can then sort, then remove all characters between the begining of lines and
the first tab.



VimTip 801: Folding of (gnu)make output
http://vim.sourceforge.net/tip_view.php?tip_id=

I regularly use the compiler output window of the QuickFix feature (see help on 'quickfix' and 'copen') to navigate the compiler output. Working on a largish software system with multiple directories with subdirectories in them, the list can get quite long. I use the following entries in my .vimrc to automatically fold on each subdirectory, and open folds containing errors (the string 'error:'). Aditionally 'zw' open also the folds containing the string 'warning:', while 'zq' switches back to the original.

"Folding of (gnu)make output
au BufReadPost quickfix setlocal foldmethod=marker
au BufReadPost quickfix setlocal foldmarker=Entering\ directory,Leaving\ directory
au BufReadPost quickfix map <buffer> <silent> zq zM:g/error:/normal zv<cr>
au BufReadPost quickfix map <buffer> <silent> zw zq:g/warning:/normal zv<cr>
au BufReadPost quickfix normal zq

VimTip 802: Specify what you do not want to have in a search and other helpful searches.
http://vim.sourceforge.net/tip_view.php?tip_id=

Sometimes, I found useful to specify in a search or a substitution what I do not want to have. There is a way with Vim to do such a thing:
/^\(\(The_Regular_Expression\)\@!.\)*$

This will find everything but the regular expression you have specified. For example, if we want to find all the lines not containing the word 'foo', simply do:
/^\(\(.*foo.*\)\@!.\)*$

If we want to find a more complex regular expression on multiple lines, like all the lines which do not begin with 'foo' with 'bar' somewhere else and the word 'magic' at the end of the next line, do:
/^\(\(^foo.*bar.*\n.*magic$\)\@!.\)*$

Another thing useful in searches and substitutions is to ommit some information, for instance, suppose we want to find every 'foo' with 'bar' somewhere else on the line, but we do not want to take the 'bar' part in the search (let's say not highlight it if the hlsearch is set), we can do:
/foo\(.*bar\)\@=
/foo.*\(bar\)\@=
/foo.\{-}\(bar\)\@=

The first one will highlight only 'foo' in lines containing both 'foo' and 'bar'. The second one will highlight 'foo' and everything up to the longest much where 'bar' appear on the line. The third one, will do the same thing, but with the shortest match (non-greedy). So, if there is more than one 'bar' on the same line, the search will stop right before the first occurrence of 'bar'.

We can also do the opposite. Let's say for example finding all the 'foo' with 'bar' some place else without highlighting the 'foo', we can do:
/\(foo.*\)\@<=bar
/\(foo\)\@<=.*bar
/\(foo\)\@<=.\{-}bar

The first one will highlight only 'bar' in lines containing both 'foo' and 'bar'. The second one will highlight everything right after 'foo' up to the last 'bar' on the line. The third one will highlight everything right after 'foo' and up to the first 'bar' (non-greedy).

There is also a way to specify that a part of the regular expression should not be there. As an example, if we want to search for all the lines where there is no word 'foo' preceding the word 'bar', we can do:
/\(foo.*\)\@<!bar

Or, on the other sie, find all the word 'foo' where there is no 'bar' following, we can do:
/foo\(.*bar\)\@!

Now, let's see another kind of search. Imagine we want to find every 'bar' where there is no 'foo' before it. We can do such a thing

There is a way with vim to specify where the beginning of the search pattern should start. As an example, suppose we want to find the lines beginning with 'foo', with the word 'bar' somewhere else and then 'magic', but that we only want to highlight 'magic' and everything up to the end to the line. We can use 'zs' for that like this:
/^foo.*bar.*\zsmagic.*

We can also do the opposite, specify where the search sould stop highlight, for example, if we want to highlight every 'foo' with 'bar' with 'magic' but not highlighting 'magic', we can do:
/foo.*bar.*\zemagic
/foo.*bar.\{-}\zemagic

The last example was non-greedy, that is, mathches up to the first occurence of the word 'magic' in a line.

Other interesting searches are the beginning of a file. For example to find the first word of a file, we can do (this one needs the +syntax feature when compiled):
/\%^\_.\{-}\<.\{-}\>

Or the first occurence of a word in a file:
/\%^\_.\{-}\zsVIM

We can also search for something at the end of a file. For example, the last occurence of 'VIM' in a file (this one is tricky):
/VIM\ze\(\(VIM\)\@!\_.\)*\%$

It finds the word 'VIM' where there is no word 'VIM' after it until the end of the file!

There are a lot of other searches of substitutions pattern out there. But I use these very often for complex substitution (often for multiple line purpose).

For more information, you can type:
:h /\@=
:h /\@!
:h /\@<=
:h /\@<!
:h /\@>
:h /\zs
:h /\ze
:h /\%^
:h /\%$

VimTip 803: Saving a file
http://vim.sourceforge.net/tip_view.php?tip_id=

In order to save a file you'll have to come out of the insert mode, commonly by hitting the Esc key.

Once you are up there to hit the Esc key, why not make it save the file too with a few more hits.
This can be done by simply adding the following line in the .vimrc file:

map <Esc><Esc> :w <CR>

Note: Mapping with a single Esc is somehow causing problems with the Up/Down/Left/Right arrow keys.

VimTip 804: single 'tags' file for a source tree
http://vim.sourceforge.net/tip_view.php?tip_id=

At the top of a source tree, create a tags file by

% ctags -R

(assuming Exuberant Ctags).  The -R (or --recurse) option tells ctags to recurse into directories.

Then, set the tags option in ~/.vimrc as

set tags=tags;

The last semicolon is the key here.  When Vim tries to locate the 'tags' file, it first looks at the current directory, and then looks at the parent directory, then the parent of the parent...

This setting works nicely together with 'set autochdir'.  You need +path-extra feature for this tip.  Also see *file-searching* .

VimTip 805: Windows: gvim as an external editor
http://vim.sourceforge.net/tip_view.php?tip_id=

This tip provides a (Windows only) means of using gvim as an external
editor for almost any other program. This script has been tested with
Lotus Notes and Internet Explorer on Windows NT.

This tip was written using gvim from internet explorer.

Step 1.
=======
Download a copy of clipbrd.vim (vimscript#1014) and put it in your
plugin directory. Modify clipbrd.vim by adding a line as shown below to
the autocommand block in clipbrd.vim:

  aug ClipBrd
    au!
    exec 'au BufWriteCmd ' . auTitle .' :call <SID>UpdateRegister(0, 1)'
    exec 'au BufReadCmd ' . auTitle .' :call <SID>ViewRegister()'

    exec 'au VimLeave ' .auTitle .' :norm gg"*yG'        " <-- this line

  aug END

Step 2.
=======
The vbscript below should be saved as something like runvim.vbs and put
it in your c:\vim\vim6x\ directory. Create a shortcut to runvim.vbs on
your desktop. Right-click on the shortcut, select "Properties" from
the context menu, click the "Shorcut" tab and add a "Shortcut Key" --
something like: "Ctrl-Alt-V".

-----8<-----
set oShell = CreateObject("WScript.Shell")
oShell.SendKeys"^a"
oShell.SendKeys"^c"
oShell.SendKeys"^{Home}"
ReturnCode = oShell.run ("c:\\vim\\vim63\\gvim.exe +ClipBrd +only",0,True)
oShell.SendKeys"^a"
oShell.SendKeys"^v"
oShell.SendKeys"^{Home}"
-----8<-----

Usage:
======
Now when you want to use vim to edit some text in your employers' crappy
email client or web browser just move your cursor to the text area and
hit Ctrl-Alt-V. The current text will be copied into gvim where it can
be edited. Once you are finished editing, quit without saving (:q!). Your
edited text should now appear in the text area.

VimTip 806: Always keep quickfix window at specified height
http://vim.sourceforge.net/tip_view.php?tip_id=

When I use Vim I have multiple windows open which are all maximized after becoming active, see for example vimtip #173

This makes debugging code in combination with the quickfix window a little difficult. After switching from the quickfix window to the code, the quickfix window is minimized and the error message is out of sight. Put the following in your .gvimrc to keep the quickfix window at a user specified height:

" Maximize the window after entering it, be sure to keep the quickfix window
" at the specified height.
au WinEnter * call MaximizeAndResizeQuickfix(8)

" Maximize current window and set the quickfix window to the specified height.
function MaximizeAndResizeQuickfix(quickfixHeight)
	" Redraw after executing the function.
	set lazyredraw

	" Ignore WinEnter events for now.
	set ei=WinEnter

	" Maximize current window.
	wincmd _

	" If the current window is the quickfix window
	if (getbufvar(winbufnr(winnr()), "&buftype") == "quickfix")
		" Maximize previous window, and resize the quickfix window to the
		" specified height.
		wincmd p
		resize
		wincmd p
		exe "resize " . a:quickfixHeight
	else
		" Current window isn't the quickfix window, loop over all windows to
		" find it (if it exists...)
		let i = 1
		let currBufNr = winbufnr(i)
		while (currBufNr != -1)
			" If the buffer in window i is the quickfix buffer.
			if (getbufvar(currBufNr, "&buftype") == "quickfix")
				" Go to the quickfix window, set height to quickfixHeight, and jump to the previous
				" window.
				exe i . "wincmd w"
				exe "resize " . a:quickfixHeight
				wincmd p
				break
			endif
			let i = i + 1
			let currBufNr = winbufnr(i)
		endwhile
	endif
	set ei-=WinEnter
	set nolazyredraw
endfunction

As an added bonus; map ,m to the make command and let the quickfix window pop up if there were any errors:

" Remap ,m to make and open error window if there are any errors. If there
" weren't any errors, the current window is maximized.
map <silent> ,m :mak<CR><CR>:cw<CR>:call MaximizeIfNotQuickfix()<CR>

" Maximizes the current window if it is not the quickfix window.
function MaximizeIfNotQuickfix()
	if (getbufvar(winbufnr(winnr()), "&buftype") != "quickfix")
		wincmd _
	endif
endfunction

VimTip 807: Backing up and commenting .vimrc
http://vim.sourceforge.net/tip_view.php?tip_id=

Hi,
1) BACKING UP .VIMRC :You can always easily reinstall VIM however the loss of your .vimrc could be a catastrophe!

So remember to variously back it up. One good place is to store it as, say vimrc.txt, on your free webspace then you can recover it from anywhere.

2) COMMENTING .VIMRC : My .vimrc now has 348 lines, but about 50% is deadwood because it's no longer clear to me what it's supposed to do, wish I'd thought of this tip years ago!. In .vimrc you use the double quote as a comment

e.g.
" open search result in a new window (the comment)
map zm :let @/=expand("<cword>") <BAR> split <BAR> execute 'normal n'<CR>

VimTip 808: how to overwrite a visual-block of text with another such block
http://vim.sourceforge.net/tip_view.php?tip_id=

One may overwrite a visual-block of text with another visual-block of text by:

   1.  Pick the first block: ctrl-v move "ay
   2.  Pick the second block: ctrl-v move c ctrl-o "aP <esc>

VimTip 809: GNU\Linux - gvim as an external editor
http://vim.sourceforge.net/tip_view.php?tip_id=

The script, external-edit, provides the windows only functionality of vimtip#805 to GNU/Linux (or any *nix) systems with X Windows.

This script does not rely on clipbrd.vim script -- it uses a temporary file to pass the clipboard to gvim. This tip is actually not gvim specific but can be configured to use any external editor.

This script is still under development. New versions will be available from http://bur.st/~benc/external-edit.html.

----------external-edit----------
#!/bin/sh
##################################################
#
# external-edit: launches an external editor from within an X11 Application.
#
# Author: Ben Collerson { benc [at] bur [dot] st }
# Copyright: 2004 Ben Collerson
# Lastchange: 2004 Oct 24
# License: GPL version 2.0 or later (http://www.gnu.org/copyleft/gpl.html)
#
# Install:
# =======
# NOTE: These installation instructions are targeted towards a Debian
# system. To install on a non-Debian system you will need to reinterpret
# these instructions.
#
# First you will need to install the required packages some of which
# are part of Debian so become root and do the following:
#
#   apt-get install xbase-clients xautomation
#
# You will also need to install wmctrl. This is not currently a Debian
# Package. The source is available from http://sweb.cz/tripie/utils/wmctrl/
#
# Wmctrl is a \"command line tool to interact with an EWMH/NetWM
# compatible X Window Manager\". This means that this tip will not work
# if you are using a particularly old window manager, however most modern
# WMs should be okay -- including the default Gnome and KDE Window Managers.
#
# More info is available at the wmctrl link provided above.
#
# Once you have the source tarball for wmctrl extract it and do a
#
#   ./configure && make && su -c make install
#
# Once wmctrl is installed your system put this script somewhere handy
# such as ~/bin/external-edit and chmod +x ~/bin/external-edit
#
# Usage:
# =====
# using your favourite keygrabber/window manager bind a key combination
# (eg: Ctrl-Alt-V) to a command like the following:
#
#   external-edit /usr/bin/gvim -f
#
# For my fluxbox/bbkeys configuration I have the following in my .bbkeysrc:
#
#   KeyToGrab(V), WithModifier(Mod1+Control), WithAction(ExecCommand),
#                 DoThis(/home/ben/bin/external-edit gvim -f)
#
# Note: the editor you specify must be executed so it does not fork
# (ie. gvim -f). When executed the editor must allow the script to wait
# until the editor has finished executing.
#
###############################################################3

# editor plus arguments (except filename) passed on command line
editor=$*

# this gets the window id of the window with focus
winid=`xdpyinfo | sed -ne \'s/^focus:.*\\(0x[^,]\\+\\).*/\\1/p\'`
# and this gets window title
wintitle=`xwininfo -id $winid | sed -ne \'s/xwininfo: .*\"\\([^\"]\\+\\)\"/\\1/p\'`

mytemp=`mktemp`

# copy text using application keyboard short-cuts
case $wintitle in
  *Mozilla*)
  xte << EOM
sleep 1
keydown Alt_L
key a
keyup Alt_L
keydown Control_L
key c
sleep 1
key Home
keyup Control_L
EOM
  ;;
  *)
  xte << EOM
sleep 1
keydown Control_L
key a
key c
sleep 1
key Home
keyup Control_L
EOM
esac

xsel -b -o > $mytemp
# xclip could also be used eg:
# xclip -selection clipboard -o > $mytemp

# invoke the editor, wait for it to finish
#/usr/bin/gvim -f $mytemp
$editor $mytemp

# applications should be using the clipboard to paste!
xsel -b -i < $mytemp

# some applications have incorrect behaviour and use the primary
# selection to paste
xsel -p -i < $mytemp

# activates the original window
wmctrl -ia $winid

# paste text using standard keyboard short-cuts
case $wintitle in
  *Mozilla*)
  xte << EOM
keydown Alt_L
key a
keyup Alt_L
keydown Control_L
key v
sleep 1
key Home
keyup Control_L
EOM
  ;;
  *)
  xte << EOM
keydown Control_L
key a
key v
sleep 1
key Home
keyup Control_L
EOM
esac

# cleanup temporary file
rm $mytemp

# vim:ft=sh:sw=2
----------external-edit----------

VimTip 810: Highlighting Text Beyond 80 Columns
http://vim.sourceforge.net/tip_view.php?tip_id=

Due to oversightedness we are often left with lines of text longer than 80 columns or the set textwidth. One way to spot such lines is to highlight the text  beyond textwidth.

I found that lines beyong textwidth in .c and .h files can be highlighted using the below line in .vimrc.

au BufNewFile,BufRead *.c,*.h exec 'match Todo /\%>' .  &textwidth . 'v.\+/'

you may add different file extensions for which you may wish to highlight text after textwidth.

Regards,
Nitin Raut

VimTip 811: Highlight whitespace errors in files
http://vim.sourceforge.net/tip_view.php?tip_id=

Being somewhat of a neat-freak, I dislike redundant trailing spaces,
and redundant space chars embedded inside of leading spaces.

This auto-command will highlight both of these when added to your vimrc.

    au Syntax *    syn match Error /\s\+$/ | syn match Error /^\s* \t\s*/

You'll be surprised how much whitespace crud there is in source files everywhere.

-Frank.

VimTip 812: Keep modified [+] flag after writing to a file
http://vim.sourceforge.net/tip_view.php?tip_id=

I have seen this being asked in vim mailing list several times, including the recent one which suggested that it should work this way when 'cp' is reset. Basically what happens is that when you modify a file and write contents to a different file, Vim resets the 'modified' flag, which is a Vi compatible behavior. For those who don't want the 'modified' flag reset, the suggested alternative is to use :saveas command instead of :write command, but this changes the name of the current buffer rather than what is wanted. So I have cooked up the following solution which seems to work for regular files, but it is not a fool proof mechanism. The problem is plugins like netrw that catch the event that is triggered when you try to write contents to a different file, and the below solution also uses the same mechanism, so it would end up getting triggered unexpectedly (actually, netrw might work just fine, but you would get ugly error messages in addition).

I have provided a simple workaround for taking care of at least netrw. Basically, it checks if netrw would react to the event and if so skip itself. A more sophisticated solution would actually parse the output of ":au BufWriteCmd" and automatically check if there are other event handlers for this file, but there are not all that many plugins that take advantage of this event (actually I am aware of only netrw), so the workaround should be sufficient (actually, I haven't tested the netrw filenames, so I am not sure it would work). What you should do is to run the ":au BufWriteCmd" before installing this solution and see what other autocommands exist, other than those that are for netrw. You will have to then tweek the code that returns early from the BufWrite() function.

OK, enough said, the solution follows. You basically put the below code in your vimrc and your :write's will work as expected (ie., as described at the start).

----------cut here-----------
function! SetBufWriteAuEnabled(enabled)
  aug BufWrite
  au!
  if a:enabled
    au BufWriteCmd * :call BufWrite()
  endif
  aug END
endfunction
call SetBufWriteAuEnabled(1)

function! BufWrite()
  let fileName = expand('<afile>')
  " If the filename already matches netrw's criteria, then don't do anything.
  if fileName =~ 'ftp://\|rcp://\|scp://\|dav://\|rync://\|sftp://'
    return
  endif
  let _modifiable = &modified
  exec 'w'.(v:cmdbang?'!':'') v:cmdarg fileName
  let &modified = _modifiable
endfunction
----------cut here-----------

Enjoy,
Hari

VimTip 813: Reverse all the lines in a file
http://vim.sourceforge.net/tip_view.php?tip_id=

This simple command

   :g/^/m0

will reverse all the lines in a file. Useful for certain files like logs.

VimTip 814: Use cygwin shell
http://vim.sourceforge.net/tip_view.php?tip_id=

By default, Vim on Windows uses the "Command Prompt" as its shell. If you have Cygwin installed (http://www.cygwin.com) you may want to use one of its shells instead, such as bash. This also makes all of the programs installed under Cygwin available for text processing.

The following settings may be included in a startup script to use bash as your shell. I have these commands in my _gvimrc file in the installation directory.

set shell=C:/cygwin/bin/bash
set shellcmdflag=--login\ -c
set shellxquote=\"

I had problems with parts of the /etc/profile not being executed, but I didn't want to add -i (interactive) to the shellcmdflag because this caused the shell to always open in my home directory. I prefer that it opens in the directory containing the file being edited. However, without that part of /etc/profile running, the path wasn't set up properly. To get around this, I added the following line to /etc/profile:

RANPROFILE="TRUE"

I added this to my .bashrc:

if [ -z "$RANPROFILE" ]; then
    PATH="/usr/local/bin:/usr/bin:/bin:$PATH"
fi

Newer versions of the /etc/profile installed with Cygwin may behave differently.

VimTip 815: Getting vim to work with cvs commit
http://vim.sourceforge.net/tip_view.php?tip_id=

One thing which I find annoying about CVS is doing a commit. You end up with a screen with a bunch of lines starting with "CVS: ", and you need to strip these strings out if you want to finish doing the `cvs commit`.

Here's some sample output from a `cvs commit`:

CVS: ----------------------------------------------------------------------
CVS: Enter Log.  Lines beginning with `CVS:' are removed automatically
CVS:
CVS: Committing in .
CVS:
CVS: Modified Files:
CVS:    foo.c
CVS: Added Files:
CVS:    bar.c
CVS: ----------------------------------------------------------------------

Normally, you can just type the following:
        :1,$s/^CVS: //

However, even this is too annoying. I'd rather have a single button which did this.

Putting the following in your ~.vimrc file acomplishes this task:

:map <F1> :1,$s/^CVS: //p<CR><CR>

This maps the F1 key to doing the desired action. So now all you have to do is a `cvs commit`, hit <F1> and viola! You can now just start typing in what you changed for the log.

This is certainly a simple, stupid map trick. But it is a superb example IMHO of applying the map command in an everyday, useful fashion. And this trick can be applied to other Source Code Control mechanisms as well.

        -dwight-

        dwight@supercomputer.org

VimTip 816: JAVH: Just another VIM Hacker
http://vim.sourceforge.net/tip_view.php?tip_id=

Perl has it's JAPH Just Another Perl Hacker (a short script that produces the output 'Just another Perl hacker' (Just Google for it)) I thought one day I'd try to something similar with VIM , the trick being to make it as obscure as possible:-

vim -c ":%s%s*%Cyrnfr)fcbafbe[Oenz(Zbbyranne%|:%s)[[()])-)Ig|norm Vg?"

Somebody (sorry I forget who, possibly Peppe) did this one

:s(.*(rekcaH iV rehtonA tsuJ(|t.|s).$)&&)|-s'.'s,\\(.\\)\\(.\\)\\(\\2.*\\),\\2\\3\\1,|'g|s=[^|]*|$=s,.,,=|d a|@a

Another voyager in cyberspace created the following

gvim -c "exec \"normal itYNQ#v'Z#ABG#GUR#BAYL#BAR\"|%s/#/ /g|normal ggVGg?ggVG~"

So what's the point:-
1) Well it attracts a few more people to VIM (I use it as a signature)
2) It sharpens your Vim skills,(they can never be sharp enough)
3) It's fun

So over to you! can you do any better!

VimTip 817: Non-blinking block cursor in the linux console
http://vim.sourceforge.net/tip_view.php?tip_id=

If you are a Linux user editing with Vim in the console, you can put the following in your .vimrc to have a nice non-blinking block cursor like in a xterm:

if &term == "linux"
        set t_ve+=^[[?81;0;112c
endif

Note that the ^[ above needs to be typed like this: <CTRL-V> <ESC>.

See Documentation/VGA-softcursor.txt in the kernel sources for details about this escape sequence.

VimTip 818: Vim/GVim as Diff tool for TortoiseCVS
http://vim.sourceforge.net/tip_view.php?tip_id=

Under Win you can use TortoiseCVS along w/ Vim/GVim as the diff tool of choice:

1. Create a .bat file containing the following and put it in your path:

@echo off
"C:\Program Files\Vim\vim63\GVim.exe" -d %1 %2

2. Add this .bat file as the diff utility under TortoiseCVS->Preferences->Tools->External Diff Application.

Alejandro

VimTip 819: Quick (Re-)starting and Iconizing gvim with keystrokes for Windows
http://vim.sourceforge.net/tip_view.php?tip_id=

gvim is iconized (resp. send to the background) with
     CTRL-Z
so for me it is useful to start it with
     CTRL-ALT-Z
which is easily configured from the properties menu of a windows shortcut  pointing to gvim.exe using the right mouse button.
Since  the last command brings gvim into the foreground if it has already been started, the above  2 control-commands toggle between another application and gvim very fast.

VimTip 820: VimTip is a one-stop resource to vim. Keep it in your $VIM directory
http://vim.sourceforge.net/tip_view.php?tip_id=

The VimTip textfile and database has become one of my favorite ways to learn
new tricks in vim. So I keep it easy available at all times and have applied
some of the nice tricks I have learned to the file to make it easier to read.

1: Get the text file (wget is a external tool, you can get a windows version)
    Download the text version with a browser or use wget like this.
    On the vim commandline: (It's all on one line)
	:!wget http://www.vim.org/tips/tip_download.php?download=download -O
	~/.vim/vimtips.txt

2: Open it and apply foldmarks.
	:e ~/.vim/vimtips.txt
	:%s/\(^VimTip\)/\1\t{{{1/g
	:set foldmethod=marker


3:	Now you should have a nice index of all the vimtip's provided. Open a fold
by placing the cursor on a line and hit za. Open all folds with zR. Close them
again with zM

4: After some vimtip's reading you shoul be able to make a automatic process of it to update your vimtips.txt file regularly.

Happy vim'ing
Best Regards
Staale Flock

VimTip 821: Simplest buffer explorer ever
http://vim.sourceforge.net/tip_view.php?tip_id=

In the footsteps of vimscript #42 and vimscript #159, here's perhaps the simplest way to select a buffer from the list of all buffers:
    nnoremap :e :ls<CR>:e<Space>

Just type ':e' and continue typing '#' and the number of a filename from the list (or a new filename).

A minor drawback is that ':' now doesn't show up immediately (vim waits some time to see if you'll complete the mapping), but I got used to this with no trouble at all.  I imagine it'll be the same for most people who type fast - you won't notice that ':' and the next character you type show up together rather than in sequence.

I always get nervous with mappings involving ':' or '/' but this one's created no problems in a couple of months.

VimTip 822: add java import statements easily (assume using ctags)
http://vim.sourceforge.net/tip_view.php?tip_id=

I like the build (make) process to be fast... Eclipse/Netbeans users are excited about "auto-import" features...
Vim can do it just fine....  Well, I just got this working today....and it may need some tweaking.
If It doesn't work for you.... take some java.... that compiles... break one of the imports (assume you don't using foo.*; syntax much).
Then comment lines below starting from bottom up....  watch editing happen.... try to do edits slow to reproduce whats here.
I generally hit F1 key to build with (jikes) (tip # 3).... 90% of build failures are missing import statements....
If you already have a ctags system (tip #804, 94, etc)... the information can be found!
I hit F1 (:make), then hit F9 (add import for keword found under cursor)...then F1 (make/build)....and so on.  (FAST)

(Add Import)
:noremap <F9> <esc>
                  \<C-W>}o//TEMP MARKER<esc>
                  \<C-W>P1G/public class<cr><esc>yy<C-W>pG?import<cr><esc>p<esc>
	          \<C-W>P1G/package<cr><esc>yy<C-W>pG?import<cr><esc>p<esc>
	          \$xa.<esc>0jwwi<cr><esc>kdd<esc>
                  \wDx<esc>kJxx<esc>$a;<esc>
	          \0cwimport<esc>
	          \:update<cr><esc>
                  \/TEMP MARKER<cr>dd<esc>
(Make)
 :noremap <F1> :update<cr>:make<cr><C-W>j<esc>:cw 3<cr><C-W>p

VimTip 823: Add your note files to vim's help system.
http://vim.sourceforge.net/tip_view.php?tip_id=

I guess you have one or more files containing short notes regarding your computer, stuff you study and suche. If you have several years of notes laying around, and are like me..:o), You tend to forget what's in your notes and you start grepping through your files ore start over again to figure stuff out.

One of my solution has been to vim-helpify my note files and add a link to them from my ~/.vim/doc/ folder.

This is the process:
Make a few changes to your note file.

---- sample notes file start -------------------------------
" vim: filetype=help foldmetod=tags foldtags=<<<,>>> modifiable noreadonly
NOTE! You need the noreadonly and modifiable keywords in the vim modeline above. help files are by default regarded as readonly and nomodifiable files by vim.

Notes about sed		*sed* *sfsed*	<<<
swapping word's in stream (I know, you don't need the cat)
	cat Myfile.h|sed 's/foo/fyy/g'

Notes about vim		*vim* *sfvim*	<<<
	Stuff I have learned about vim.
	Create a help link like this |add-local-help|
	Regenerate help tags: |helptags|

	A realy big section closed with a tag <<<
	--- lots of stuf ---
	Closing tag >>>



Telephonelist		*sfphone*	<<<
	mom:	555-676767-333
	dad:	555-767676-222
	sis:	555-121212-999

---- sample notes file end ---------------------------------

As you can see from my sample I tend to prepend my keywords with sf so I can get a handy list with <CTRL+d> later.

I have tried to index files placed in an arbitray place. Sadly enough the helptags command does not seem to like this, so my solution has been to make a soft link from the ~/.vim/doc/ folder to my file. You can do this from vim:
	:!ln -s ~/.vim/doc/mynotes.txt ~/Documents/mynotesfile.myext
To have vim create the tags
	:helptags ~/.vim/doc

Viola, now when I need that important phone numer it's only one :h command away
	:h sfp<CTRL-d>



You could also create your own helptags function adding tags containing a more specifig file position. A realy simple function would be.

function! AddMyHelpTags()
	exe 'echo -e "sfsed\t ~/Documents/mynotesfile.mytext\t/\*sfsed\*" >> ~/.vim/doc/tags'
	exe 'echo -e "sfphone\t ~/Documents/mynotesfile.mytext\t/\*sfphone\*" >> ~/.vim/doc/tags'
	exe 'sort ~/.vim/doc/tags > /tmp/foo.vim.tags'
	exe 'mv -f /tmp/foo.vim.tags ~/.vim/doc/tags'
endfunction

NOTE! I do not use such a AddMyHelpTags function myself. But I have tested the principle (The sample function it self is not tested, only the commands). This is just a sample to get you going. Remember that you probably would have to run this AddMyHelpTags function each time :helptags has been called, so as-is it is not very convinient..:o(

Happy viming, regards
Staale Flock

VimTip 824: Choose smaller font in vimdiff mode.
http://vim.sourceforge.net/tip_view.php?tip_id=

Recently someone wants me to post the solutions of this.

I just want to change the font when vim is launched in vimdiff mode, since you'll not be able to change the font later while retain the 1:1 split, (in other cases, I can change the font before :diffs)

Just add something like the following in .gvimrc:

Of course, your fonts may vary.

" Font must be set in .gvimrc
let in_diff_mode = 0
windo let in_diff_mode = in_diff_mode + &l:diff
    set guifont=Lucida_Console:h15:cDEFAULT

    " In diff mode
    if in_diff_mode == 1
        set guifont=isi_ansi:h14:cDEFAULT
    endif

unlet in_diff_mode

VimTip 825: Expand #* search to grep-find
http://vim.sourceforge.net/tip_view.php?tip_id=

When #/* will not find a word under-cursor,
use the macro 'g/' given below, to expand the
same search with gnu-grep to dirs/files.

Search results are shown in a small window (quickfix mode),
use c-n/c-p to move between results.

Uses gnu-grep on PC/Unix to search vim \<regexp\> in files/trees.

Based on 'grep-find' which is a emacs commands.

" Put this in ~/_vimrc and use g/ to repeat current search as a grep-find.
" Usage
"   /xyz   .. not found in current file, so lets look for it in *.* with
"   g/     .. search for xyz in *.*, next lets look for it in the whole tree
"   :call Mosh_grep("../..")
"   :call Mosh_grep("/usr/include","strstr")
" GNU-grep -recursive,nocase,linenum,noerror,VimRegexp (in that order).
:set  grepprg=grep\ -rinsE

:map g/  :call Mosh_grep()<CR>

function! Mosh_grep(...)
    if a:0 == 0
        :exec "grep '".@/."' *.*"
    elseif a:0 == 1
        :exec "grep '".@/."' " a:1
    elseif a:0 == 2
        :exec "grep" a:2 " " a:1
    endif
    " Optional mappings for easy navigation of results
    :map <c-n>  :cnext<CR>
    :map <c-p>  :cprev<CR>
    :copen
endfunction

- Mohsin
http://www.cs.albany.edu/~mosh



VimTip 826: PHP manual in VIM help format
http://vim.sourceforge.net/tip_view.php?tip_id=

Download http://planetxml.de/php_manual.txt and put it into your vim/doc folder, then run :helptags [path to vim/doc]. Documentation for PHP functions can be shown by pressing K while the cursor is on a function name.

The manual was created using a modified version of script found at http://www.phpvolcano.com/articles/manual/index.php.

VimTip 827: XTerm and 256 Colors
http://vim.sourceforge.net/tip_view.php?tip_id=

XTerm supports 256 colors when compiled with the --enable-256-color configure option.  To actually enable the colors set the TERM enviroment variable to TERM=xterm-256color

Some of the colorschemes support the 256 color format.

VimTip 828: pad trailing blanks onto end of lines to ease visual blocks
http://vim.sourceforge.net/tip_view.php?tip_id=

I love using the visual block feature to move columns around (<ctrl-v>, blockwise-visual).
However, this does not work conveniently on the last column
when  lines are not of equal length. <ctrl-v> marks then a block which
is equal in width to the shortest line.

In order to pad all lines to a given width with trailing blanks
you can use the following functions:

" truncate line 'line' to no more than 'limit' width
function! Truncate( line, limit )
    call cursor(a:line,a:limit)
    norm d$
endfunc

" Pad all lines with trailing blanks to 'limit' length.
function! AtOnce( limit )
    norm mm
    g/^/norm 100A
    g/^/call Truncate( getline('.'), a:limit )
    let @/=""
    norm 'm
endfunc

You may alternatively use the oneliner:
:g/^/exe "norm! 100A" | call cursor(getline('.'), 79) | norm d$

I even saw someone use a standard vi (non vim) oneliner to achieve the
same, but I forgot how. Any ideas?

VimTip 829: copy & paste between vim session
http://vim.sourceforge.net/tip_view.php?tip_id=

I use putty + vim + screen on web application developing.
because, daily working directory is more than 10. I couldn't find easy way
to develop in only one vim session.

so, copy & paste between session, usally used window's clipboard. but, to copy longer
than one screen, It's really hard. yes, there are auto-indenting problem too.

and sometimes, I just want copy function definition or long variable names. between vim
buffers I simply use visual selection. or cw/ciw. in this case, yanking by line is worse than
clipboard.

last night I made this script saving current register to file supporting visual selection too.

,y saves current unnamed buffer to ~/reg.txt file.
,p / ,P read from ~/reg.txt and paste using p/P.
in visual mode,  ,y  is yank and save.

vmap <silent> ,y y:new<cr>:call setline(1,getregtype())<cr>o<esc>P:wq! ~/reg.txt<cr>
nmap <silent> ,y :new<cr>:call setline(1,getregtype())<cr>o<esc>P:wq! ~/reg.txt<cr>
map  <silent> ,p :sview ~/reg.txt<cr>"zdddG:q!<cr>:call setreg('"', @", @z)<cr>p
map  <silent> ,P :sview ~/reg.txt<cr>"zdddG:q!<cr>:call setreg('"', @", @z)<cr>P

but, I think there are more simple way to this in our vim world. always there were.

what's the best way to copy & paste between vim sessons?

VimTip 830: Using netbeans 4 and vim for java
http://vim.sourceforge.net/tip_view.php?tip_id=

This tip explains how to configure Vim to build Java sources and to execute classes without having to start Netbeans, but everything done in the same way Netbeans would do it. Netbeans can then be started any time to do things that Vim cannot, like debugging in a GUI or refactoring.

This has been tested in Linux.

It is assumed that your Java source code is in the directory "~/data/java/src" and that your classes are in different packages below this directory. For example the package com.your_domain.util is in the directory "~/data/java/src/com/your_domain/util"

Step 1: Install Ant

Step 2: Install Netbeans and create a new project with existing sources. At this point you can choose within Netbeans where all project files will be saved. Let say "~/data/java/netbeans" and the project name is "my_domain". The source code directory should be the top directory, here: "~/data/java/src". Netbeans will add packages in the project for all subdirectories, which allows to move classes between packages with the mouse, and Netbeans will refactor your whole source files for you.

Step 3: Compile your project with Netbeans. After that you can close Netbeans.

Step 4: Add the following two lines in .vimrc or in ~/.vim/ftplugin/java_netbeans.vim or ...

             nmap <F6> :! ant -buildfile ~/data/java/netbeans/my_domain/build.xml compile<CR>

             nmap <F7> :cd ~/data/java/src<CR>:! ant -buildfile ~/data/java/netbeans/my_domain/build.xml -Drun.class=%:.:r -Djavac.includes=~/data/java/netbeans/my_domain/build/classes/ run-single<CR>:cd %:p:h<CR>

That's it ! Now you can compile changed files pressing <F6> or execute the class you are editing with <F7> in Vim. And you can start anytime Netbeans for debugging, refactoring, etc.

VimTip 831: regexp to strip redundant zeroes in decimal fractions
http://vim.sourceforge.net/tip_view.php?tip_id=

Vim command
%s/\(\.\d\+\)\@<=0\+\>//g
will strip all trailing (meaningless) zeroes in decimal fractions. Some of my data files lost 50% fat after this procedure and also became much more human readable.

I guess "correct"regular expression should be
\(\.\d\{-1,}}\)\@<=0\+\>
(since the intention is to preserve just one zero that comes right after decimal point), but for some reason original expression works as well.

I guess this serves as another example of how \@<= regexp token makes things so much easier.

VimTip 832: Remembering previous deletes/yanks
http://vim.sourceforge.net/tip_view.php?tip_id=

The following was posted on the Irish Linux User Group mailing list:

&lt;quote&gt;
ok, let's say your cursor is on ok, and you delete this paragraph with
the command [d}] (just the d} part, for this mail i'm wrapping
keystrokes in []'s).  the reason you deleted it is because you want to
move it to another file.

so now you open the other file with [:e other.file.txt<return>].  as
you're scrolling down to where you want to put it, you accidentally
delete/yank some text.

you've saved the last file and now doing [p] just inserts the text you
just deleted/yanked.  how can you get back what you deleted?  vim
extends vi's numbered delete buffers so that they work from one file to
the next - switching files doesn't delete the numbered delete buffers.

the numbered buffers are numbered from 0 to 9.  ["0p] is the same as
plain old [p].  ["1p] is the buffer from the previous delete, ["2p] is
from the delete before that, etc.  note that while ["0p] has the last
delete or yank, the other numbered buffers only contain previous
deletes.

it's handy, and thanks to donncha for looking it up the other day while
i was on the train.

&lt;/quote&gt;
Credit where credit due, it was Kevin Lyda who posted this.

VimTip 833: Google lookup as a contextual spell check and phrase verifier.
http://vim.sourceforge.net/tip_view.php?tip_id=

I started hacking vim + google apis yesterday to do phrase lookups
on google. Google is much better (but
slower than a dictionary) as a contextual speller/data verifier.

However here is something readymade by Danny O'Brien, from
http://www.oblomovka.com/entries/2003/04/16#1050554820

In your .vimrc, add these lines:

" ,g  - create google a href for word under cursor
map ,g <Esc>Bm`:r!ghref <cword><CR>"gdd``i<C-R><C-R>g<esc>dw
vmap ,g yvgvdm`:r!ghref '<C-R>=substitute(@0, "['\n]", " ", "g")<cr>'<cr>"gdd``i<C-R><C-R>g<Esc>

Now put this program somewhere in your PATH, saved as "ghref"

#!/usr/bin/python
##
# ghref - takes a string on command line, looks it up in google, outputs
#         the HTML for a hyperlink to the "I'm feeling lucky" URL
##
import google
import sys
import re
def main(argv):
    search=argv[0]
    data = google.doGoogleSearch(search)
    if (data.results[0].summary):
        title = data.results[0].summary
    else:
        title = data.results[0].title
        title = re.sub('</*b>','',title)
    print '<a href="%s" title="%s">%s</a>' % (data.results[0].URL, title, argv[0])

if __name__ == '__main__':
    main(sys.argv[1:])




VimTip 834: Word-wise cut, copy & paste
http://vim.sourceforge.net/tip_view.php?tip_id=

Word-wise cut, copy & paste over the current word. There's nothing special or magical about these bindings, just that I find them really useful for coding, and I thought I'd share.

Add the following lines to _vimrc:

map <A-v> viw"+gPb
map <A-c> viw"+y
map <A-x> viw"+x

These bindings follow the Windows-style keys of control-V, control-C, and control-X; except using alt instead of control. Adjust to your preference.

VimTip 835: Get Intellisense for C++ to search CWD/PWD
http://vim.sourceforge.net/tip_view.php?tip_id=

I searched the tips database and didn't find this.  Do not know the best place for this tip.

This tip is relevant to those who use the "Intellisense" functionality for vim (insenvim.sourceforge.net) for C++.  This requires, as a part of its setup, that the paths for the all the included header files in a C++ file be present in the $INCLUDE variable.  This is fine so long as all your header files are in one (invariant) location (say the MSVC's include directory).  However, if your C++ file includes header files in locations relative to the current file, updating the INCLUDE environment variable is not an option.

E.g., if your header files are in the same directory as your source file, simply add the following line to the cpp_vis.vim file that is delivered to the vimfiles\ftplugin location:

let $INCLUDE = expand("%:p:h") . ";" . $INCLUDE

To include other relative paths, simply tweak the argument to expand().  For more info, see

:help filename-modifiers

Happy vimming! :)

VimTip 837: Load file from list of filenames in textfile
http://vim.sourceforge.net/tip_view.php?tip_id=

Following is a BIG timesaver if you need to open lots of files.

Assume you have a text file containing filenames with or without paths (created by for instance 'grep -Erl "^" * > files.txt'). Following opens all these files in the same vim.

Asumming that only this text file is opened:

- Set the cursor on the first line
- in command mode, type: q0gf:rew<CR><DOWN-ARROW>q
     - This loads the file on the first line and create a macro '0'
- Check the number of lines with <CTRL-g> and substract one for the first line
- Type this value, then: @0
    - This loads the remaining files

VimTip 839: switch editing: .c* to .h*
http://vim.sourceforge.net/tip_view.php?tip_id=

This command allows you to
quickly switch editing between .c* and .h* files.

It is especially useful when the header file is
in different direcotry and filenames are long.
Example: press 'zh' when editing fxx1234.cxx to open fxx1234.hxx

:map zh :call Mosh_Flip_Ext()

" Since .h file can be in a different dir, call :find instead of :e
" :find file will be searched in this path
set  path=.,,..,../..,./*,./*/*,../*,~/,~/**,

" note there are double backslashes below, http post might mangle them.

function! Mosh_Flip_Ext()
    :if match(expand("%"),"\\.c") > 0
        let s:flipname = glob(expand("%:r").".h*")
        :exe ":find " s:flipname
    :elseif match(expand("%"),"\\.h") > 0
        let s:flipname = glob(expand("%:r").".c*")
        :exe ":find " s:flipname
    :endif
endfun

VimTip 840: Show tags in a separate preview window
http://vim.sourceforge.net/tip_view.php?tip_id=

I love using exuberant ctags (especially ctags -R).  But I dislike how the show-tag-under-cursor command (Control-]) replaces the current buffer and loses my cursor position.  Instead I want to view the tag definition in a separate 'preview' window so I can, for example, view a C/C++ type declaration while coding a call.

Add the following to your _vimrc/.vimrc file:

nnoremap <C-]> <Esc>:exe "ptjump " . expand("<cword>")<Esc>

This will make Control-] pop open a window and show the tag there.  The :ptjump command shows the tag in a preview window without changing the current buffer or your cursor position.

This is especially handy for referencing C/C++ function declarations while entering code.

VimTip 841: Vim reference card of common commands
http://vim.sourceforge.net/tip_view.php?tip_id=

Charles E. Campbell wrote an excellent Vim reference card in 1999 for Vim 5.7.  I revised it for Vim 6.3.

http://utools.com/vimrefcard.pdf

VimTip 842: c/c++ function abbreviations
http://vim.sourceforge.net/tip_view.php?tip_id=

I have been seeking for some 'perfect' abbrevs for long time. They have to work in c code, but not in string or comment. They have to place cursor inside the function and leave vim in insert mode, so that I can just continue typing. They have to respect my indenting, and they have to produce exactly the same results when I start the abbreviation by <C-]> or just by <Space> (no bothersome space should appear). And they should be easy to maintain. I thought that this is not possible, but after seeing Luc Hermitte's lh-cpp-ftplugins, I found my way through. Here is what I got:

" Help delete character if it is 'empty space'
"  stolen from vim manual
function! Eatchar()
  let c = nr2char(getchar())
  return (c =~ '\s') ? '' : c
endfunction

" Replace abbreviation if we're not in comment or other unwanted places
"  stolen from Luc Hermitte's excellent http://hermitte.free.fr/vim/
function! MapNoContext(key, seq)
  let syn = synIDattr(synID(line('.'),col('.')-1,1),'name')
  if syn =~? 'comment\|string\|character\|doxygen'
    return a:key
  else
    exe 'return "' .
      \   substitute( a:seq, '\\<\(.\{-}\)\\>', '"."\\<\1>"."', 'g' ) .  '"'
  endif
endfunction

" Create abbreviation suitable for MapNoContext
function! Iab (ab, full)
  exe "iab <silent> <buffer> ".a:ab." <C-R>=MapNoContext('".
    \  a:ab."', '".escape (a:full.'<C-R>=Eatchar()<CR>', '<>\"').
    \"')<CR>"
endfunction

call Iab('#d', '#define ')
call Iab('#i', '#include <><Left>')
call Iab('#I', '#include ""<Left>')
call Iab('printf', 'printf ("\n");<C-O>?\<CR>')
call Iab('if', 'if ()<CR>{<CR>}<Left><C-O>?)<CR>')
call Iab('for', 'for (;;)<CR>{<CR>}<C-O>?;;<CR>')
call Iab('while', 'while ()<CR>{<CR>}<C-O>?)<CR>')
call Iab('else', 'else<CR>{<CR>x;<CR>}<C-O>?x;<CR><Del><Del>')
call Iab('ifelse', 'if ()<CR>{<CR>}<CR>else<CR>{<CR>}<C-O>?)<CR>')
call Iab('intmain', 'int<CR>main (int argc, char **argv)<CR>'.
       \'{<CR>x;<CR>return 0;<CR>}<CR><C-O>?x;<CR><Del><Del>')

For me it's working, I also tried it with plain vim (without .vimrc), but it may depend on some settings. Hope it helps.

Happy vimming
--
  Neuron

VimTip 843: Moving between buffers using mouse and minibufexpl.
http://vim.sourceforge.net/tip_view.php?tip_id=

After some time using mini buffer explorer (http://www.vim.org/scripts/script.php?script_id=159), here is the way for moving between buffers using mouse (thus GVim only) and minibufexpl I feel comfortable with (Who knows you might feel the same :)

1. download the minibufexpl script and put it in the plugin directory (~/.vim/plugin or %HOME%\vimfiles\plugin in windows). Thus we have a pseudo tabbar in GVim window.
2. map the right click to <Esc> by adding this line to vimrc
imap <RightMouse> <Esc>
nmap <RightMouse> <Esc>
3. Then when we want to switch buffer in insert mode (or normal mode), instead having to press the <Esc> key, then move the mouse and click the buffer name, we instead just need to right click and click the buffer name using the mouse. Quite easier I think.

Drawback, you lose your right click menu, but do you use it anyway ?

VimTip 844: Simple Macros to quote and unquote a word
http://vim.sourceforge.net/tip_view.php?tip_id=

Here are some simple mappings that can be used to quote and unquote a word. Place the cursor over a word and
press qw to place single quotes, or qd to place double quotes around the word. To remove quotes press wq.

The mnemonic used is perls qw() operator.

  " 'quote' a word
  nnoremap qw :silent! normal mpea'<esc>bi'<esc>`pl
  " double "quote" a word
  nnoremap qd :silent! normal mpea"<esc>bi"<esc>`pl
  " remove quotes from a word
  nnoremap wq :silent! normal mpeld bhd `ph^M

VimTip 845: Getting color to work in SecureCRT
http://vim.sourceforge.net/tip_view.php?tip_id=

I was puzzled I couldn't get colors despite setting SecureCRT emulation settings to ANSI Color

Adding this to .cshrc fixed it:
setenv TERM xterm-color

VimTip 846: gvim ampersand in freebsd shell commands (viewing with vim-latex)
http://vim.sourceforge.net/tip_view.php?tip_id=

could not execute shell commands ending with ampersand (&) in gvim running under Freebds. Commands like:

:!xdvi &
:!xterm &

did not work. This meant that I couldn't use vim-latex to view documents dvi since by default vim-latex sends a command ending with &.  The problem does not occure in vim.

The fix. The problem is solved if the shell is changed to ksh from the default sh or bash.

1) install pdksh

     $ su                (su to root)
     # cd /usr/ports/shells/pdksh/
     #make install cleanset

2)  Change the shell to ksh in .vimrc. Add

    set sh=ksh


(see help sh)

Happy  ampersanding in gvim

VimTip 847: Avoid irritating "ATTENTION" message and always open it read-only
http://vim.sourceforge.net/tip_view.php?tip_id=

When you open a file opened in somewhere else,
you would get "E325: ATTENTION" message because a swap file already exists there.
I (almost) always choose the action "[O]pen Read-Only" in this case,
so typing 'O' key is an annoying job for me.
The following in my vimrc reduce my job.

func CheckSwap()
    swapname
    if v:statusmsg =~ '\.sw[^p]$'
	set ro
    endif
endfunc

if &swf
    set shm+=A
    au BufReadPre * call CheckSwap()
endif

VimTip 848: Installing several releases in parallel, even with matchit
http://vim.sourceforge.net/tip_view.php?tip_id=

It is possible to install several different releases of Vim (for instance, Vim 6.3 "stable" and Vim 7.0 "alpha") on a single computer and decide at run-time which one to use. The present tip tells how. However, it does not solve all of the problems; in particular, it tells how to use either one or the other but not both by the same user at the same time. (It is possible to use both at the same time if "users" are different, or if the matchit plugin is not used.)

1. One version should be chosen as "default", normally the stabler one. It will be accessible via the PATH, through one of the following methods:

a) Put the name of its directory in the PATH: for example, on Windows 98, AUTOEXEC.BAT may contain:
...
set VIM=C:\PROGRA~1\vim
...
path %VIM%\vim63;%PATH%

b) Have a soft link to it in a directory in the PATH, for example on Unix you may have a soft link /usr/bin/vim pointing to /usr/share/vim/vim63/vim

To use the non-default version (or, on Windows, the default when you are in the directory of the other one), use a full path: in the case above, you will invoke the default Vim as "vim" and the other one as (for example, on Windows) %VIM%\vim70aa\vim

2. The permanent environment may possibly contain a VIM variable (which may for instance be set to C:\PROGRA~1\vim on Windows or to /usr/share/vim on Unix) but not a VIMRUNTIME variable. Each executable will select a different $VIMRUNTIME according to its version number. If VIM is unset, Vim will normally set it correctly; but even if you use the default it can be useful to set VIM in the permanent environment so that the shell can see it: indeed, it is much easier to type cd $VIM than cd /usr/share/vim; or %VIM%\vim70aa\gvim filename.ext than "C:\Program Files\vim\vim70aa\gvim" filename.ext. For best results on Windows, use "short" directory names in the value of VIM, HOME, etc. (as in the W98 example above).

3. The "system-wide customizations" in $VIM/vimfiles and the "user-specific customizations" in $HOME/.vim or $HOME/vimfiles will be common to the different versions; any differences can be resolved by testing the value of v:version at run-time.

4. Each distribution should have its own distribution tree at the proper place under $VIM, for instance $VIM/vim63 for stable release 6.3 (at any patchlevel) or $VIM/vim70aa for alpha release 7.0aa (at any snapshot date). If you install via a pre-compiled archive or installer, it should select the proper default. If you compile your own, the subdirectory name is the value of the constant VIM_VERSION_NODOT defined in src/version.h

5. Now we come to the ticklish point: the matchit plugin. It comes with each distribution, with its own script and helpfile, but they are deactivated by default and they may vary from version to version. They are however, very useful; but how can we sure of using the right one? Here is how I solve the dilemma: I use a small "system-wide" plugin $VIM/matchit.vim to automatically select the right plugin at run-time (the first line takes care of the plugin itself; the rest is for the help file. This "fancy footwork" is needed to avoid changing the distribution files in or under $VIMRUNTIME.) Note that the following assumes that different users may use both versions at the same time, but that a single user will not. The contents of that scriptlet is shown here between -----start and -----end; it assumes that +eval (expression evaluation) and +windows (the ability to use split windows) have been compiled-in. In other words, the "normal" feature set should be enough. (With only "small" features, we can't use the :if statement and that's a big handicap.) This plugin also assumes that there exists a "doc" subdirectory in ~/vimfiles or ~/.vim for "user help files". You should create that directory if it doesn't yet exist.

$VIM/vimfiles/plugin/matchit.vim:
----- start
	runtime! macros/matchit.vim
	split $VIMRUNTIME/macros/matchit.txt
	if has("unix")
		saveas! ~/.vim/doc/matchit.txt
		helptags ~/.vim/doc
	else
		saveas! ~/vimfiles/doc/matchit.txt
		helptags ~/vimfiles/doc
	endif
	close
----- end

see
	:help $VIM
	:help $VIMRUNTIME
	:help v:version
	:help matchit-install
	:help :helptags

VimTip 849: Shortcuts to compile/run default file and alternate file in Java
http://vim.sourceforge.net/tip_view.php?tip_id=

Coding in Java? Add this to your .vimrc to map F9 to compile, and F10 to run. You can also use F11 and F12 to compile and run the alternate file. I\'ve found this .vimrc very useful where I am working on a Java class in one file, and a driver program to test it in the alternate file. See also: #vimtip 3 and #vimtip 120. Note that ^M and ^[[ below need to be typed as control characters (hit Ctrl+V, Ctrl+M, etc.), and makeprg could easily be modified for those using jikes. Hope someone else finds this useful.

\" F9/F10 compile/run default file
\" F11/F12 compile/run alternate file
map <F9> :set makeprg=javac\\ %^M:make

map <F10> :!echo %\\|awk -F. \'{print $1}\'\\|xargs java^M
map <F11> :set makeprg=javac\\ #^M:make^M
map <F12> :!echo #\\|awk -F. \'{print $1}\'\\|xargs java^M

map! <F9> ^[[:set makeprg=javac\\ %^M:make^M
map! <F10> ^[[:!echo %\\|awk -F. \'{print $1}\'\\|xargs java^M
map! <F11> ^[[set makeprg=javac\\ #^M:make^M
map! <F12> ^[[!echo #\\|awk -F. \'{print $1}\'\\|xargs java^M

\" Tip: load a file into the default buffer, and its driver
\"    into the alternate buffer, then use F9/F12 to build/run.
\" Note: # (alternate filename) isn\'t set until you :next to it!
\" Tip2: You can make then run without hitting ENTER to continue. F9-F12

\" With these you can cl/cn/cp (quickfix commands) to browse the errors
\" after you compile it with :make
set makeprg=javac\\ %
set errorformat=%A:%f:%l:\\ %m,%-Z%p^,%-C%.%#

\" If two files are loaded, switch to the alternate file, then back.
\" Useful because then # is set!
if argc() == 2
    n
    e #
endif

VimTip 850: automatic word wrapping
http://vim.sourceforge.net/tip_view.php?tip_id=

To automatically wrap word in vim
:set wm=2
which sets a wrap margin of 2 characters at the end of each
line, and does automatic word-wrapping as u type in text.

To set textwidth as of your screen with do
:set textwidth=0 (If u want to set it yourself do :set textwidth=78.)

If you want to apply this to specific areas; bring the cursor at
the beginning of the text u want to format and type gq. Now specify the range,
say $ to format a large line.

For more help
:help wn
:help gq

Hope this helps.
mmj

VimTip 851: compose mail in Mozilla Thunderbird using Vim.
http://vim.sourceforge.net/tip_view.php?tip_id=

Hi.

There si finally an extension for thunderbird that enables user to
compose mail in an external editor.
Like Vim, or Gvim ;-)

I have been waiting for this for a looong time.
Sometimes I want to use very powerfull editor of my choice (Vim)
to format an email message and Copy and Paste sucks.

You can find it here:
http://globs.chez.tiscali.fr/moz_extensions/exteditor.html

It works also in W2000 (not only on XP and Linux as the author claims)

I couldn't make it work at first.
You have to start a new massage, right click the toolbar and add icon for External Editor.
Now, when you click on the icon, your mail is displayed in Vim.

Have a nice day
Stanislav

VimTip 852: Make support for NEC V850 CA850 compilers
http://vim.sourceforge.net/tip_view.php?tip_id=

This line will replace "make" with the "build" command when using ":make".

" Use build.exe for making
set makeprg=build\ -script\ script.bld\ -XO\ build.err

NOTE: It directs the output to a file called "build.err" and assumes a script based build where the scriptname is "script.bld".

This line allows the error output from the build to be processed for display and linking back to the source.

" Find CA850 errors and warnings
set errorformat=%f\ %l\ %.%#rror:\ %t%n:%m,%f\ %l\ %.%#arning:\ %t%n:%m,%+Eld850:\ %.%#rror:\ %t%n:%m

VimTip 853: Write a dated backup of the current file.
http://vim.sourceforge.net/tip_view.php?tip_id=

I sometimes find it useful to take a backup of the file I am currently editing
before continueing to edit the file.  Thats what this function is for :-)

Put this into your vimrc and press \ba while in normal mode, and the current
file will be backed up.

" A mapping to make a backup of the current file.
fun! WriteBackup()
        let fname = expand("%:p") . "__" . strftime("%Y_%m_%d_%H.%M.%S")
        silent exe ":w " . fname
        echo "Wrote " . fname
endfun
nnoremap <Leader>ba :call WriteBackup()<CR>

VimTip 855: Automatically add closing brace to block when coding
http://vim.sourceforge.net/tip_view.php?tip_id=

I got fed up with having to add the closing brace to a code block, so I've got my Vim to automatically add a closing brace when coding in c#. Add the following to any appropriate ftplugin files (prefereably in vimfiles/ftplugin) so they don't get overwritten on upgrades.

The script will automatically add the closing brace and position the cursor on a line between the opening and closing braces. It ignores braces in comments, strings and if the word new is in the line (e.g. for string[] myArray = new string[] {"a", "b"}.

There are maps for enclosing code in a set of braces.

imap { <esc>:call ReplaceCurly()<Cr>cl

function! ReplaceCurly()
    imap { {
    " only replace outside of comments or strings (which map to constant)
    let elesyn = synIDtrans(synID(line("."), col(".") - 1, 0))
    if elesyn != hlID('Comment') && elesyn != hlID('Constant') && match(getline("."), "\\<new\\>") < 0
      exe "normal a{"
      " need to add a spare character (x) to position the cursor afterwards
      exe "normal ox"
      exe "normal o}"
      exe "normal kw"
    else
      " need to add a spare character (x) to position the cursor afterwards
      exe "normal a{x"
    endif
    imap { <esc>:let word= ReplaceCurly()<Cr>cl
endfunction

"Surround code with braces
nmap <leader>{} O{<esc>ddj>>ddkP
vmap <leader>{} <esc>o{<esc>ddgv>gvdp

VimTip 856: syntax highlighting
http://vim.sourceforge.net/tip_view.php?tip_id=

(Originally posted in http://www.livejournal.com/community/vim_ers/3546.html)

I've just found a very nice feature of syntax highlighting in Vim.

Try this:
1. Create new file (for example, qwerty.txt).
2. Execute the following:

    :syntax on
    :syntax include @CPP syntax/cpp.vim
    :syntax region cppSnip matchgroup=Snip start="@begin=cpp@" end="@end=cpp@" contains=@CPP
    :hi link Snip SpecialComment

3. Now type in following text:

This is simple text; and this is C++:
@begin=cpp@
  int q;
  struct w { double e };
@end=cpp@

4. Now you have text between @begin=cpp@ and @end=cpp@ highlightied as C++, though filetype is not 'cpp'.

Isn't it magnificent?

-------------------------
Here is more useful version:

function! TextEnableCodeSnip(filetype,start,end) abort
  let ft=toupper(a:filetype)
  let group='textGroup'.ft
  execute 'syntax include @'.group.' syntax/'.a:filetype.'.vim'
  unlet b:current_syntax
  execute 'syntax region textSnip'.ft.'
    \ matchgroup=textSnip
    \ start="'.a:start.'" end="'.a:end.'"
    \ contains=@'.group
  hi link textSnip SpecialComment
endfunction

Now we can write something like:
  call TextEnableCodeSnip('c'   ,'@begin=c@'   ,'@end=c@'  )
  call TextEnableCodeSnip('cpp' ,'@begin=cpp@' ,'@end=cpp@')
  call TextEnableCodeSnip('sql' ,'@begin=sql@' ,'@end=sql@')
to enable highlighting of code pieces for c, cpp and sql.

VimTip 857: syntax highlighting
http://vim.sourceforge.net/tip_view.php?tip_id=

(Originally posted in http://www.livejournal.com/community/vim_ers/3546.html)

I've just found a very nice feature of syntax highlighting in Vim.

Try this:
1. Create new file (for example, qwerty.txt).
2. Execute the following:

    :syntax on
    :syntax include @CPP syntax/cpp.vim
    :syntax region cppSnip matchgroup=Snip start="@begin=cpp@" end="@end=cpp@" contains=@CPP
    :hi link Snip SpecialComment

3. Now type in following text:

This is simple text; and this is C++:
@begin=cpp@
  int q;
  struct w { double e };
@end=cpp@

4. Now you have text between @begin=cpp@ and @end=cpp@ highlightied as C++, though filetype is not 'cpp'.

Isn't it magnificent?

-------------------------
Here is more useful version:

function! TextEnableCodeSnip(filetype,start,end) abort
  let ft=toupper(a:filetype)
  let group='textGroup'.ft
  execute 'syntax include @'.group.' syntax/'.a:filetype.'.vim'
  unlet b:current_syntax
  execute 'syntax region textSnip'.ft.'
    \ matchgroup=textSnip
    \ start="'.a:start.'" end="'.a:end.'"
    \ contains=@'.group
  hi link textSnip SpecialComment
endfunction

Now we can write something like:
  call TextEnableCodeSnip('c'   ,'@begin=c@'   ,'@end=c@'  )
  call TextEnableCodeSnip('cpp' ,'@begin=cpp@' ,'@end=cpp@')
  call TextEnableCodeSnip('sql' ,'@begin=sql@' ,'@end=sql@')
to enable highlighting of code pieces for c, cpp and sql.

VimTip 858: Setting tags when working with multiple source branches.
http://vim.sourceforge.net/tip_view.php?tip_id=

This ~/_vimrc code will setup your tags variable, according to
the source tree you are working in. This is useful
when you have multiple source trees with duplicate tags
in each branch.

If you work in a single source tree, then you can hardcode
:set tags=$SRC/tags and ignore this tip.

Example:

cd /a ; ctags -r .  # creates /a/tags
cd /k ; ctags -r .  # creates /k/tags
cd /x ; ctags -r .  # creates /x/tags

cd /x/y/z ; vim /a/b/c/d/e/f/h/i.c
:set tags
   tags=/a/tags,/x/y/tags

cd /k/l/m ; vim i.c
:set tags
   tags=/k/tags  .. vim found the tags in parent of PWD and parent

" put this code in your ~/_vimrc

" Your customised tags go first.
     set tags+=~/tags,$DOC/tags

     let parent_dir = expand("%:p:h")."/"
     while match(parent_dir,"/",0)>-1 && isdirectory(parent_dir)
         let parent_tag = parent_dir."tags"
         if filereadable(parent_tag)
            exe ":set tags+=".parent_tag
         endif
         let parent_dir = substitute(parent_dir,"[^/]*/$","","")
     endwhile

     let parent_dir = getcwd()."/"
     while match(parent_dir,"/",0)>-1 && isdirectory(parent_dir)
         let parent_tag = parent_dir."tags"
         if filereadable(parent_tag)
            exe ":set tags+=".parent_tag
         endif
         let parent_dir = substitute(parent_dir,"[^/]*/$","","")
     endwhile


    unlet parent_dir parent_tag

VimTip 859: Remap % to show how many lines in between pairs
http://vim.sourceforge.net/tip_view.php?tip_id=

Add this line to your ~/.vimrc to have vim show how many lines you moved between when you hit the % key (which moves between matching pairs of characters, such as parenthesises and braces). The number of lines will be displayed at the bottom of the screen, positive for down, negative for up.

Especially useful when programming Java, C++, Perl, as % easily lets you count how many lines are in a method, class, or clause. Note that ^M needs to be typed as Ctrl+V, Ctrl+M.

" Count number of lines within this matching pair, print them
" when jumping between braces with %. Very useful. By shellreef.
nnoremap % :let line=line(".")^M%:echo line(".") - line^M

VimTip 860: count number of matches of a pattern
http://vim.sourceforge.net/tip_view.php?tip_id=

mfyahya asked at #vim on freenode this question and I told him to try a simple substitude command such like :s/pattern/foo/g, to watch the status line and to press "u" (ndo) ;) Happy vimming!

VimTip 861: Right click in Windows Explorer to open GVim in 'Ex;plorer Mode' on the current directory.
http://vim.sourceforge.net/tip_view.php?tip_id=

This may have been done before but maybe not.

There is a Windows 'reghack' that permits you to right click on a directory in Windows Explorer to open a command prompt at that same directory.  I''ve "hacked" it so as to open GVim in explorer mode at that directory.   You can then use the 'Explorer Mode' of GVim to navigate the directory and view or edit the files within.

! ---------- Windows XP / Windows 2000 / Winnt -----------------------
REGEDIT4

[HKEY_CLASSES_ROOT\Folder\shell\GVimHere]
@="gViM Here"

[HKEY_CLASSES_ROOT\Folder\shell\GVimHere\command]
@="C:\\Program Files\\Vim\\vim63\\gvim.exe ."

! ---------------------------------------------------------------------------------------

The following is the 'reghack' of the 'Command Prompt Here' for Windows 9x.  I haven't tried the alteration above on it, but I don't see why it wouldn't work.

! -------------------- Windows 9x --------------------------------------------------
REGEDIT4

[HKEY_CLASSES_ROOT\Directory\shell\DosHere]
@="Command &Prompt Here"

[HKEY_CLASSES_ROOT\Directory\shell\DosHere\command]
@="C:\\WINDOWS\\command.com /k cd \"%1\""

! ---------------------------------------------------------------------------------------

 - corp-mule

VimTip 862: how to toggle between all vertical and all horizontal window layout
http://vim.sourceforge.net/tip_view.php?tip_id=

How to change from a horizontal list to a vertical list of windows, and vice versa:

---------------------------
horizontal list of windows
to vertical list of windows
---------------------------
    W|W|W
to
    W
    W
    W

    :windo wincmd K

----------------------------
vertical list of windows
to horizonal list of windows
----------------------------
    W
    W
    W
to
    W|W|W

  :windo wincmd H

This tip was written in response to a request in comp.editors and now shared in the vim-tip database.

VimTip 863: Vimsessions utilization
http://vim.sourceforge.net/tip_view.php?tip_id=

I often use vimsession-files to save set of options, buffers, etc., that are specific for each job (see :help mksession).  To save some additional settings, which are not saved in vimsession (like commands, autocommands, functions), I use vimsession-extra file.  When I want modify that extra-file, it had to type something like :new <c-r>=v:this_session<cr>, then edit commandline to get proper extra-file name and edit it.  It was tiring.  So I wrote this plugin:

	command! -bar SessSave call SessSave()

	function! SessSave()
		if v:this_session==""
			call confirm("There is no loaded session","&Ok",1)
			return
		endif
		if 2==confirm('Save session '.v:this_session.'?',"&No\n&Yes",1)
			exe 'mksession! '.v:this_session
			call confirm('Session '.v:this_session.' saved.','&Ok',1)
		endif
	endfunction

	function! SessExtraFname()
		if v:this_session==""
			call confirm("There is no loaded session","&Ok",1)
			return ''
		endif
		return substitute(v:this_session,'\.[^.]*$','x.vim','')
	endfunction

	command! -bar SessExtraOpen   exe 'new '.SessExtraFname()
	command! -bar SessExtraReread exe 'source '.SessExtraFname()

I also put following mapping there:
	nmap <c-z>l :SessSave<cr>
Of course, you can change lhs to whatever you want, or add some extra mappings, for example for SessExtraOpen or SessExtraReread.

VimTip 864: Windows: make arrow keys work in visual mode
http://vim.sourceforge.net/tip_view.php?tip_id=

On windows, in visual mode the arrow keys do not work, they even end visual mode.

Simply put this into your _vimrc:

vnoremap <left>  h
vnoremap <right> l
vnoremap <up>    k
vnoremap <down>  j

and - voilá - they arrow keys behave like expected.

(Googling for "vim windows visual arrow" finds everything, so I'm glad you found this tip.)

VimTip 865: Easy buffer switching
http://vim.sourceforge.net/tip_view.php?tip_id=

Add to your .vimrc.

"buffer switching
nmap > :bn<CR>
nmap < :bp<CR>

Open few buffers and press < > (buffer previous, buffer next).

VimTip 866: Cut/Copy(All)/Paste with Ctrl-X/C(A)/V
http://vim.sourceforge.net/tip_view.php?tip_id=

"<Ctrl-X> -- cut (goto visual mode and cut)

imap <C-X> <C-O>vgG
vmap <C-X> "*x<Esc>i

"<Ctrl-C> -- copy (goto visual mode and copy)

imap <C-C> <C-O>vgG
vmap <C-C> "*y<Esc>i

"<Ctrl-A> -- copy all

imap <C-A> <C-O>gg<C-O>gH<C-O>G<Esc>
vmap <C-A> <ESC>gggH<C-O>G<Esc>i

"<Ctrl-V> -- paste

nm \\paste\\ "=@*.'xy'<CR>gPFx"_2x:echo<CR>
imap <C-V> x<Esc>\\paste\\"_s
vmap <C-V> "-cx<Esc>\\paste\\"_x

--
Matous Jan Fialka
http://vcp.ligatura.org/

VimTip 867: quickly get help on python libraries
http://vim.sourceforge.net/tip_view.php?tip_id=

Add this to your .vimrc, note that this requires pydoc (comes with most python)

:command -nargs=+ Pyhelp :call ShowPydoc("<args>")
function ShowPydoc(module, ...)
    let fPath = "/tmp/pyHelp_" . a:module . ".pydoc"
    :execute ":!pydoc " . a:module . " > " . fPath
    :execute ":sp ".fPath
endfunction

Then  from vim:

:Pyhelp time.strftime
:Pyhelp os
:Pyhelp yourFunkyModuleHere

VimTip 868: langmap: go-to-end-of-line problem
http://vim.sourceforge.net/tip_view.php?tip_id=

Recently I found it very helpful to use 'langmap' option.  But I've got a problem: when I switch to my language, I'm not able to use $ command (go-to-end-of-line), because keyboad layout (for my language) does not contain this character at all.

I had to press <End> (which is quite inconvinient) or switch to another layout each time I needed to to to end of line.  (Or use some another ways: pressing w considerable amount of times, or use f<char>, or anything else.)

This was awful!

But today I found another way, which is much easier: command g_ moves cursor to the last non-blank character in the line.  This works with 'langmap', for all english characters are always "mapped" properly.

See also tip #278.

VimTip 869: Opening new buffer below the current
http://vim.sourceforge.net/tip_view.php?tip_id=

Have you ever been annoyed with that fact that :new opens buffer above current?  If yes, then try :below new.  You'll like it!

It seems to be a basic feature, but I've been vimming for 4 years before I discovered it.  So/ I think, it should be placed here in case there are another people knowing not about it.

VimTip 870: Resize terminal window to original size when quitting vim
http://vim.sourceforge.net/tip_view.php?tip_id=

While editing I often decide that I need more lines or columns to complete my task, so I resize the xterm in which vim is running. After quitting, usually the xterm is too large for me and I need to do "eval `resize`", so the shell knows about the new size. I end up resizing the xterm manually again.

Put this in your ~/.vimrc, so vim returns to the original size when quitting, if the terminal supports this:

if !has("gui_running")
  augroup resize
    au VimEnter * let lines_save = &lines | let columns_save = &columns
    au VimLeave * let &lines = lines_save | let &columns = columns_save
  augroup END
endif

VimTip 871: Changing word
http://vim.sourceforge.net/tip_view.php?tip_id=

We know that * or # is used for searching the entire word no matter where the cursor is positioned within the word.
Similar idea if applied for changing a word would be helpful:

map <C-q> bcw

This is the simplest of cases that will allow you change the entire word regardless of the position of the cursor by hitting Control + q.
Thanks

VimTip 872: Finding phone numbers
http://vim.sourceforge.net/tip_view.php?tip_id=

I have a little script making the my modem dial phone numbers. As the numbers are contained in a file I edit with Vim, I call the script by

func CPhone( ...)
  " Get phone number under cursor
  let s="[-+./()0-9 ]*"
  let nr=matchstr( getline("."), "\\s*\\zs".s."\\%".col(".")."c".s)
  let nr=substitute( nr, "\\s\\+$", "", "")
  if nr == "" && a:0 && a:1
    throw "No phone number under cursor."
  endif
  return nr
endf

let @p=":exec \":!dial   \'\".CPhone(1).\"\'\"\<cr>"

augroup LocalUser
  autocmd BufRead phone* nnoremap <buffer> <cr> :exec ":!dial '".CPhone(1)."'"<cr>
augroup END

VimTip 873: Elusive buffer ring cycling .. dired mode
http://vim.sourceforge.net/tip_view.php?tip_id=

This mapping on <Control-n> will let you cycle through all
your buffers (including hidden directory listings):

  :map <C-n> :exe  ":buf ".((bufnr("%") % bufnr("$"))+1)<CR>

I had a problem for a long time when cycling thru all the buffers
since most commands (bn/bp) will skip hidden buffers.

# Example of problem.

gvim ~ /etc/motd
      gvim goes to dir ~
     :bn
       gvim goes to /etc/motd
     :bp
        but will not go back to ~, because it is hidden.
     :ls!
        ~ is there in list of the buffers 1,2

     :buf 1
          have to give it the buf number to find it.

     problem gets worse with several levels dirs navigation/browsing
     can't go back to old dirs.

Also this mapping works for ordinary files as expected.

eg. gvim *.*, then use C-n to cycle thru.

VimTip 874: Fold C-style Comments
http://vim.sourceforge.net/tip_view.php?tip_id=

Do want to make the 10-line /*style*/ comment disappear?

You can add folding capability to C-style comments using the command:
au BufNewFile,BufRead *.cpp,*.c,*.h,*.java   syn region myCComment start="/\*" end="\*/"  fold keepend transparent

This will work on C, .h, C++, and Java files.

The "keepend" and "transperent" commands are necessary to avoid overriding the default syntax highlighting of comments.

If you want to keep the "/*" beginning of the comment in the folded text, you can
use the following function:

  set foldtext=MyFoldText()
  function MyFoldText()
    let line = getline(v:foldstart)
    let sub = substitute(line, '^[\t ]*', '', '')
    let nlines = v:foldend - v:foldstart + 1
    if strlen(nlines) == 1
      let nlines = "  " . nlines
    elseif strlen(nlines) == 2
      let nlines = " " . nlines
    endif
    return "+-" . v:folddashes . nlines . ": " . sub
  endfunction

The resulting line should look about the same as the default, without removing the comments.

VimTip 875: grep and bar---AKA |, OR, or alternation
http://vim.sourceforge.net/tip_view.php?tip_id=

It took me a little while to notice this in the help file:

cmdline.txt - (help)
                                                   *:bar* *:\bar*
'|' can be used to separate commands, so you can give multiple commands
in one line.  If you want to use '|' in an argument, precede it with
'\'.

When using bar in grep from a shell prompt you would use something like:

grep -i "main\(menu\|tool\)" *
or
grep -iE "main(menu|tool)" *

but you must remember to add an extra escape the '|' character in your regex when using grep from Vim like so:

grep -i "main\(menu\\|tool\)" *
or
grep -iE "main(menu\|tool)" *

VimTip 876: selecting blocks of paragraphs.
http://vim.sourceforge.net/tip_view.php?tip_id=

I use vim in windows a lot and have to copy text from vim into  some other window. I found myself copying SQL queries a lot and figured I should save my poor fingers so many keypresses. To that end I came up with two handy mappings. The first one just selects the entire text of the paragraph that your cursor is currently within, using Control-Shift-v. The second takes it one step further, by yanking the entire paragraph your cursor is in into the * buffer (windows clipboard) all while keeping your cursor on the same line.

one:

:map <C-S-v> (V)

two:

:map <C-S-v> (V)*y''

VimTip 877: Replace all commas with new lines
http://vim.sourceforge.net/tip_view.php?tip_id=

If you wanted to turn a comma-separated list of items into a list where each item is on its own line do this in vim:
:%s/,/^M/g
do not type the "^M" literally but hit CTRL-ENTER to get it.

VimTip 878: Remove trailing spaces
http://vim.sourceforge.net/tip_view.php?tip_id=

A heavy nuisance to me are hidden spaces at line ends and before tab characters. I make them visible and remove them using two mappings:

function ShowSpaces( ...)
  let @/="\\v(\\s+$)|( +\\ze\\t)"
  let oldhlsearch=&hlsearch
  if !a:0
    let &hlsearch=!&hlsearch
  else
    let &hlsearch=a:1
  end
  return oldhlsearch
endfunction

function TrimSpaces() range
  let oldhlsearch=ShowSpaces( 1)
  execute a:firstline.",".a:lastline."substitute ///gec"
  let &hlsearch=oldhlsearch
endfunction

command -bar -nargs=? ShowSpaces call ShowSpaces(<args>)
command -bar -nargs=0 -range=% TrimSpaces <line1>,<line2>call TrimSpaces()
nnoremap <F12>     :ShowSpaces 1<cr>
nnoremap <S-F12>   m`:TrimSpaces<cr>``
vnoremap <S-F12>   :TrimSpaces<cr>

VimTip 879: change .vimrc + auto reload
http://vim.sourceforge.net/tip_view.php?tip_id=

if you find yourself always re :so ing your .vimrc after you changed it, have the following autocmd in your .vimrc:

autocmd! bufwritepost .vimrc source ~/.vimrc

VimTip 880: Shebang line automatically generated
http://vim.sourceforge.net/tip_view.php?tip_id=

In my Python or Ruby scripts, the first line is always a shebang line. I create it automatically using

augroup Shebang
  autocmd BufNewFile *.py  0put =\"#!/usr/bin/env python\<nl># -*- coding: iso-8859-15 -*-\<nl>\"|$
  autocmd BufNewFile *.rb  0put =\"#!/usr/bin/env ruby\<nl># -*- coding: None -*-\<nl>\"|$
  autocmd BufNewFile *.tex 0put =\"%&plain\<nl>\"|$
  autocmd BufNewFile *.\(cc\|hh\)  0put =\"//\<nl>//  \".expand(\"<afile>:t\").\"  --  \<nl>//\<nl>\"|2|start!
augroup END

VimTip 882: learn to use help
http://vim.sourceforge.net/tip_view.php?tip_id=

Vim's help is remarkably thorough, but it definitely takes some getting used to if you are new to it.

Starting out, remember:
* CTRL-D will list all matches to your subject so that you can narrow what you are looking for; TAB scrolls through them
* You can search within help just like within a regular file using /.
* :help help
* CTRL-] follows a link CTRL-O goes back
* read a new chapter from the main help (:help) file every now and again

VimTip 883: Automatically maximizing gvim in KDE
http://vim.sourceforge.net/tip_view.php?tip_id=

After a week of trying to find a proper way to maximize a gvim window under KDE, using the .vimrc file, the best solution that I was able to find was "pseudo-maximize", which still left extra space around the gvim window. As a result of this, I abandoned the vim configuration file and began experimenting with KDE's window-specific settings. Ironically, the solution was very simple:

First, open a gvim window and press the maximize button. Vim will generally rescale the window after you do this, so you'll need to make sure that the window is in fact maximized, typically by pressing the maximize button a second time to achieve the desired effect.

Next, right click on the title bar: Advanced -> Window Specific Settings. Select the Window tab if it isn't the default.

Click on the Detect button, and click anywhere inside the gvim window. In the window that pops up, select "Use window class (whole application)" and click Ok.

From here, move over to the Geometry tab and check the Size box. Change "Do Not Affect" to Force. You'll note that the size to the right is the same as that of the maximized window, which is the correct value. If you choose "Apply Initially" instead of Force, you'll encounter the same rescaling problem that required you to press the maximize button twice in the first step.

Please make certain that you've followed all of the above steps, as you'll need to edit these settings manually to change them. They're located in ~/.kdeX.Y/share/config/kwinrulesrc and must be edited when KDE is not running in order to avoid being overwritten. The above is tested with KDE 3.4.

Click Ok at the bottom of the window, restart gvim and enjoy.

VimTip 884: Let VIM use different color schemes dependent on time of day
http://vim.sourceforge.net/tip_view.php?tip_id=

If your Vim's version has been compiled with the +perl - feature (type ":echo has('perl')" to find out),
you can use the following lines to let Vim choose a different color scheme on startup, depending on
the actual time of day. For example, if you want something like this:

"elflord" from 19 to 4 o'clock in the morning
"morning" from 4 to 8
"desert" from 8 to 15
"evening" from 15 to 19

place the following lines somewhere into your _vimrc:

VIM::DoCommand "color " . {
    map @{ref and push(@$a,@$_),[] or $c=$_,[map{$a=[];$_,$c}@{[@$a]}]},
	[0 .. 3]   => "elflord",
	[4 .. 7]   => "morning",
	[8 .. 14]  => "desert",
	[15 .. 18] => "evening",
	[19 .. 23] => "elflord"
    }->{(localtime)[2]}

Customize the [interval] => "name-of-colorscheme" - lines to your individual needs.
Notes:
  - [0 .. 3] means 00:00 to 03:59.
  - Intervals should cover all hours from 0 to 23.

VimTip 885: Switching between different statuslines
http://vim.sourceforge.net/tip_view.php?tip_id=

The code between "---cut---" signs is a nice piece
of my ~/.vimrc which I really likes. It allows me to switch
between several different statuslines by pressing F3 key (in
normal Vim mode).

---cut---
"Theese three functions are just for example.
"It might be that these three functions are irrelevant
"in example statuslines, but they demonstrate that
"functions can be used in statusline too...

fu! Percent()
  let byte = line2byte( line( "." ) ) + col( "." ) - 1
  let size = (line2byte( line( "$" ) + 1 ) - 1)
  return (byte * 100) / size
endf

fu! FileEncoding()
  if &fileencoding == ''
    return "is not set"
  else
    return &fenc
  endif
endf

fu! GlobalEncoding()
  if &fileencoding == ''
    return "is not set"
  else
    return &enc
  endif
endf

"And now the magical stuff!
"We define some statuslines at first...

let g:StatusLines{0}='[%1*%n%*]%= [%2*%03bD%* | %2*%5(0x%02BH%)%*] [%8oC=%1*%3{Percent()}%%%*] [%8c] : [%8l/%8L = %1*%3p%%%*]'
let g:StatusLines{1}='[%1*%n%*]%= [%1*GENC%* %10(%{GlobalEncoding()}%)] [%1*FENC%* %10(%{FileEncoding()}%)]'
let g:StatusLines{2}='[%1*%n%*]%= [%1*%F%*]'
let g:StatusLinesCurrent=-1

"And we map switching on some unused key...

map <F3> :call ToggleStatusLine()<CR>

"Function that switch between several statuslines
"Made by M.W. from IRC#vim (many thanks for it)...

fu! ToggleStatusLine()
  let g:StatusLinesCurrent=g:StatusLinesCurrent+1
  if (!exists("g:StatusLines" . g:StatusLinesCurrent))
    let g:StatusLinesCurrent=0
  endif
  let &statusline=g:StatusLines{g:StatusLinesCurrent}
endf

"We use the first one as default...

call ToggleStatusLine()

"Because I used some highlighting in the example statuslines
"I put some highlighting definitions here too...

"The colours of statusline itself...

hi statusline term=inverse,bold cterm=inverse,bold ctermfg=darkred ctermbg=white
hi statuslinenc term=inverse,bold cterm=inverse,bold ctermfg=gray ctermbg=black

"Some other colours used in statuslines...

hi User1 term=inverse,bold cterm=inverse,bold ctermfg=darkred ctermbg=yellow
hi User2 term=inverse,bold cterm=inverse,bold ctermfg=darkred ctermbg=cyan
---cut---

I think that this tip should be very useful if you need
so much information that is unable to be fit in a single statusline...

Enjoy.

--
Matous Jan Fialka [ http://vcp.ligatura.org/ ]

VimTip 886: Adding vim.exe to windows "Send To" context menu.
http://vim.sourceforge.net/tip_view.php?tip_id=

Create a link of vim.exe in the "C:\Documents and Settings\<YOUR USER NAME>\SendTo" folder. This will bring vim.exe in to the "Send To" contect menu. This helps a lot when you want to open a file by using "Send To" option.

VimTip 887: q/ and q?  (Those are Q's)
http://vim.sourceforge.net/tip_view.php?tip_id=

Oops.  I went to do a q: and accidentally hit q?.  I was suprised to find myself in the command line editing window, only editing previous searches.

I thought this was  obscure enough to warrant a tip.  :)

VimTip 888: :e(dit) multiple files with a single command
http://vim.sourceforge.net/tip_view.php?tip_id=

Load multiple files into a running vim session with a single command!  Put the following in your .vimrc:

com! -complete=file -nargs=* Edit exec "!vim --servername " . v:servername . " --remote <args>"

Then do something like this to 'e(dit)' multiple files:

:Edit .vim/colors/*

VimTip 889: Nicer looking fonts on MacOSX
http://vim.sourceforge.net/tip_view.php?tip_id=

If you set up your font for gvim on MacOSX by including a line similar to this in your $HOME/.vimrc:
set gfn=Monaco:h14
you might find that the font is ugly compared to the same font used e.g. in the terminal app.
To avoid this problem, add this line to $HOME/.gvimrc:
set antialias
(tested with vim 6.3 on MacOSX 10.3.8)

VimTip 890: Last modified: <CURRENT DATETIME>
http://vim.sourceforge.net/tip_view.php?tip_id=

I find it really useful to have a line in the header of my sourcecode such as "Last modified: Sun Mar 06, 2005  01:56PM"

Insert the following code into your .vimrc and vim will automatically update the date time when you save.

" Search the first 20 lines for Last modified: and update the current datetime.
function! LastMod()
    if line("$") > 20
	let l = 20
    else
	let l = line("$")
    endif
    exe "1," . l . "g/Last modified: /s/Last modified: .*/Last modified: " .
		\ strftime("%a %b %d, %Y  %I:%M%p")
endfun

" This auto command will call LastMod function everytime you save a file
autocmd BufWrite *   ks|call LastMod()|'s

VimTip 891: Copy (parts of) filename to clipboar
http://vim.sourceforge.net/tip_view.php?tip_id=

I often need the name and/or directory of the file I'm workin on in another (windows-)application.

Therefore I've added to menu.vim:

:amenu 20.351 &Edit.Copy\ fName :let @*=expand("%:t")<CR>
:amenu 20.352 &Edit.Copy\ fPath :let @*=expand("%:p:h")<CR>
:amenu 20.353 &Edit.Copy\ rName :let @*=expand("%:.")<CR>

This will copy
fName: Onle the filename (without path)
fPath: Only the path
rName: path+filename relative to current directory

VimTip 892: Incremental Auto-Backup
http://vim.sourceforge.net/tip_view.php?tip_id=

Hello Everyone.

I was wondering how I could make an automatic backup of my edited files.
I added the following to my _vimrc:

[snip]
set backupdir=c:\temp\vim_backup
let myvar = strftime("(%y%m%d)[%Hh%M]")
let myvar = "set backupext=_". myvar
execute myvar
[snap]

So the command which is executed in this example sounds like this:

set backupext=_(050309)[15h15]

This creates backups into c:\temp\vim_backup\  having names
like myfile_(050309)[15h15] instead of myfile~

Each time my vim starts up for editing a file, backupext gets changed so
I get at least one backup per day, without overwriting backups of the day
before.

If I open and close that file more often, I could theoretically have one Backup
each minute.  ( But who would want to have that many backups ? )

VimTip 893: Aligning numbers at decimal-point
http://vim.sourceforge.net/tip_view.php?tip_id=

To see the _really_ alignment you should use a fixedsized font (eg. FixedSys on Windows) or mark this all and copy it into vim!

Suppose, you've gotten some numbers in a ugly format:

---BEG
123
2.5678
-13.44
100.5
  +47.11
---END

You want to have them nice aligned with 5 decimals written out.
First, we align any line left to the beginning:

:%s§^\s*§§

---BEG
123
2.5678
-13.44
100.5
+47.11
---END

Now we split at the decimal-point (if any) and shift the fractional part wide to the right and add five '0' at the end (because we want 5 fractional digts).
(The decimal-point has been replaced by '!' for simpleness: you are not forced to escape '!' :-)

:%s§\([-+]\?\d\+\)\.\?\(\d*$\)§\1                        !\200000§

---BEG
123                        !00000
2                        !567800000
-13                        !4400000
100                        !500000
+47                        !1100000
---END

This tricky substitue aligns the fractional part at column 15:


:%s§\%15c\s*!§!§

---BEG
123           !00000
2             !567800000
-13           !4400000
100           !500000
+47           !1100000
---END

Now we shift the integral part back by exchanging it with leading spaces (and by the mean replacing '!' by decimal-point):

:%s§\(^\S*\)\(\s*\)!§\2\1.§

---BEG
           123.00000
             2.567800000
           -13.4400000
           100.500000
           +47.1100000
---END

Now we truncate each fractional part to 5 digits:

:%s§\%21c\d*§§


---BEG
           123.00000
             2.56780
           -13.44000
           100.50000
           +47.11000
---END

Finally we add a '+'-sign where it's missing:

:%s§\s\(\d\)§+\1§

---BEG
          +123.00000
            +2.56780
           -13.44000
          +100.50000
           +47.11000
---END

Looks now very nice, doesn't it?

VimTip 894: Regex-based text alignment
http://vim.sourceforge.net/tip_view.php?tip_id=

Long-time tip reader, first-time writer.

This is a function I use often to align a section of items.

This function goes line-by-line in the range provided and searches each line for a regex match.  If it matches, this line is aligned to every other line that matches the pattern.  Patterns are matched at the beginning of the match (remember \zs !).

The second element is optional padding, which defaults to a space.

Note that this does not operate properly in the presence of tabs.

Also, it would not suprise me if this was already present in VIM somewhere... if you know where, feel free to reply.

----------------------------------------------------------
Binding:
vmap <silent> A      :call Align_Section(Prompt("Pattern: "), Prompt("Padding: "))<CR>

----------------------------------------------------------
Examples;

Given the data:

let l:range = '%'
let l:foo = 'VIM'
let l:nixon = 'Crook'

Using pattern: =
Would align the = marks.

void XYHit(int a, int b);
int StrokeUp(doublePt dp);
const *char GetString(unsigned int index);

Using pattern: ^\S\+(
Would align the start of the functions.

Using pattern: (
Would then align align the (

Doing both would result in the following:

void        XYHit    (int a, int b);
int         StrokeUp (doublePt dp);
const *char GetString(unsigned int index);

Happy VIMing!

----------------------------------------------------------
Functions:

fun! Align_Section(regex, ...) range
  let l:padding = a:0 ? a:1 : ' '

  let l:range   = a:firstline . ', ' . a:lastline
  let l:col     = 0
  let l:maxcol  = 0

  " Find the maximum column "
  let l:ln = a:firstline
  while l:ln <= a:lastline
    let l:sln = getline(l:ln)

    if l:sln =~ a:regex
      let l:col    = match(l:sln, a:regex)
      let l:maxcol = l:col > l:maxcol ? l:col : l:maxcol
    endif

    let l:ln     = l:ln + 1
  endwhile

  " Set them all "
  let l:ln = a:firstline
  while l:ln <= a:lastline
    let l:sln = getline(l:ln)

    if l:sln =~ a:regex
      let l:col = match(l:sln, a:regex)
      call setline(l:ln, strpart(l:sln, 0, l:col) . Pad('', l:maxcol-l:col, ' ') . strpart(l:sln, l:col) )
    endif

    let l:ln = l:ln + 1
  endwhile
endfun

fun! Pad(str, num, ...)
  let l:char = a:0 ? a:1 : ' '

  let l:str = a:str
  while strlen(l:str) < a:num
    let l:str = l:char . l:str
  endwhile
  return l:str
endfun

fun! Prompt(str, ...)
  let l:def = a:0 ? a:1 : ''

  call inputsave()
  exe "let l:ret = input(\"" . a:str . "\", \"" . l:def . "\" )"
  call inputrestore()

  return l:ret
endfun

VimTip 895: Maps, Commands, and Functions - some examples of their interplay
http://vim.sourceforge.net/tip_view.php?tip_id=

This tip concerns the interplay between commands, maps, and functions.  Please consider the following test script...
  - to run the script, you'll need Decho.vim (vimscript#120) and cecutil.vim (vimscript#1066) -

  (this tip is aimed for those who wish to write scripts in vimL)
 ---------------------------------------------------------------------

fun! TestOne(reg,bang,args) range
  call Dfunc("TestOne(reg<".a:reg.">,bang=".a:bang." q-args=".a:args.") firstline=".a:firstline." lastline=".a:lastline)
  call Dret("TestOne")
endfun
fun! TestTwo(reg,bang,qty,args)
  call Dfunc("TestTwo(reg<".a:reg.">,bang=".a:bang." qty=".a:qty." q-args=".a:args.")")
  call Dret("TestTwo")
endfun

" this is a test range
" this is a test range
" this is a test range
" this is a test range

com! -range -register -bang TestOne <line1>,<line2>call TestOne("<reg>",<bang>0,<q-args>)
com! -count=1 -register -bang TestTwo call TestTwo("<reg>",<bang>0,<count>,<q-args>)
nnoremap \aa :TestOne<CR>
nnoremap \bb :TestOne!<CR>
nnoremap \cc :TestOne a<CR>
nnoremap \dd :TestOne! a<CR>
nnoremap \ee :TestOne! a "abc" "def"<CR>
nnoremap \ff :10,13TestOne<CR>
nnoremap \gg :TestTwo 3<CR>

 ---------------------------------------------------------------------

 \aa : illustrates using a map to call TestOne().  When no count (ie. 5\aa)
       is provided, the only thing interesting is that firstline and lastline
	   are equal to the current line.

5\aa : Like \aa, but this time lastline= firstline+5-1 .  Thus one can pass
       a repetition count of sorts to the map.  However, one will get an
	   "Invalid range" error within four lines of the end-of-file.

\bb  : This example shows how to pass the optional "!" to a function.  Useful
       for having an alternate behavior associated with a function.

\cc  : These maps illustrates the use of <reg> -- note that the first argument
\dd  : is made available by the <reg>, and is elided from the arguments.  The
\ee    \ee map shows how arguments are still available.

\ff  : This map shows how to pass a fixed range to a function.  Here the
       <line1>,<line2> construct is being illustrated

\gg  : This map/command/function set is illustrating the use of <count>.

VimTip 896: Lookup the city and state of a given US Zip code using TCL
http://vim.sourceforge.net/tip_view.php?tip_id=

The following code allows a lookup of US ZIP code without leaving VIM. Place the cursor over a 5-digit number (the ZIP code), and choose ZipLookup from the Utilities menu. The result is then displayed at the bottom of the screen. E.g., placing the cursor over "02169" should result in "02169 ==> QUINCY, MA" being displayed.
This works by accessing the USPS web site, so one needs to be online for this to work. Since the code parses the HTML code, this breaks whenever the web site code is reorganized -which seems to happen every other year or so-, but can be fixed by adjusting the regexp (which may take a bit of fiddling). The code is in TCL, so one needs to use a TCL-enabled version of VIM.

The following should go in your gvimrc file:

if has("tcl")
	tclfile utilities.tcl

	" change the menu name and the menu item name as you see fit
	menu &Utilities.&ZipLookup		:call ZIPLookup(expand("<cword>")) <CR>

	function ZIPLookup (word)
		tcl puts [ZipLookup [::vim::expr a:word]]
	endfunction
endif

and this into utilities.tcl:

proc ZipLookup zipcode {
	package require http

	# some websites, not the usps necessarily, care what kind of browser is used.
	::http::config -useragent "Mozilla/5.0 (X11; U; Linux 2.4.22; rv:1.7.5) Gecko/20041108 Firefox/1.0"

	set url "http://zip4.usps.com/zip4/zip_responseA.jsp"

	while { [string length $zipcode] < 5 } { set zipcode "0$zipcode" }

	# the http man page is a good place to read up on these commands
	set query [::http::formatQuery zipcode $zipcode]
	set http  [::http::geturl $url -query $query]
	set html  [::http::data $http]

	# we use a regular expression pattern to extract the text we are looking for
	if {[regexp {row1 header1[^>]*>[^<]*<font[^>]*>\s*([^<]+).*row1 header2.*([A-Z][A-Z]).*row1 header3} $html => city state]} {
		return "$zipcode ==> $city, $state"
	} else {
		return "$zipcode ==> not found"
	}
}

VimTip 897: Some tips on saving the document
http://vim.sourceforge.net/tip_view.php?tip_id=

I use the following mappings to save my document -- they do away with
the need for hitting escape when I'm in visual or insert modes.

NOTE, however, that control-s will freeze some computers; if that
happens, hit control-q to get out it, curse me for suggesting the use of
control-s, thank me for suggesting the use of control-q, and create a
new sequence!

The control-s is a hang-around from Windows days.

nmap <c-s> :w<CR>
vmap <c-s> <esc><c-s>
imap <c-s> <esc><c-s>

The F2 series of mappings are different; they only write if needed
(performing an update) AND return you to where you were:  insert mode,
visual selection etc.

nmap <f2> :update<cr>
vmap <f2> <esc><f2>gv
imap <f2> <c-o><f2>

So, if you're done with a particular operation, hit control-s (or
whatever you come up with as a replacement); if you're not done, but
want to save (just to be safe), use the <f2> series of mappings.  I
think QEdit and Turbo Pascal/C, both of which I used back in the old
stone age, used F2, so it stuck in my mind.

VimTip 898: Automatic no beep *and* no flash
http://vim.sourceforge.net/tip_view.php?tip_id=

For those of you who despise both the bell and the visual flash, but cannot seem to get it set automatically on startup, you're in luck. After all, some of us have a habit of hitting the Esc key one too many times ;)

Add the line below to the vimrc file:
autocmd VimEnter * set vb t_vb=

Note:
Just adding the line:
set vb t_vb=
to the vimrc file somehow does not work. It works if entered manually with ":set vb t_vb=" from within Vim.

VimTip 899: Capitalize words and regions easily
http://vim.sourceforge.net/tip_view.php?tip_id=

All of you (hopefully) know the gu{motion} and gU{motion}
commands used to convert a region to lower/upper case.
Unfortunately, there is no possibility to capitalize a region.
Until now ...

Similar to the gu/gU commands I defined some mappings for "gc".
Easy to remember: c as in capitalize
Incidentally the "gc" mapping is not used by Vim.

To capitalize the word "example" place the cursor over the word and
type gciw (similar to guiw).
Before:  this is an example.
After:   this is an Example.

To capitalize the whole line place the cursor somewhere on the
line and either type gcgc or gcc (similar to gugu/guu).
Before:  this is an Example.
After:   This is an example.

I defined some common mappings. Please feel free to add your own.
gcw        - capitalize word (from cursor position to end of word)
gcW        - capitalize WORD (from cursor position to end of WORD)
gciw       - capitalize inner word (from start to end)
gciW       - capitalize inner WORD (from start to end)
gcis       - capitalize inner sentence
gc$        - capitalize until end of line (from cursor postition)
gcgc       - capitalize whole line (from start to end)
gcc        - capitalize whole line
{Visual}gc - capitalize highlighted text

Put the following lines into your vimrc file.
Note: These mappings depend on the tilde operator option.

if (&tildeop)
  nmap gcw  guw~l
  nmap gcW  guW~l
  nmap gciw guiw~l
  nmap gciW guiW~l
  nmap gcis guis~l
  nmap gc$  gu$~l
  nmap gcgc guu~l
  nmap gcc  guu~l
  vmap gc   gu~l
else
  nmap gcw  guw~h
  nmap gcW  guW~h
  nmap gciw guiw~h
  nmap gciW guiW~h
  nmap gcis guis~h
  nmap gc$  gu$~h
  nmap gcgc guu~h
  nmap gcc  guu~h
  vmap gc   gu~h
endif

VimTip 900: Right Aligned Comment Block
http://vim.sourceforge.net/tip_view.php?tip_id=

Put this in your .vimrc file and you can have nicely aligned comment boxes

map ,co O#====================================================================================================<CR>#<CR>#====================================================================================================<ESC>100\|Dkk100\|DjA

NOTE:
* The above should all be on one line.
* There is a space after the "A" at the end of the line above.
* While in navigation mode use ,co to create a comment block
* The comment block will chop off at column 100
* It relies on having autoindent set

Have fun

-Ken

VimTip 901: Text objects for strings in vim 6.x
http://vim.sourceforge.net/tip_view.php?tip_id=

This little function adds support for common operations on string text objects like

di" Delete Inner String
ca' Change A String

and so on. Strings have to be on one line. See :help text-objects for a description of other predefined text objects.

function! JHStringObject(cmd,delim,mode)
    if a:mode == 'i'
        let c = 'normal T' . a:delim . a:cmd . 't' . a:delim
    elseif a:mode == 'a'
        let c = 'normal F' . a:delim . a:cmd . 'f' . a:delim
    endif
    execute c
    if a:cmd == 'c'
        normal l
        startinsert
    endif
endfunction

nnoremap di" :call JHStringObject('d','"','i')<CR>
nnoremap di' :call JHStringObject('d',"'",'i')<CR>
nnoremap da" :call JHStringObject('d','"','a')<CR>
nnoremap da' :call JHStringObject('d',"'",'a')<CR>
nnoremap ci" :call JHStringObject('c','"','i')<CR>
nnoremap ci' :call JHStringObject('c',"'",'i')<CR>
nnoremap ca" :call JHStringObject('c','"','a')<CR>
nnoremap ca' :call JHStringObject('c',"'",'a')<CR>
nnoremap yi" :call JHStringObject('y','"','i')<CR>
nnoremap yi' :call JHStringObject('y',"'",'i')<CR>
nnoremap ya" :call JHStringObject('y','"','a')<CR>
nnoremap ya' :call JHStringObject('y',"'",'a')<CR>

VimTip 902: A command manipulate &path
http://vim.sourceforge.net/tip_view.php?tip_id=

The WHY:

Some include paths (VC7 in particular) are very deep, so much so that I opted
to "set complete-=i" (which is to say to NOT 'scan current and included files'
during completion; see :h complete).

This allowed me to <ctrl+n>/<ctrl+p> without delay, and when I knew what I was
trying to complete was in the system includes (sprintf for instance) I could
use CTRL-X CTRL-I (see: :h i_CTRL-X_CTRL-I) as needed, for instance
'spr<ctrl-x><ctrl-i>'. This worked like a charm for many moons. Until recently
when I've found a need to have a different set of includes to search and I
wanted normal CTRL-N/CTRL-P to search these files and NOT the system include. I
was also getting kind of tired of not searching the current directory via
CTRL-N/CTRL-P as well.

A Solution:	aka Enter hair brained scheme #1

The concept is simple, search the path each time (i.e."set complete+=i", which
is default) but limit what the path is.

The solution.. well it is pretty simple too really.

I decided on a few global scoped variables to hold my paths and then a
function/command to help set &path. Seemed easy enough.

This is from my .vimrc and as you can see it is a mess. It does (as far as I
know!) function properly with no adverse effects, but I am very definitely not
certain of that yet.

--------------------------------------------------

if has("win32")
	" Base path :".,,"
	let g:feral_path_B	= &path
	" System include path
	set path=C:/PROGRA~1/MICROS~1.NET/Vc7/include/**
"	set path+=C:/Program\ Files/Microsoft\ Visual\ Studio\ .NET/Vc7/PlatformSDK/include/prerelease/**
	let g:feral_path_S	= &path
	" project include path
	set path=C:/Program\ Files/ClanLib/include/**
""	set path=C:/Program\ Files/ClanLib/ClanLib-0.7/Sources/**
	let g:feral_path_P	= &path

	" start off with base path
	execute "set path=".g:feral_path_B

	function Feral_Path(whichpaths)
		if strlen(a:whichpaths)
			let old_path = &path
			set path=
			let paths_to_use = a:whichpaths
			while strlen(paths_to_use)
"				call confirm("SO:"."\npath_to_use:".paths_to_use."\npath_to_use[0]:".paths_to_use[0]."\nExists?".exists("g:feral_path_{paths_to_use[0]}") )
				if exists("g:feral_path_{paths_to_use[0]}")
"					call confirm("is1:".g:feral_path_{paths_to_use[0]})
					execute "set path+=".substitute(g:feral_path_{paths_to_use[0]}, "\\ ", "\\\\ ", "g")
"execute "set path+=".substitute("C:/Program\ Files/ClanLib/include/**", "\\ ", "\\\\ ", "g")
"execute "set path+="."C:/Program\\ Files/ClanLib/include/**"

"					call confirm("is2:".&path)
					" remove the first char from paths_to_use now
					let paths_to_use = strpart(paths_to_use,1)
"					call confirm("is3:".paths_to_use)
				else
					" not found; remove this char and see if we can try again.
					let paths_to_use = strpart(paths_to_use,1)
"					call confirm("is4:".paths_to_use)
				endif
			endwhile
"			call confirm("outside while")
			if strlen(&path) == 0
"				call confirm("restoring path as it was when we got here.")
				execute "set path=".old_path
			endif
		endif
"		call confirm("outside outer if")
	endfunction
	command	-nargs=1	FP	call Feral_Path(<q-args>)
endif

--------------------------------------------------

The Usage:

To use this the above code frag must be sourced, in my case this is in my
.vimrc.

You need some paths to switch between, these global variables must start with
"g:feral_path_" and the last character is used to identify (NOTE: SINGLE CHAR
ONLY!) the path.

For instance:

--------------------------------------------------
	set path=C:/PROGRA~1/MICROS~1.NET/Vc7/include/**
"	set path+=C:/Program\ Files/Microsoft\ Visual\ Studio\ .NET/Vc7/PlatformSDK/include/prerelease/**
--------------------------------------------------

Note how I use 'set path=' and thus can use this more or less naturally,
includeing += to add an additional path. Not strickly necessary but does not
hurt anything as far as I know.

--------------------------------------------------
	let g:feral_path_S	= &path
--------------------------------------------------

I then set my global variable (this one is referenced as 'S') to the current
value of &path.

It is a bit messy but it is straight forward and to the point.

I also define the base path (referenced as 'B'), and my project path
(referenced as 'P').  NOTE how 'B' is set to &path 's initial value; which in
my case is the default for the system.

--------------------------------------------------
	" Base path :".,,"
	let g:feral_path_B	= &path
	" System include path
	set path=C:/PROGRA~1/MICROS~1.NET/Vc7/include/**
"	set path+=C:/Program\ Files/Microsoft\ Visual\ Studio\ .NET/Vc7/PlatformSDK/include/prerelease/**
	let g:feral_path_S	= &path
	" project include path
	set path=C:/Program\ Files/ClanLib/include/**
""	set path=C:/Program\ Files/ClanLib/ClanLib-0.7/Sources/**
	let g:feral_path_P	= &path
--------------------------------------------------

So this gives us 3 paths to play with, B (base), S (system) and P (project).

I set &path to the default value I want directly:
--------------------------------------------------
	" start off with base path
	execute "set path=".g:feral_path_B
--------------------------------------------------

Now, to use this when you are coding away you can *easily* change &path via the
:FP command.

:FP takes one argument, that argument is the one-word group of paths to set,
use the one character to reference each path;

i.e.
:FP B
echo &path: .,,
to set path to basic and system, i.e.
:FP BS
echo &path: .,,,C:\PROGRA~1\MICROS~1.NET\Vc7\include**

or if I wanted system then basic:
:FP SB
echo &path: C:\PROGRA~1\MICROS~1.NET\Vc7\include**,.,,

As you can see it is pretty simple to manipulate &path now via the :FP command.

You can specify one or more paths to set:
:FP BPS
echo &path: .,,,C:/Program Files/ClanLib/include/**,C:/PROGRA~1/MICROS~1.NET/Vc7/include/**

All in all this should be fairly simple to use, the major problem I see is
forgetting the reference chars, but hopefully with clever naming this won't be
a problem.

An alternative to the above mess:

You could of course forgot the above mess and just have menu
entries/commands/mappings/what have you that sets &path directly.

Closing remarks:

All in all this is a simple, quick HACK that perhaps no one will every find of
use.

I submit this as a tip in the hopes that it might be useful in someway to
someone.

I suggest you be a little leery of the code, though it *should* be fine. But,
we all know how that goes! (=

Happy Vimming!

VimTip 903: Capitalize words in insert & normal mode *with no cursor displacement*
http://vim.sourceforge.net/tip_view.php?tip_id=

For those of you who require a way of capitalizing (or toggling the case) of words in either insert or normal mode but want the cursor to stay put where it currently is, you're in luck.

The mappings below work in such a way where the word being capitalized is the word where one of its alphabets is being "touched" by the cursor.

When it is in normal mode, the cursor only touches the alphabet underneath it (i.e. alphabet under flashing cursor block).
When it is in insert mode, the cursor touches the alphabet beside it. A few examples below (assume pipe character as cursor):

1. foo| bar <<< "foo" gets capitalized
2. foo |bar <<< "bar" gets capitalized
3. foo b|ar <<< "bar" gets capitalized
3. foo bar    |   tool   <<< no word gets capitalized

Cursor stays where it is after capitalization, in its current mode :)

================
"Place in vimrc file
"<F7> for word case toggle & <F8> for word capitalization

"Normal mode mappings:
nmap <F7> mzg~iw`z
nmap <F8> mzgUiw`z

"Insert mode mappings:
imap <F7> _<Esc>mza<C-Right><Esc>bg~iw`zi<Del>
imap <F8> _<Esc>mza<C-Right><Esc>bgUiw`zi<Del>

================

Notes:
<F7> & <F8> can be changed to desired mapping
"~" for togglecase, "U" for uppercase & "u" for lowercase change

VimTip 904: Convenience wrapper for setline
http://vim.sourceforge.net/tip_view.php?tip_id=

Occasionally, when writing scripts, I have to use the setline functionality to change the contents of a line; more often than not, the cursor is already on the line that I want changed.  Just to make life a little bit easier, I wrote a version of setline (called Setline) that does two things:

1.  Changes the order of the input parameters so the text for replacement is provided before the line number.
2.  If no line number is provided (only one parameter) it assumes you mean the current line -- I use this mode the most.

Otherwise, it is just a wrapper for the built-in setline and calls it after setting up the line number and swapping the order of the parameters.

Here is my wrapper for the built-in setline function:

function! Setline (...)
  let lineno=line('.')

  "check arguments
  if (a:0 < 1)
    return
  elseif (a:0 > 1)
    let lineno=a:2
  endif

  return setline (lineno, a:1)
endfunction

VimTip 905: Remember my buffers!
http://vim.sourceforge.net/tip_view.php?tip_id=

Vim can remember the list of your opened buffers even after you close vim.

In vim, or .vimrc do:

:exec 'set viminfo=%,' . &viminfo

The '%' flag tells vim to remember your list of opened buffers in your .viminfo file.

Try, for example, opening vim and editing your .vimrc file.  Then without :bd 'ing the buffer, quit vim (:wq).  If you open vim again, check your buffer list (:ls) and you will notice that the .vimrc buffer is still there.

This is similar to an MRU plugin, but it isn't.

VimTip 906: Toggle auto-indenting for code paste
http://vim.sourceforge.net/tip_view.php?tip_id=

I hate typing :nosi and :noai, so I just put it into my vimrc as a toggling function.
This will make F2 turn em on and off, so you can paste in code that doesn't end up
indented all the way across the screen.

**I'm pretty new to vim scripting so the code may not be great.

" Set or remove autoindent and smart indent
function! ToggleForPaste()
    if &si == 1
        exe 'set nosi'
    else
        exe 'set si'
    endif
    if &ai == 1
        exe 'set noai'
    else
        exe 'set ai'
    endif
endfunction

noremap <buffer> <F2> :call ToggleForPaste()<CR>

VimTip 907: Keep Passwords in encrypted file
http://vim.sourceforge.net/tip_view.php?tip_id=

I keep some of my passwords in a vim encrypted file (see :h :X).
I know encryption is not strong but I think for me it is ok ...
It is even ok for me to open it directly when asked face to face for a common group password,
since I use folding in the modeline to make the file appear like this:

my pc1
+-- 3 lines mylogin1
my pc2
+-- 3 lines mylogin2

The format of the file is organized in blocks separated by blank lines where in each block all but the first line are indented,
i.e. they look like this:

my pc1
  mylogin1
  mypasswd1

my pc2
  mylogin2
  mypasswd2

Now comes the trick for the modeline (line 1 of the file) which is just this:
vi: noswapfile bufhidden=wipe tw=0 fdm=expr foldexpr=getline(v\:lnum)=~'^\\s\\|^$'

Short explanation:
    noswapfile to keep others from sniffing in the swapfile
    bufhidden=wipe to erase all session information when the file is left
    the fold commands fold as described above

VimTip 908: Move cursor up/down virtually in insert mode
http://vim.sourceforge.net/tip_view.php?tip_id=

This is for those of you who do not edit in virtualedit mode but would occasionally want to move the cursor up/down virtually to get the cursor to a character column quickly. Keep in mind, the mappings below is basically a switch to virtualedit mode, followed by a cursor move up/down and a switch back to non-virtualedit mode, with a couple of minor details.

Here is an example of the effect:

Let's say you have your cursor (the pipe character) between 'a' and 'b' in the first line. Also assume the second line ends at the character 'z'.

aaaaa|bbb
oz

Moving the cursor down virtually would have the cursor 5 characters from the beginning of the second line, automatically inserting 3 spaces between the new cursor location and character 'z'. The colon indicates the previous cursor location.

aaaaa:bbb
oz   |

=====
"place in vimrc
"cursor down/up existing lines
imap <S-Down> _<Esc>mz:set ve=all<CR>i<Down>_<Esc>my`zi<Del><Esc>:set ve=<CR>`yi<Del>
imap <S-Up> _<Esc>mz:set ve=all<CR>i<Up>_<Esc>my`zi<Del><Esc>:set ve=<CR>`yi<Del>

"cursor down with a new line
imap <S-CR> _<Esc>mz:set ve=all<CR>o<C-o>`z<Down>_<Esc>my`zi<Del><Esc>:set ve=<CR>`yi<Del>
=====

Notes:
The mappings of Shift-Up/Down/Enter may not work with terminal versions of Vim (in which case, switch mappings to another key sequence). Works fine with GVim.
After mapping is done, mode is set back to non-virtualedit.
These mappings are for insert mode, not while in replace mode.

VimTip 909: Slide line forward/backward using indentation in insert & normal mode *with no cursor displacement*
http://vim.sourceforge.net/tip_view.php?tip_id=

The mappings provided below are basically indentations that could easily be achieved by typing ">>" or "<<" to indent forward or backward, respectively, in normal mode with a minor difference: the cursor stays fixed relative to its location on the pre-shifted line and remains in its current mode (whether the mapping be done in normal or insert mode).

=====
"place in vimrc
"shift line forward (Ctrl-Shift-Tab for backward shift)
nmap <C-Tab> i_<Esc>mz:set ve=all<CR>o<C-o>`z<Down>_<Esc>:exe "normal >>"<CR>my`z:exe "normal >>"<CR>`y<Up>mz<Down>dd`z:set ve=<CR>i<Del><Right><Esc>

nmap <C-S-Tab> i_<Esc>mz:set ve=all<CR>o<C-o>`z<Down>_<Esc>:exe "normal <<"<CR>my`zi<Del><Esc>:exe "normal <<"<CR>`y<Up>mz<Down>dd`z:set ve=<CR>:<Del>

imap <C-Tab> _<Esc>mz:set ve=all<CR>o<C-o>`z<Down>_<Esc>:exe "normal >>"<CR>my`z:exe "normal >>"<CR>`y<Up>mz<Down>dd`z:set ve=<CR>i<Del>

imap <C-S-Tab> _<Esc>mz:set ve=all<CR>o<C-o>`z<Down>_<Esc>:exe "normal <<"<CR>my`zi<Del><Esc>:exe "normal <<"<CR>`y<Up>mz<Down>dd`z:set ve=<CR>i
=====

Notes:
These mappings are probably a dirty way of doing it. Perhaps the more elegant way would be to write a function. Feedback is appreciated.
The mappings of Ctrl(-Shift)-Tab may not work with terminal versions of Vim (in which case, switch mappings to another key sequence). Works fine with GVim.
The imaps are for insert mode, not while in replace mode.

VimTip 910: upload files from vim (using python)
http://vim.sourceforge.net/tip_view.php?tip_id=

I often have a local working copy of a remote directory tree (e.g. a website) and sometimes I want to transfer some minor changes to a file very fast (e.g. when updating a webpage).
You can do this by simply typing :Upload while editing a file using the following line in .vimrc:

:command Upload :!upload.py %;

The file upload.py ( http://www.vug.de/t/upload.py.txt ) must be in your PATH:
upload.py:
-----------------------

#!/usr/bin/env python
import os, sys

# cmd parsing
if len(sys.argv)>1 and os.path.isfile(sys.argv[1]): file=sys.argv[1]
else: print "Usage: upload.py <file>"; sys.exit()

# can be overridden by environment variables
mode='scp'
server='your_server.org'
user='username_on_server
remote_root='/your/root/on/server'
local_root='/your/local/root'

# override defaults with environment variables
if os.getenv('UPLOAD_MODE'): mode = os.getenv('UPLOAD_MODE')
if os.getenv('UPLOAD_SERVER'): mode = os.getenv('UPLOAD_SERVER')
if os.getenv('UPLOAD_USER'): user = os.getenv('UPLOAD_USER')
if os.getenv('UPLOAD_REMOTE_ROOT'): mode = os.getenv('UPLOAD_REMOTE_ROOT')
if os.getenv('UPLOAD_LOCAL_ROOT'): mode = os.getenv('UPLOAD_LOCAL_ROOT')

# add other modes here
if mode=='scp':
         if not os.getcwd().startswith(local_root): print 'file not in %s'%local_root; sys.exit()
         else: ext_path=os.path.join(os.getcwd().replace(local_root, remote_root), file)
         cmd = 'scp %s %s@%s:%s'%(file, user, server, ext_path)
         failure = os.system(cmd)
         if failure: print "Running %s failed..."%cmd
-----------------------
You will have to specify your server, your directory on the server, the user on the server and the local directory root which is corresponding to the remote directory.
(You can specify the location either in the script, or as environment variables as
export UPLOAD_REMOTE_ROOT=/some/directory
...

If the file you are editing is in the specified local directory or one of its subdirectories, the script will automatically upload it to the correct location.
Of course this is only of use if you have one major directory on one major server. If you have data on multiple servers, this script won't help, since you always
have to specify the server and the corresponding directories.
I would also have liked to implement this functionality in VIM's internal language, but I was just too impatient :-)

VimTip 911: How to make fileencoding work in the modeline
http://vim.sourceforge.net/tip_view.php?tip_id=

Currently fileencoding does not work well in a modeline: when Vim sees the fileencoding setting, the file has already been read, and only output will be affected, which will cause even more trouble (suppose the default encoding is latin1, the modeline has fileencoding=utf-8, and the result file will be a utf-8 file converted as latin1 to utf-8 again!).

Before Bram handles this often-encountered problem with a more decent solution, you could try my hack. I have these lines in _vimrc:

  function! CheckFileEncoding()
    if &modified && &fileencoding != ''
      exec 'e! ++enc=' . &fileencoding
    endif
  endfunction

  au BufWinEnter *.txt call CheckFileEncoding()

Change the "*.txt" part if need be. You may also want to put "set encoding=utf-8" (to edit files of different encodings simultaneously) and "language messages en" (display all menus and messages in English) in your _vimrc file.

VimTip 912: smart abbreviation
http://vim.sourceforge.net/tip_view.php?tip_id=

Hi,
I love the abbreviations in vim, but sometimes , exspecially when writing Strings there might be a small Problem... Words in the Strings matching my keywords are expanded :(
Here are some small snippets, which helped me dealing with keywords in Strings.
First off all the functions:
---------------------------------------
func! JAVA_EatChar(pat)
	let c=nr2char(getchar())
	return (c =~ a:pat) ? '' : c
endfunc
---------------------------------------
JAVA_EatChar is taken from the vim helpfiles and removes the character trigering the expansion

----------------------------------------------------------------------
func! JAVA_insert_p()
    let modeVal=synIDattr( synIDtrans( synID(line("."), col("."), 0)), "name")
    return modeVal!=?"Constant"
endfunc
-----------------------------------------------------------------------
JAVA_insert_p is a predicate which checks whether we are typing a String or not :)

------------------------------------------------------------------------
func! JAVA_replace(name, repl)
    if JAVA_insert_p()
	exec a:repl
	return ""
    else
	exec a:name
	return " "
    endif
endfunc
----------------------------------------------------------------------------
And finally the replace function, which execeutes name or repl.
- name is a short String being executed, if you are in a String
- repl is to be executed, when you want your expansion. Not very elegant, but it works

And finally some mappings:
----------------------------------------------------------------------------
iabbrev <silent> <buffer> for for<C-R>=JAVA_replace("", "normal i(){\n}\ekf(\el")<Enter><C-R>=JAVA_EatChar('\s')<CR>
iabbrev <silent> <buffer> fori for(int i=0;;i++){<ENTER>}<ESC>k^f;a<C-R>=JAVA_EatChar('\s')<CR>
iabbrev <silent> <buffer> forint for(int){<ENTER>}<ESC>kf)i
iabbrev <silent> <buffer> foriti for(Iterator i=;i.hasNext();){<Enter>}<ESC>kf=a<C-R>=JAVA_EatChar('\s')<CR>
iabbrev <silent> <buffer> forit for(Iterator){<ENTER>}<ESC>kf)i
iabbrev <silent> <buffer> while while<C-R>=JAVA_replace("", "normal i(){\n}\ekf(\el")<ENTER><C-R>=JAVA_EatChar('\s')<CR>
iabbrev <silent> <buffer> sysout <C-R>=JAVA_replace("normal isysout", "normal iSystem.out.println();\eF)")<CR><C-R>=JAVA_EatChar('\s')<CR>
iabbrev <silent> <buffer> syserr <C-R>=JAVA_replace("normal isyserr", "normal iSystem.err.println();\eF)")<CR><C-R>=JAVA_EatChar('\s')<CR>
iabbrev <silent> <buffer> privfun private(){<Enter>}<ESC>kf(i
iabbrev <silent> <buffer> pubfun public(){<Enter>}<ESC>kf(i
iabbrev <silent> <buffer> profun protected(){<Enter>}<ESC>kf(i
iabbrev <silent> <buffer> tryc try{<ENTER>}catch(){}<ESC>F)i<C-R>=JAVA_EatChar('\s')<CR>
iabbrev <silent> <buffer> trya try{<ENTER>}catch(Exception e){}<ESC>O<C-R>=JAVA_EatChar('\s')<CR>
------------------------------------------------------------------------------------------
I'm using JAVA_replace for:
for
while
sysout
syserr
but not for e.g. fori or forint.
This is very important, cause if you define e.g. fori with JAVA_replace the expansion will be executed with "exec" which will call the abbreviation for "for", thus unfortunatelly defining abbr. for keywords which extend other keywords will become some kind of tricky.
But since the functions don't do any syntax checking by themself, it won't be difficult to apply em to any other language.
bye :)

VimTip 913: Add a command to remove a file from vim
http://vim.sourceforge.net/tip_view.php?tip_id=

You can of course create a command/map to execute the external "rm" or "del" command depending on the OS and environment, but Vim has a delete() function which works very well, and I like to do it this way because it works on all environments without much effort. Put the following in your vimrc (all on one line) and you can use the "Remove" command with the normal vim command-line arguments (such as "%" to remove the current file). It also has filename completion.

command! -complete=file -nargs=1 Remove :echo 'Remove: '.'<f-args>'.' '.(delete(<f-args>) == 0 ? 'SUCCEEDED' : 'FAILED')

Once you execute the command, watch out for the "SUCCEEDED" status for confirmation. This only removes the file on the filesystem, so if you want, you can explicitly delete/wipeout the vim buffer too.

Hari

VimTip 914: Looking for the perfect programming font ?
http://vim.sourceforge.net/tip_view.php?tip_id=

Changed from Debian to Ubuntu on my Laptop today and noticed
that I don't like the default font used by gvim. So I started to look
for an alternative and found this wonderful page:

http://www.proggyfonts.com/index.php?menu=about

The first impression from the Proggy Clean font is really good! The
only problem I had was the installation of the font. (I use gvim with gtk2)

Tried the pcf format first and couldn't get the font registered by
freetype/fontconfig which means I could select it via "xfontsel" but
not with the gtk2 font selector. Probably a gtk build would have worked.

Anyway -- the ttf format works fine. Just copy ProggyCleanTT.ttf in ~/.fonts
and run "fc-cache" once. This should work on every Unix system with
fontconfig installed.

Afterwards start gvim and and choose the font or insert
"set guifont=ProggyCleanTT\ 12" in your .gvimrc.  Note that the size of
12pt is necessary for a good look.

VimTip 915: An alternative to :s
http://vim.sourceforge.net/tip_view.php?tip_id=

I re-fell in love with :g/ when I discovered "norm f{char}".  Say you want to delete the two words between the url and the IP address, and "has address" isn't spelled the same consistently throughout (preventing us from doing
:s/has address//). You can do this:

  :g/-/norm f w2dw

... changes this:

    yahoo.com             hav address 216.109.112.135
    yahoo.com             has addrwss 66.94.234.13
    google.com            hqs address 216.239.37.99
    google.com            has zddress 216.239.57.99
    google.com            has addrers 216.239.39.99
    msn.com               has addresr 207.68.172.246
    vhost.sourceforge.net has addsess 66.35.250.210
    hotmail.com           has adbress 64.4.33.7
    hotmail.com           has amdress 64.4.32.7
    about.com             has admress 207.241.148.80
    wikipedia.com         has addrens 207.142.131.235
    ebay.com              has add;ess 66.135.192.87
    amazon.com            hds address 207.171.166.48
    amazon.com            has addr'ss 207.171.166.102
    amazon.com            hxs address 207.171.163.90
    amazon.com            has addre=s 207.171.163.30


... to this:

    yahoo.com             216.109.112.135
    yahoo.com             66.94.234.13
    google.com            216.239.37.99
    google.com            216.239.57.99
    google.com            216.239.39.99
    msn.com               207.68.172.246
    vhost.sourceforge.net 66.35.250.210
    hotmail.com           64.4.33.7
    hotmail.com           64.4.32.7
    about.com             207.241.148.80
    wikipedia.com         207.142.131.235
    ebay.com              66.135.192.87
    amazon.com            207.171.166.48
    amazon.com            207.171.166.102
    amazon.com            207.171.163.90
    amazon.com            207.171.163.30

Of course, the example I've displayed doesn't demonstrate much power (you could do "2dw" then "j." 14 times), but many many keystrokes could be avoided in a given situation.

For more info on the bits and pieces of the command:

  :h f
  :h normal
  vimtip #305
  vimtip #227
  vimtip #31

-Ethan

VimTip 916: Expose only what you're editing
http://vim.sourceforge.net/tip_view.php?tip_id=

Ever have a giant file with many function definitions you want to hide while you edit only a few functions?  Folding (see :h fold) is a great way to "shrink" a file down to size, while you concentrate on a few fragments of the file you're editing.  Putting the following vim function definition in a file (I always name it ".vimrc") in the same directory as the file you're editing, allows you to hide all the functions you want (provided you bracket using the style below, notice the {}'s on their own lines):

sub foo
{
   some code ...
}

To use it, source the file, then do :call HideFunctionDefs() to invoke the function, which will hide the bodies of the functions you don't care to see.

The following example hides foo1, foo2, foo3, and foo4.

    function! HideFunctionDefs()
       if search("sub foo1") > 0
            normal jv%zf
        endif
       if search("sub foo2") > 0
            normal jv%zf
       endif
       if search("sub foo3") > 0
           normal jv%zf
       endif
       if search("sub foo4") > 0
           normal jv%zf
       endif
    endfunction

If you bracket like this:

sub foo {
   some code ...
}

Replace all instances of "normal jv%zf" with "normal f{v%zf".

To hide more functions, add more if-endif blocks substituting "sub foo_" with the names of the functions you want to hide.

VimTip 917: Word, down/up, Home/End, PageUp/PageDown visual selection & Word deletion
http://vim.sourceforge.net/tip_view.php?tip_id=

Perhaps the most useful thing I do in Windows editing (be it in MS Word or Notepad-variant) is to hold down both Ctrl-Shift keys and press either up/down/left/right arrow keys or Home/End/PageUp/PageDown keys to select an area that could encompass word-by-word, line-by-line or page-by-page. This allows me to quickly edit or delete my text. This feature is prominent in Windows and I find myself using it too often with any edit box, like in a web browser or chat messenger.

Also, holding down the Ctrl key and pressing either Backspace or Delete keys delete word-by-word.

The features mentioned above work differently and are somewhat clumsy in Vim - requiring many keystrokes and often a change from insert to normal mode and back from visual. Some features do not exist. Hence, I thought of combining these features with Vim as a way of bringing Vim closer to the standard editing tools most textboxes have. Plus, this would be a great way for new users to get acquainted with Vim.

NOTE1: These mappings utilize the Ctrl & Shift keys that may *NOT* work with terminal versions of Vim. They SHOULD work with GVim.

NOTE2: I have set up these mappings to work just the way I would like it to do. They may not conform to how it actually is when the same keystrokes are performed in another editor (e.g. textboxes in Windows or X11). Try it and see if you like it :)

NOTE3: No, v<End><C-d><End> is not the same as v<PageDown>. Both <End>'s are necessary to give its effect. I'm slightly dissatisfied with the <C-Del> mapping done when the cursor is at the end of a line. It pulls the next line up and _deletes the first word_. Any ideas on how to prevent it from taking the first word, but still take the eol?

NOTE4: Feedback is appreciated. Let me know if the mappings break for some reason.

=========================
"place in vimrc file

"word selection
nmap <C-S-Left>  vbge<Space>
nmap <C-S-Right> vew<BS>
imap <C-S-Left>  _<Esc>mz"_xv`z<BS>obge<Space>
imap <C-S-Right> _<Esc>my"_xi<S-Right><C-o><BS>_<Esc>mz"_xv`yo`z
vmap <C-S-Left>  bge<Space>
vmap <C-S-Right> ew<BS>

"down/up selection
nmap <C-S-Down>  v<Down>
nmap <C-S-Up>    v<Up>
imap <C-S-Down>  _<Esc>mz"_xv`zo`z<Down><Right><BS><BS>
imap <C-S-Up>    _<Esc>mz"_xv`z<Up>o`z<BS>o
vmap <C-S-Down>  <Down>
vmap <C-S-Up>    <Up>

"home/end selection
nmap <C-S-Home> v<Home>
nmap <C-S-End>  v<End>
imap <C-S-Home> _<Esc>mz"_s<C-o><Left><C-o>`z<Esc>v<Home>
imap <C-S-End>  _<Esc>mz"_xv`zo<End>

"half page down/up selection
nmap <C-S-PageDown> v<End><C-d><End>
nmap <C-S-PageUp>   v<Home><C-u>
imap <C-S-PageDown> _<Esc>mz"_xv`zo<End><C-d><End>
imap <C-S-PageUp>   _<Esc>mz"_xv`z<BS>o<Home><C-u>
vmap <C-S-PageDown> <End><C-d><End>
vmap <C-S-PageUp>   <Home><C-u>

"word deletion
imap <C-BS>  <C-w>
imap <C-Del> _<Esc>mzew<BS>i<Del><Esc>v`z"_c
=========================

VimTip 918: Yet another increasing number utility
http://vim.sourceforge.net/tip_view.php?tip_id=

fun! Incr()
    let l  = line(".")
    let c  = virtcol("'<")
    let l1 = line("'<")
    let l2 = line("'>")
    if l1 > l2
        let a = l - l2
    else
        let a = l - l1
    endif
    if a != 0
        exe 'normal '.c.'|'
        exe 'normal '.a."\<c-a>"
    endif
    normal `<
endfunction

vnoremap <c-a> :call Incr()<cr>

You can use this script for increasing number in a column. For example, you want to initialize an array with the value i for the element i. You can type :
my_array[0] = 0;
Then you can copy and paste this line.
my_array[0] = 0;       my_array[0] = 0;
my_array[0] = 0;       my_array[0] = 1;
my_array[0] = 0;       my_array[0] = 2;
my_array[0] = 0; --> my_array[0] = 3;
my_array[0] = 0;       my_array[0] = 4;
my_array[0] = 0;       my_array[0] = 5;
my_array[0] = 0;       my_array[0] = 6;
--> means select the second column of 0 by ctrl-v, and type ctrl-a.
By doing the same manipulation on the first colum of 0, you obtain :
my_array[0] = 0;       my_array[0] = 0;
my_array[0] = 1;       my_array[1] = 1;
my_array[0] = 2;       my_array[2] = 2;
my_array[0] = 3; --> my_array[3] = 3;
my_array[0] = 4;       my_array[4] = 4;
my_array[0] = 5;       my_array[5] = 5;
my_array[0] = 6;       my_array[6] = 6

This script is very simple, and works pretty well. If you search something more elaborate, there are some others tips/scripts :
vimtip #150
vimscript #145
vimscript #156
vimscript #189

Another method using macro is exposed in the help :
1. Create the first list entry, make sure it starts with a number.
2. qa        - start recording into buffer 'a'
3. Y         - yank the entry
4. p         - put a copy of the entry below the first one
5. CTRL-A    - increment the number
6. q         - stop recording
7. <count>@a - repeat the yank, put and increment <count> time

VimTip 919: Moving by screen lines instead of file lines
http://vim.sourceforge.net/tip_view.php?tip_id=

I just came across this in the vim mailing list. I had wanted to this sort of thing for a long time.

Using 'gj' and 'gk' instead of just 'j' and 'k' allows moving down and up by screen lines instead of file lines. This is the behaviour common in most word processors and other text editors (notepad and the like)
Thanks to Tony for this mail.

Here is the text from that mail:

You can move the cursor by screen lines with gj and gk. Here are a few
nifty mappings for that:

:noremap <Up> gk
:noremap! <Up> <C-O>gk
:noremap <Down> gj
:noremap! <Down> <C-O>gj
" the following are optional, to move by file lines using Alt-arrows
:noremap! <M-Up> <Up>
:noremap! <M-Down> <Down>
:noremap <M-Up> k
:noremap <M-Down> j

Here is the link to the particular mail in the archive:

http://groups.yahoo.com/group/vim/message/58794

VimTip 920: Quick generic option toggling
http://vim.sourceforge.net/tip_view.php?tip_id=

A fairly well-known mapping to toggle boolean options is:

map <F2> :set wrap!<CR>

Nicer, more elaborate versions of this idea exist, such as:

nnoremap <F2> :set wrap! \| set wrap?<CR>
inoremap <F2> <C-O>:set wrap! \| set wrap?<CR>

which displays the current value of the option after toggling it, and
works both in normal and insert mode.

However, that definition quickly clutters up your .vimrc, and is a pain
to edit due to the redundant occurances of the toggle key and option.
Wrapping the definition in a temporary function/command combination
solves the problem, though, making toggle definition a one-line
operation again:

" Map key to toggle opt
function MapToggle(key, opt)
  let cmd = ':set '.a:opt.'! \| set '.a:opt."?\<CR>"
  exec 'nnoremap '.a:key.' '.cmd
  exec 'inoremap '.a:key." \<C-O>".cmd
endfunction
command -nargs=+ MapToggle  call MapToggle(<f-args>)

" Display-altering option toggles
MapToggle <F1> hlsearch
MapToggle <F2> wrap
MapToggle <F3> list

" Behavior-altering option toggles
MapToggle <F10> scrollbind
MapToggle <F11> ignorecase
MapToggle <F12> paste
set pastetoggle=<F12>

VimTip 922: launch lynx to get a info from php.net for the word under your cursor
http://vim.sourceforge.net/tip_view.php?tip_id=

This isn't one of those "Gee, I always wondered how to do that!" tips, but it may be something that you would have never thought to do.  I use CTRL+L to search php.net for the term under my cursor.  The key mapping goes like this:

nmap ^L :!lynx -accept_all_cookies http://us2.php.net/^R^W\#function.^R^W<CR>

(Remember to use CTRL+V,CTRL+L to get the ^L and CTRL+V,CTRL+R to get the ^R, etc.)

My workflow causes me to do most of my PHP development directly on a Unix server over an SSH connection.  So, instead of switching from my terminal app to my web browser to search php.net, I like having a single keystroke to do it.

The ^R^W inserts the word under the cursor into the command area.  You can use this is many other handy key mappings.  The \#func... is to tell lynx to jump to an anchor tag, since all php.net manual pages have an anchor tag named in the form function.{functionName}  (and the # is escaped as \# since Vim what to do a path substitution.)  I should also note that the anchor part will only work if what you search for a) is a function and not a language construct, or a reference term b) does not contain an underscore.  It will still load the page, but you will have to scroll past all of the navigation manually.

VimTip 923: Sort lines by word# count
http://vim.sourceforge.net/tip_view.php?tip_id=

Based on the script by Robert Webb found in the Vim help file (eval.txt) ":help eval-examples" to sort lines, I made some modifications to enable Sort() to sort lines according to word number count.

I defined words to be clusters of non-whitespace characters separated by whitespace characters. For example, the line "while (k == 0)" has 4 words.

To use, get into visual-block mode (hit Ctrl-V from normal mode) and highlight the lines you wish to sort. Then hit <F3> or any other key mapping of your choice. You will be prompted to enter a number, which is the word number count from the left.

Example:
ID           Name                 PIN     E-mail
172987129    Jon Doe              5787    jondoe@spamme.com
943973494    Don Juan Marco Jr    2001    don@nonexistent.net
439872390    Bob Peter Tomalin    7786    tomalin@nospam.edu

To sort by ID, enter "1" for word number. You can also enter a word number count from right by entering a negative number. Since the Name column has a variable number of words for each line, in order to sort by PIN, enter "-2" to indicate the second word from the right.

After that, you will be prompted to enter the sort order. For example, enter "r" to sort in reverse order.

====================
"paste in vimrc file - tested with GVim 6.3

"** use visual block <Ctrl-V> to select lines to sort and hit <F3> **
vmap <F3> :call Sort(Prompt("0","1"),Prompt("1","f"),"Strcmp")<CR>

"sort lines function
function Sort(wnum, order, cmp) range
  call SortR(a:firstline, a:lastline, a:wnum, a:order, a:cmp)
  normal gv
endfunction

"sort lines recursively
function SortR(start, end, wnum, order, cmp)
  if a:start >= a:end
    return
  endif

  let partition = a:start - 1
  let middle = partition
  let partstr2 = Words2(getline((a:start + a:end) / 2), a:wnum)
  let i = a:start

  while i <= a:end
    let str = getline(i)
    let partstr = Words2(str, a:wnum)
    if a:order == "r"
      execute "let result = ".a:cmp."(partstr2, partstr)"
    else
      execute "let result = ".a:cmp."(partstr, partstr2)"
    endif

    if result <= 0
      "swap i before partition
      let partition = partition + 1

      if result == 0
        let middle = partition
      endif

      if i != partition
        let str2 = getline(partition)
        call setline(i, str2)
        call setline(partition, str)
      endif
    endif

    let i = i + 1
  endwhile

  "make sure middle element at end of partition
  if middle != partition
    let str = getline(middle)
    let str2 = getline(partition)
    call setline(middle, str2)
    call setline(partition, str)
  endif

  call SortR(a:start, partition - 1, a:wnum, a:order, a:cmp)
  call SortR(partition + 1, a:end, a:wnum, a:order, a:cmp)
endfunction

"determine compare strings
function Words2(line, wnum)
  if a:wnum > 1
    return strpart(a:line, matchend(a:line, "\\s*\\(\\S*\\s*\\)\\{".(a:wnum - 1)."}"))
  elseif a:wnum == 1
    return strpart(a:line, matchend(a:line, "\\s*"))
  elseif a:wnum < 0
    return matchstr(a:line, "\\(\\S*\\s*\\)\\{".(-a:wnum)."}$")
  else
    return a:line
  endif
endfunction

"compare two strings
function Strcmp(str1, str2)
  if a:str1 < a:str2
    return -1
  elseif a:str1 > a:str2
    return 1
  else
    return 0
  endif
endfunction

"prompt user for settings
function Prompt(str, ...)
  let default = a:0 ? a:1 : ""
  if a:str == "0"
    let str = "Sort by which word [(0)whole line (<0)count from right]? "
  elseif a:str == "1"
    let str = "Order [(f)orward (r)everse]? "
  endif

  execute "let ret = input(\"".str."\", \"".default."\")"

  return ret
endfunction
====================

Other references: vimtip#588 vimtip#800

VimTip 924: alt up/down mappings like in eclipse.
http://vim.sourceforge.net/tip_view.php?tip_id=

Move the line your cursor is on up/down with the cursor as in eclipse like so:

map <M-Down> ddp
map <M-Up> ddkP
imap <M-Down> <Esc>ddpi
imap <M-Up> <Esc>ddkPi

These still need a little work but this is the basics...

VimTip 925: Not So Quick generic option toggling
http://vim.sourceforge.net/tip_view.php?tip_id=

This allows "toggling" of more complex operations, like switching off "diffthis".  It also reduces the number of key mappings used overall by placing the operations under a key activated command window menu.  It is quick to use (mapped key + one more keystroke), even if it isn't as quick to write.  I stuck it in my plugin directory as "ToggleOptions.vim".  Maybe it should be submitted as a script, but it's kinda small, and I was inspired by

Tip #920: Quick generic option toggling
author:   Piet Delport <pjd@satori.za.net>

so here it is:

" - ToggleOptions.vim
"
" vim6:fdm=marker:foldenable:ts=4:sw=4
"
" Author:		Eric Arnold ( eric_p_arnold in_the_vicinity_of yahoo.com )
" Created:		Mon May 09, 05/09/2005 05:04:17

map <leader>o :ToggleOptions<CR>
command! ToggleOptions call ToggleOptionsMenu()

function! ToggleOptionsMenu()

	let l:char = s:Char_menu( "{w}rap, {W}rapscan, {l}ist, {b}inary, {m}odifiable, {d}iff, {v}irtualedit, uhe{x}" )

	if l:char ==# 'w'
		set wrap!
		set wrap?
	elseif l:char ==# 'W'
		set wrapscan!
		set wrapscan?
	elseif l:char ==# 'b'
		set binary!
		set binary?
	elseif l:char ==# 'l'
		set list!
		set list?
	elseif l:char ==# 'm'
		if &modifiable && !&readonly
			set nomodifiable
			set readonly
		else
			set modifiable
			set noreadonly
		endif
		set readonly?
		set modifiable?
	elseif l:char ==# 'v'
		if &virtualedit == 'all'
			set virtualedit=block
		else
			set virtualedit=all
		endif
		set virtualedit?
	elseif l:char ==# 'd'
		if &diff
			set nodiff foldcolumn=0
		else
			diffthis
		endif
		set diff?
	elseif l:char ==# 'x'
		if &display =~ 'uhex'
			set display-=uhex
		else
			set display+=uhex
		endif
		set display?
	endif

endfunction

function! s:Char_menu( stuff, ... )
	let l:stuff = a:stuff
	let l:match_col = 0
	let l:hi = "None"

	echohl Question

	while l:match_col >= 0
		let l:match_col = match( l:stuff, '^\(\w\+\|\W\+\|{\|}\)' )

		let l:tok = strpart( l:stuff, 0, l:match_col + 1 )
		let l:stuff = strpart( l:stuff, l:match_col + 1 )

		if l:tok == '{'
			echohl warningmsg " Error
			let l:hi = "standout"
		elseif l:tok == '}'
			echohl Directory " Statusline " Question
			let l:hi = "standout"
		elseif l:tok != ''
			if l:tok =~ '\w\+' && l:hi == "whitespace"
				echohl Directory " Statusline " Question
				let l:hi = "text"
			elseif l:tok =~ '[ ]\+'
				let l:hi = "whitespace"
				echohl None
			endif
			echon l:tok
		endif
	endwhile

	echohl None
	echon "\r"
	return nr2char( getchar() )

endfunction

VimTip 926: QT Help from Vim
http://vim.sourceforge.net/tip_view.php?tip_id=

QT GUI Toolkit comes with extensive documentation in html format;
searching in help that means constant copy/paste from vim
into my Opera web browser.

This tip will allow you to press <C-t> in vim on any QT Class or Function
and have the relevant help open up in Opera in the background.

1. build tags for all the QT classes and functions
   using the perl script given below.

2. Then in ~/_vimrc put these lines:

   set tags^=$QTDIR/tags,$QTDIR/doc/html/tags
   au  FileType  html      :silent exe ":!c:/opera/6*/opera.exe ".expand("%:p")

3. Press <Control-T> on QWidget in any source file
   The file QTDIR/doc/html/qfile.html will open up in
   Opera web browser in the background.

Notes:
   Other web browsers may work too.

# WHAT: make tags for qt documentation.
# HOW: cd $QTDIR/doc/html; perl $0 index > tags
# AUTHOR: Mohsin Ahmed http://www.cs.albany.edu/~mosh
my(@mytaglist,%seen);
while( <> ){
    if( m/^"(\S+)"\s+(\S+\.html)(.+)/ ){
        my($class,$file,$tag)=($1,$2,$3);
        push @mytaglist,"$class\t$file\t/$class/\n";
        if( $class =~ m/(\S+)::(\S+)/ ){
            my($class,$func) = ($1,$2);
            push @mytaglist,"$func\t$file\t/$class::$func/\n";
            if( ! $seen{$class}++ ){
                push @mytaglist,"$class\t$file\t/$class/\n";
            }
        }
    }
}
print sort @mytaglist;

VimTip 927: A better autowrite?
http://vim.sourceforge.net/tip_view.php?tip_id=

I'm curious whether this is a good idea.  I saw that an "autowrite" was in the "todo.txt" helpful, but wasn't implemented yet, so I did this.

map <leader>aw :call Myautowrite()<CR>

function! Myautowrite()
    if ( !exists( "g:myautowrite" ) )
        let g:myautowrite = 0
    endif

    if ( g:myautowrite == 0 )
        let g:myautowrite = 1

        exec "aug myautowrite"
        exec "au BufLeave * silent! update"
        exec "au FocusLost * silent! update"
        exec "aug end"
        exec "echo 'Auto-update-all is ON'"
    else
        let g:myautowrite = 0

        exec "aug myautowrite"
        exec "au!"
        exec "aug end"
        exec "echo 'Auto-update-all is OFF'"
    endif

endfunction

VimTip 928: q: and q/
http://vim.sourceforge.net/tip_view.php?tip_id=

When you hit : to enter a command or / to start a search, you often want to edit
a previous command or search. This can be done with the arrow keys and
ctrl chords (see :help :)

A far superior solution however, is to use q/ and q: which gives you all
of vims normal editing power to edit the command or search history.

You may even want to experiment with mappings like
:nmap : q:i
:nmap / q/i
:nmap ? q?i

VimTip 929: Finding your way around in an installshiled project XML file
http://vim.sourceforge.net/tip_view.php?tip_id=

We still use InstallShield MP 5.x and I find the lack of search functionality in the GUI very hindering (I don't if this is still the case with the newer 10.x and 11.x releases), so I use Vim to do all my searching and find the beans etc. and go back to the GUI to locate them. This by itself provides a huge benefit, but it is often not sufficient in a huge project, because you still don't know how to locate it in the GUI.

My solution for sometime was to set 'foldmethod' to "indent" and after searching for the bean, carefully open the folds up one by one and locate the parents (this works because the beans are indented nicely by their level in the bean tree). Once you reach to the top most bean (under the root), you get an idea how to locate it, which solved the problem, but I still felt that it is a bit tedious to do this (especially because of the several folds you need to open up keeping track of the cursor position).

My new solution to this problem is still using folds, but in a different way (You need Vim 6.3). The displayName property of the beans is what we are interested in to locate the bean, so I create an outline of the entire bean structure using the following command (you need vimscript #158, and the vimscript #171 and vimscript #197 that this depends on):

             FoldMatching "displayName" -1

This creates folds just the way I want, but provides no way to navigate the bean structure, so here is a function to take advantage of the fact that the XML is nicely indented, and find the parent bean:

" This function is useful in an InstallShield XML project file to find the
"   parent bean of the current bean. Call this function after creating folds
"   using the following command:
"             FoldMatching "displayName" -1
" This assumes that the beans are indented based on their depth in the bean
"   tree (which is the case for at least InstallShield MP 5.x)
function! FoldMoveToParentNode()
  normal! zc
  let curNodeIndent = indent(foldclosed('.'))
  let nodeIndent = curNodeIndent
  let curLine = line('.')
  let line = -1
  while nodeIndent >= curNodeIndent
    " Move to the upper fold.
    normal! zkzc
    let line = line('.')
    if line == curLine " No more folds
      break
    endif
    let nodeIndent = indent(foldclosed('.'))
  endwhile
endfunction

Put the above function in your vimrc along with installing the required plugins that I mentioned above, and optionally create a mapping:

nnoremap \fdp :call FoldMoveToParentNode()<CR>

Here are the concise steps to locate beans:

- Execute the below command:
:FoldMatching "displayName" -1
- Search for the bean name or any others that you are interested in (like a filename or command being executed). This will position the cursor on the fold that the matching line is part of (vim might automatically open the fold, depending on your 'foldopen' setting):
/\.ear
- Now execute the above function (or the map) multiple times until you reach the parent that is familiar to you:
:call FoldMoveToParentNode()

I find this very handy to quickly navigate in an installshield MP project (especially when it is unfamiliar), and I hope that others also find it useful.

VimTip 930: highlighted text -> HTML
http://vim.sourceforge.net/tip_view.php?tip_id=

I'm sure this has been covered somewhere, but it took me some time to find it.
You can convert highlighted text to HTML code in Vim.

:TOhtml

this works with a complete file or  segments of code (selected in visual mode).
GUI users can also use the drop-down menu

Syntax -> Convert To HTML

This is really nice when you are writing webpages with code snippets in it:
    - set the highlighting of the file to your programming language of choice
    - enter the code
    - highlight the code
    - type :TOhtml
    - copy and paste the HTML code from the opening window (part)

VimTip 931: STL (Standard Template Library/C++) help via tags.
http://vim.sourceforge.net/tip_view.php?tip_id=

This tip builds on tip #926 (tagging QT help). With a different
perl parser given below for tagging STL documentation.

In vim, you can now do
    :ta vector
or press Control-T on vector
to open the stl/vector.html in your browser.
or do :ts /push   .. to find all tags names ~ push.

How:
 wget http://www.sgi.com/tech/stl/STL_doc.zip
 unzip stl_doc.zip
 cd stl_doc
 perl stl_tags.pl > tags  # script given below.

In your _vimrc put these two lines:

au  BufReadPost */stl_doc/*.html  :silent exe ":!c:/opera/6*/opera.exe ".expand("%:p") | bd
set tags+=your_stl_dir/tags

I use opera6,7,8, but all browsers should work. The html files
are opened in tabbed windows in opera, so no clutter on desktop.

Feel free to hack the script, you can decide what tags you want
from STL, here is an example of the tags you should get

pos_type	char_traits.html	133;" STL/Member
power	power.html	/<Title>/;" STL/Title
prev_permutation	prev_permutation.html	/<Title>/;" STL/Title
previous	Slist.html	477;" STL/Member
priority_queue	priority_queue.html	/<Title>/;" STL/Title
priority_queue	priority_queue.html	194;" STL/Member
priority_queue::empty	priority_queue.html	290;" STL/Class::Member
priority_queue::pop	priority_queue.html	334;" STL/Class::Member

Mohsin.
-----------------

# What: tag stl documentation for use from gvim.
# How: wget http://www.sgi.com/tech/stl/STL_doc.zip; unzip stl_doc.zip
#      cd stl_doc; perl stl_tags.pl > tags
# In ~/.vimrc put this:
#   :set tags^=stl_doc/tags
#   au BufReadPost */stl/*.html  :silent exe ":!c:/ opera/6*/opera.exe ".expand("%:p") | bd
# Usage: vim file.cpp
#        :ta vector -> Opera will display stl_doc/vector.html
# AUTHOR: Mohsin Ahmed, http://www.cs.albany.edu/~mosh

# make tags for html files listed stl_index.html
open(INDEX,"stl_index.html") or die "no stl_index.html?";
while(<INDEX>){ $files{$1}++ if m/href="(\w+?.html)"/; } close INDEX;

foreach $htmlf (keys %files){
    open(FILE,"$htmlf") or die "cannot read $htmlf";
    $lineno = $member=0;
    while(<FILE>){ $lineno++;
        s,&gt;,>,g; s,&lt;,<,g; s,&amp;,&,g; # html quadgraphs
        if( m,^<Title>([\w\s]+), ){ $tag = $1; # tag single word titles
            next if $tag_seen{$tag}++ || $tag =~ m/\s/;
            push @mytaglist,"$tag\t$htmlf\t/<Title>/;\" STL/Title\n";
            next;
        }
        $members++ if m/<h3>Members/i; # collect members in /Members/..eof()
        $members=0 if m,</table>,i;
        if( $members && m,^<tt>(.+?)</tt>, ){
                $tag=$1;
                $tag = $1 if $tag =~ m/\b(\S+)\(/;  # purge proto
                next if $tag =~ /href=/;  # skip urls.
                $tag =~ s,^operator(\S+),$1,; # purge sugar
                my $file = $htmlf; $file =~ s,\..*,,;
                push @mytaglist,"$tag\t$htmlf\t$lineno;\" STL/Member\n"  # member
                        unless $seen{"$tag.$file"}++;
                $tag = "$file\::$tag";   # class::member
                push @mytaglist,"$tag\t$htmlf\t$lineno;\" STL/Class::Member\n"
                    unless $tag_seen{$tag}++;


        }
    }
    close FILE;
}
print sort @mytaglist;

VimTip 932: Autojump to ( when entering ), then jump back. Handy for Lisp.
http://vim.sourceforge.net/tip_view.php?tip_id=

Entering the following mapping will make writing lisp code (as well as other code) much easier:

imap ) )<esc>%:300sleep m<enter>%a

Whenever you type in a ) in insert mode, the cursor will jump to the corresponding (, then jump back 300 milliseconds later.

VimTip 933: search the web for  text selected in vim.
http://vim.sourceforge.net/tip_view.php?tip_id=

This tip allows you to search the web for a selected phrase from vim.
This is especially useful to lookup spellings of proper nouns, phrases,
function prototypes and man pages on the web, while working in vim.

Usage:
  0. Add the vmap ?? line given below to your ~/_vimrc
  1. In Vim press v to begin selection,
  2. move cursor to end of selection (region will be highlighted).
  3. Press ??
  4. The search results will appear in your web browser.

:vmap ??  <ESC>:silent exec
    \ ":!c:/opera/6*/opera.exe \\\"http://www.google.com/search?q=".substitute(@*,"\\W\\+\\\\|\\<\\w\\>"," ","g")
    \ . "\\\" "<CR><CR>

Notes and explanation:

The vmap takes the visually selected region, and
removes all non word characters and single characters in region, and
launches the query on the phrase.

Customizations:

You should replace c:/opera/6*/opera.exe by path to your browser,
  or you can get the opera from http://www.opera.com for windows/linux,
  opera is super fast and safe in textmode with images and java turned off.

You can replace the vmap selection by <cword> above
  to query for <word under cursor>.

- MA
http://www.cs.albany.edu/~mosh

VimTip 934: Vim-sessions under Windows
http://vim.sourceforge.net/tip_view.php?tip_id=

If you use vim-sessions, and if you run Vim under Windows, try this tip.  Place following lines in <somefile>.reg and execute it.  This adds files associations for extensions .vimsession and .vim, so that clicking on <bla-bla>.vimsession Windows will run "gvim -S <bla-bla>.vimsession", and something appropriate will be done when clicking on <bla-bla>.vim (read it yourself below).  Of course, you will need to change full path to your GVim installed.

REGEDIT4

[HKEY_CLASSES_ROOT\.vimsession]
@="vimsession_auto_file"

[HKEY_CLASSES_ROOT\vimsession_auto_file]
@="GVim saved session"

[HKEY_CLASSES_ROOT\vimsession_auto_file\shell]

[HKEY_CLASSES_ROOT\vimsession_auto_file\shell\edit]

[HKEY_CLASSES_ROOT\vimsession_auto_file\shell\edit\command]
@="D:\\prgfiles\\vim\\vim63\\gvim.exe -S \"%1\""

[HKEY_CLASSES_ROOT\.vim]
@="vim_auto_file"

[HKEY_CLASSES_ROOT\vim_auto_file]
@="GVim script"

[HKEY_CLASSES_ROOT\vim_auto_file\shell]

[HKEY_CLASSES_ROOT\vim_auto_file\shell\edit]

[HKEY_CLASSES_ROOT\vim_auto_file\shell\edit\command]
@="D:\\prgfiles\\vim\\vim63\\gvim.exe -c \"try|source %1|q|endtry\""

VimTip 935: Highlight space errors
http://vim.sourceforge.net/tip_view.php?tip_id=

To highlight spaces at the end of a line and spaces in front of tabs you can simply add the following command to your vimrc:
let <language>_space_errors=1
supported languages are:
ada, c, chill, csc, icon, java, lpc, mel, nqc, nroff, ora, plm, plsql and python. So if you want to highlight space errors in lpc-files you have to write:
let lpc_space_errors=1

If you don't want to see the errors at the end of the line set:
let <language>_no_trail_space_error=1
and if you only use spaces to indent and don't want to see the space errors in front of tabs set:
let <language>_no_tab_space_error=1

VimTip 936: Quick insert character at end-of-line
http://vim.sourceforge.net/tip_view.php?tip_id=

Here's a quickie. This inserts the next character typed at the end of a line and operation continues where the cursor was. Useful for adding trailing '"', ';' and ')' without moving around too much.

To use, hit <F2> in insert mode and type the end character.

==========
"place in vimrc
imap <silent><F2> <Esc>v`^me<Esc>gi<C-o>:call Ender()<CR>

function Ender()
  let endchar = nr2char(getchar())
  execute "normal \<End>a".endchar
  normal `e
endfunction
==========

VimTip 937: tip on looking up vim help topics
http://vim.sourceforge.net/tip_view.php?tip_id=

In addition to the existing techniques for searching vim help pages, such as the built-in :helpgrep and other grep techniques such as using external grep/id-utils, here is another technique that you can use to quickly lookup help topics.

You are probably already aware that Vim creates tags to lookup help topics (using :helptags command), and commands such as :tselect (or :ts in short) do work in the help windows (it is automatically scoped to only the tags files in your runtime doc directories). This other than providing a way to use familiar tag commands to lookup help topics (such as tag completion and using regex to lookup), allows us to take advantage of any tools that enhance the Vim built-in tag commands. I would like to show here one such tool that you can use.

This requires the tagselect.vim plugin (vimscript #1282), and its dependent plugins (vimscript #171 and vimscript #197). The plugin allows you execute a :tselect command and view the results in a new window. You can then use Vim's navigation (such as search) to find the tag you want and press enter to jump to it. When used inside a help window, this naturally works on the help topics too. E.g., say you want to view all the topics that have "shell" in its name, one way to do this is use tag completion

:h shell<Tab>

and go one by one. But this is not easy as often you find tens, if not hundreds of matches for a keyword, so going through the list and using :tnext and :tprevious commands to navigate to other matching results is painful. But if you use the :Tselect command provided by the plugin, it becomes relatively simpler.

:h
:Tselect /.*shell.*

The above gives you the full matching results for all the topics containing "shell" in their names. You can try other regular expressions (see :help tag-regexp), but the above is probably the most useful, so you can create a command for it:

:command! -nargs=+ -complete=tag Helpt :Tselect /.*<args>.*

You can put the above command definition in your vimrc. You can then say:

:Helpt tag

The best part of this is that you will discover topics that you overlooked several times, including any help topics for plugins.

VimTip 938: Create PayPal "Buy Now" Buttons from a CSV Buffer
http://vim.sourceforge.net/tip_view.php?tip_id=

I started using the PayPal Button Factory the other day, but the button creation process is a bit too slow for me - so I thought I would semi-automate it in VIM ;-)

If you have a list in your buffer such as :

Product 1,PD001,30
Product 2,PD002,130
Product 3,PD003,1130
Product 4,PD004,230

you can use the following command to turn the list into unencrypted PayPal Buy Now buttons :

:%s/\(.*\)\(,\)\(.*\)\(,\)\(.*\)/<form action='https:\/\/www.paypal.com\/cgi-bin\/webscr' method='post'> <input type='hidden' name='cmd' value='_xclick'> <input type='hidden' name='business' value='my_user@my_company.com'> <input type='hidden' name='item_name' value='\1'> <input type='hidden' name='item_number' value='\3'> <input type='hidden' name='amount' value='\5.00'> <input type='hidden' name='no_note' value='1'> <input type='hidden' name='currency_code' value='GBP'> <input type='image' src='https:\/\/www.paypal.com\/en_US\/i\/btn\/x-click-but01.gif' border='0' name='submit' alt='Make payments with PayPal - it's fast, free and secure!'> <\/form>/

which generates the following HTML that you can then insert into your web page:

<form action='https://www.paypal.com/cgi-bin/webscr' method='post'> <input type='hidden' name='cmd' value='_xclick'> <input type='hidden' name='business' value='my_user@my_company.com'> <input type='hidden' name='item_name' value='Product 1'> <input  type='hidden' name='item_number' value='PD001'> <input type='hidden' name='amount' value='30.00'> <input type='hidden' name='no_note' value='1'> <input type='hidden' name='currency_code' value='GBP'> <input type='image' src='https://www.paypal.com/en_US/i/btn/x-click-but01.gif' border='0' name='submit' alt='Make payments with PayPal - it's fast, free and secure!'> </form>

Obviously you are not going to type that onto the command line every time, so you could set this up as a VIM menu button as below :

:amenu PayPal.BuyNow\ from\ CSV :<CR>
\:%s/\(.*\)\(,\)\(.*\)\(,\)\(.*\)/<form action='https:\/\/www.paypal.com\/cgi-bin\/webscr' method='post'> <input type='hidden' name='cmd' value='_xclick'> <input type='hidden' name='business' value='my_user@my_company.com'> <input type='hidden' name='item_name' value='\1'> <input type='hidden' name='item_number' value='\3'> <input type='hidden' name='amount' value='\5.00'> <input type='hidden' name='no_note' value='1'> <input type='hidden' name='currency_code' value='GBP'> <input type='image' src='https:\/\/www.paypal.com\/en_US\/i\/btn\/x-click-but01.gif' border='0' name='submit' alt='Make payments with PayPal - it's fast, free and secure!'> <\/form>/<CR><CR>

Of course you should make sure to change values in the code to match what you want - Probably, the best idea is to use PayPal to get the code for your first button, which you can then use as a template for the rest of them.

VimTip 939: Single config file for Vim on Windows with Cygwin installed.
http://vim.sourceforge.net/tip_view.php?tip_id=

Not really an earth shattering tip but I found it handy so I thought I'd share. I got really bored of editting multiple vimrc files when I wanted to change mine. So, after installing cygwin under Windows I added an environment variable which set HOME to be c:\cygwin\home\username. Vim/GVim in windows reads that variable if it is set and notes that the config file to read is the one I have in my cygwin directory. Also, because Vim/GVim under Windows understands that the config files could be called either .vimrc or _vimrc it doesn't require any other change. Now when either Vim in cygwin or Vim/GVim in Windows loads, they both use the same config files. This assumes that your config files can work under either environment as mine do.

VimTip 940: Easily add folds in code
http://vim.sourceforge.net/tip_view.php?tip_id=

This is a simple keymapping to make adding folds to source code simpler.  I use foldmethod=marker, but that shouldn't be necesary for this tip.  It will fold the current block (block being anything delimted with '{' and '}') no matter where you are in that block.

Add this to your .vimrc:

nmap <silent> <leader><leader> [{V%zf

Enjoy!

VimTip 941: Adding MPI and PVM syntax highlighting
http://vim.sourceforge.net/tip_view.php?tip_id=

    The MPI standard and the PVM library are commonly used to parallelize codes to run them across multiprocessor systems.  The lines below can be added to the c.vim syntax file to highlight all MPI and PVM function calls, as well as the MPI data types.  The Fortran syntax is the same except that PVM uses the pvmf prefix instead of pvm_.  You will also need to add a line to your favorite colorization file to  highlight the new Communicator group.  I use a Yellow background which shows up well on both light and dark backgrounds to really illustrate where the communications calls are in a program.  If the powers that be ever wish to include these capabilities in the official VIM release, I'd be happy to add OpenMP functions as well.

                        Dave Turner

syn match	cCommunicator	"MPI_[A-Z][A-Z_a-z2 ]*("me=e-1
syn match	cCommunicator	"MPIO_[A-Z][A-Z_a-z ]*("me=e-1
syn match	cCommunicator	"pvm_[a-z ]*("me=e-1
syn match	cCommunicator	"MP_[A-Z_a-z ]*("me=e-1

syn keyword     cType           MPI_Group MPI_Status MPI_Request MPI_Win MPI_Aint
syn keyword    cType            MPI_Info MPI_Op MPI_Datatype MPI_Comm

  HiLink cCommunicator		Communicator

Example addition to the colorization file for dark backgrounds:

    hi Communicator      guibg=yellow2 guifg=black gui=bold ctermbg=yellow ctermfg=black

Example addition to the colorization file for light backgrounds:

    hi Communicator      guibg=yellow2 guifg=white gui=bold ctermbg=yellow ctermfg=white

VimTip 942: Simple VIM Reference
http://vim.sourceforge.net/tip_view.php?tip_id=

A simple VIM reference (in pdf, and good for beginners) can be found at

http://simpletutorials.com/vim/index.php

VimTip 943: send buffer to interpreter in a new xterm
http://vim.sourceforge.net/tip_view.php?tip_id=

Without saving the current buffer you want to send its contents to an interpreter (python, scheme, whatever), and you want that interpreter to run in a freshly spawned xterm.   A new xterm window is useful because running the shell within Vim does not allow simultaneously inspection of program output and the code buffer, and Vim's shell is weak in several respects.

Put this script in your path and make it executable:
------------------------------------------------
#!/bin/sh
# This is for use from .vimrc files.  It sends vim buffers to the specified
# interpreter.

if [ "$#" -lt 1 ]
then
    echo "ERROR: not enough args."
    echo "VIMRC USAGE: viminterpreter <interpretercommand>"
    exit 1
fi

TMP=`mktemp`
VM="$1" #command to run on the current buffer

cp /dev/stdin $TMP
xterm -e "\"$VM\" $TMP && rm $TMP && read"
------------------------------------------------

Add the following to .vimrc:
------------------------------------------------
map ,p :w !viminterpreter python <CR>
map ,g :w !viminterpreter gosh <CR>
------------------------------------------------

Now you can edit scheme code in an unsaved vim buffer and hit ",g" to see what it does.  Or ",p" for python code.

Is there a simpler way to do this?  I feel it SHOULD be possible to just add this .vimrc:
map ,p :!xterm -e "python \"<the_current_buffer>\""

VimTip 944: send buffer to interpreter in a new xterm
http://vim.sourceforge.net/tip_view.php?tip_id=

Without saving the current buffer you want to send its contents to an interpreter (python, scheme, whatever), and you want that interpreter to run in a freshly spawned xterm.   A new xterm window is useful because running the shell within Vim does not allow simultaneously inspection of program output and the code buffer, and Vim's shell is weak in several respects.

Put this script in your path and make it executable:
------------------------------------------------
#!/bin/sh
# This is for use from .vimrc files.  It sends vim buffers to the specified
# interpreter.

if [ "$#" -lt 1 ]
then
    echo "ERROR: not enough args."
    echo "VIMRC USAGE: viminterpreter <interpretercommand>"
    exit 1
fi

TMP=`mktemp`
VM="$1" #command to run on the current buffer

cp /dev/stdin $TMP
xterm -e "\"$VM\" $TMP && rm $TMP && read"
------------------------------------------------

Add the following to .vimrc:
------------------------------------------------
map ,p :w !viminterpreter python <CR>
map ,g :w !viminterpreter gosh <CR>
------------------------------------------------

Now you can edit scheme code in an unsaved vim buffer and hit ",g" to see what it does.  Or ",p" for python code.

Is there a simpler way to do this?  I feel it SHOULD be possible to just add this .vimrc:
map ,p :!xterm -e "python \"<the_current_buffer>\""

VimTip 945: range of current c/c++/java function
http://vim.sourceforge.net/tip_view.php?tip_id=

It is often useful to restrict the range of commands like s or g to the function one is editing currently. For C/C++ and java

:cmap ;tf ?^{??(?,/^}/

maps the keystrokes ;tf (_t_his _f_unction) to the range of the function in which the cursor is currently located. It works by searching backwards for a { occurring in the first column, and then for a ( to find the start of the function. A } in the first column ends the function body.

For example, you want to change the name of a function argument in the current function from i to ii:

int foo(int i,
            int j)
{
    // ...
    i++;
    return i;
}

Type <esc>:;tf followed by the subsitution command s/\<i\>/ii/g. The command line now reads:

:?^{??($,/^}/s/\<i\>/ii/g

Press <cr> to execute and observe the change:

int foo(int ii,
            int j)
{
    // ...
    ii++;
    return ii;
}

The range can be used with other commands too.

This tip assumes that:

- your source code is indented, so that curly braces on the first column always open or close a function body

- a function name is  followed by a (. This is true in c, mostly true in c++ and java, and true to a limited extend in perl.

This tip does not work for constructor definitions in c++ and java, since they can contain many parentheses:

Foo(int bar, int baz):
    mBar(bar),
    mBaz(baz)
{}

VimTip 946: VisVim for Visual Sutdio .NET
http://vim.sourceforge.net/tip_view.php?tip_id=

The VisVim which comes with Vim 6.3 does not work with Visual Studio .NET. Here is an implementation of VisVim for VS.NET :

Setup:
http://www.kaoriya.net/testdir/VisVimNET/VisVimNETSetup-20040706.msi

Source Code:
http://www.kaoriya.net/testdir/VisVimNET/VisVimNET-20040706.tar.bz2

Looks like this implementation is completely different from the orignal VisVim. It will be great if the original VisVim is modified or this is included in the next Vim release. If you know any other VisVim implementation which works for VS.NET, please post the link here.

VimTip 947: Comprehensive Vim Quick Reference Card
http://vim.sourceforge.net/tip_view.php?tip_id=

Comprehensive Vim quick reference card in several languages in .pdf, .tex and .dvi forms released under GNU general public license.
"http://tnerual.eriogerg.free.fr/vim.html"

VimTip 948: Correct Format-flowed Email function
http://vim.sourceforge.net/tip_view.php?tip_id=

I frequently get email from people who do not use format-flowed email properly. I prefer to send out "correct" email, including the stuff I'm quoting, and vim helps me do that. I added this function to my ~/.vimrc, and now I use it when editing mail by simply typing:

:call FixFlowed()

(That's easier to type, because I really type :call F<tab> )

Here's the function (suggestions for improvement always welcome):

function! Fixflowed()
   " save position
   let l = line(".")
   let c = col(".")
   normal G$
   " add spaces to the end of every line
   while search('\([^]> :]\)\n\(>[> ]*[^> ]\)','w') > 0
       s/\([^]> :]\)\n\(>[> ]*[^> ]\)/\1 \r\2/g
   endwhile
   " now, fix the wockas spacing from the text
   while (search('^\([> ]*>\)\([^> ]\)','w') > 0
                s/^\([> ]*>\)\([^> ]\)/\1 \2/
        endwhile
   " now, compress the wockas
   while search('^\(>>*\) \(>>*\( [^>]\)*\)', 'w') > 0
                s/^\(>>*\) \(>>*\( [^>]\)*\)/\1\2/
        endwhile
   " restore the original location, such as it is
   execute l . " normal " . c . "|"
endfunction

It's a little sensitive because it blows away ascii art... and it also doesn't automatically reflow paragraphs (I have no idea how to do that properly). Hope it helps someone.

VimTip 949: Integrate Pylint and Pychecker support into Vim Cwindows.
http://vim.sourceforge.net/tip_view.php?tip_id=

Simple function to add pylint and pychecker support to Vim.

      function <SID>PythonGrep(tool)
        set lazyredraw
        " Close any existing cwindows.
        cclose
        let l:grepformat_save = &grepformat
        let l:grepprogram_save = &grepprg
        set grepformat&vim
        set grepformat&vim
        let &grepformat = '%f:%l:%m'
        if a:tool == "pylint"
            let &grepprg = 'pylint --parseable=y --reports=n'
        elseif a:tool == "pychecker"
            let &grepprg = 'pychecker --quiet -q'
        else
            echohl WarningMsg
            echo "PythonGrep Error: Unknown Tool"
            echohl none
        endif
        if &readonly == 0 | update | endif
        silent! grep! %
        let &grepformat = l:grepformat_save
        let &grepprg = l:grepprogram_save
        let l:mod_total = 0
        let l:win_count = 1
        " Determine correct window height
        windo let l:win_count =  l:win_count + 1
        if l:win_count <= 2 | let l:win_count = 4 | endif
        windo let l:mod_total = l:mod_total + winheight(0)/l:win_count |
        \ execute 'resize +'.l:mod_total
        " Open cwindow
        execute 'belowright copen '.l:mod_total
        nnoremap <buffer> <silent> c :cclose<CR>
        set nolazyredraw
        redraw!
    endfunction

    if ( !hasmapto('<SID>PythonGrep(pylint)') && (maparg('<F3>') == '') )
        map  <F3> :call <SID>PythonGrep('pylint')<CR>
        map! <F3> :call <SID>PythonGrep('pylint')<CR>
    else
        if ( !has("gui_running") || has("win32") )
            echo "Python Pylint Error: No Key mapped.\n".
            \  "<F3> is taken and a replacement was not assigned."
        endif
    endif

    if ( !hasmapto('<SID>PythonGrep(pychecker)') && (maparg('<F4>') == '') )
        map  <F4> :call <SID>PythonGrep('pychecker')<CR>
        map! <F4> :call <SID>PythonGrep('pychecker')<CR>
    else
        if ( !has("gui_running") || has("win32") )
            echo "Python Pychecker Error: No Key mapped.\n".
            \  "<F8> is taken and a replacement was not assigned."
        endif
    endif

VimTip 950: search multiple buffers for next match
http://vim.sourceforge.net/tip_view.php?tip_id=

When editing multiple files I like to have a search operation that behaves a bit like "/*" in less (to search multiple buffers looking for the next match).  The Nextmatch function (below) does this, although it doesn't behave quite as I would like.  I'm kind of hoping somebody will tell me a better way of doing this ...

    function! Nextmatch()
        let v:errmsg = "X"
        let s:x = bufnr("%")
        while v:errmsg != ""
            bnext
            if bufnr("%") == s:x
                break
            endif
            1
            let v:errmsg = ""
            silent! /
        endwhile
    endfunction

And on a related note, can anyone tell me why this bufdo command doesn't work properly (to show all matching lines in all buffers):

    bufdo g/pattern/p

It always seems to miss a few lines.

VimTip 951: Vim Tutorials
http://vim.sourceforge.net/tip_view.php?tip_id=

At http://psy.swan.ac.uk/staff/carter/unix/ there are a number of web pages with how-to explanations of various tasks in Vim. Various examples of search and replace are provided, an enhanced vimrc, general tips, and a guide on writing an indent script, using Pascal as the indented language.

VimTip 952: refresh screen while typing a command
http://vim.sourceforge.net/tip_view.php?tip_id=

If you are using command line completion while showing matches (^D etc.), often, the display scrolls such a way that the at least part of the text in the buffers is not visible anymore. If you want to redraw screen, you have the option of switching to the command-window, which will refresh the screen anyway, but the following shows a way to redraw the screen without needing to do that. Install the genutils.vim (vimscript #1062) plugin or just copy paste the GetVimCmdOutput() function into your vimrc, and create the following cmap:

cnoremap <C-X><C-L> <C-R>=GetVimCmdOutput('redraw')<CR>

You can now type ^X^L anytime on the command-line even in the middle of typing a new command. In the normal mode you can always use ^L directly so this is not needed, if you enter Ex mode through gQ command (h gQ), you can use this to quickly redraw screen.

VimTip 953: Quick ex in Brazillian ABNT2
http://vim.sourceforge.net/tip_view.php?tip_id=

For those with a Brazillian ABNT2 keyboard, the line
nnoremap ç :
shall provide a quicker access to ex mode at no cost.
You can map it to any other stuff, as VIM does not use 'ç', as far as I can tell.
Just put it in your $HOME/.vimrc and have fun.

VimTip 954: restore the circumstance of edited files when we reopen them
http://vim.sourceforge.net/tip_view.php?tip_id=

autocmd+mksession+expand+wviminfo

when using vim/gvim, we often open many subwindows in one vim/gvim. but when we terminate vim/gvim, the subwindows, marks, and contents in registers will be lost. using the pasted contents below, we can keep all and bring us back to the original circumstance.when we reopen a file edited before, it seems we have never close them. it's very useful to develop projects.

enjoy!

In /etc/vim/gvimrc, add the following two lines
au VimLeave * mksession! ~/.vim/session/%:t.session
au VimLeave * wviminfo! ~/.vim/session/%:t.viminfo

write a script named gvims
#!/bin/sh
if [ -r ~/.vim/session/$1.session ]; then
gvim  "+source ~/.vim/session/$1.session" "+rviminfo ~/.vim/session/$1.viminfo"
else
gvim $1
fi

VimTip 955: Switch between the two styles of Pan Shizhu's color scheme by a single key stroke
http://vim.sourceforge.net/tip_view.php?tip_id=

Pan Shizhu's color scheme ps_color (vimscript #760) supports two styles, a cool (dark) and a warm (light) style. If you want to switch between these styles by just a single key stroke, you may define the following function in your vimrc file:

function! <SID>SwitchPSCStyle()
    if exists("g:psc_style")
        if g:psc_style == 'cool'
            let g:psc_style = 'warm'
        elseif g:psc_style == 'warm'
            let g:psc_style = 'cool'
        endif
    else
        let g:psc_style = 'warm'
    endif
    colorscheme ps_color
endfunction

In order to map this function to a key (for example to <F6>), just add the following mapping:

map <silent> <F6> :call <SID>SwitchPSCStyle()<CR>

Happy Vimming!

VimTip 956: Text-object for quoted strings
http://vim.sourceforge.net/tip_view.php?tip_id=

I really like the text-objects in Vim (:h text-objects), like ciw, or da>, but I really wanted one that would work on quoted sentences.  Here's what I came up with (add to your vimrc):

" Quote motions for operators: da" will delete a quoted string.
omap i" :normal vT"ot"<CR>
omap a" :normal vF"of"<CR>
omap i' :normal vT'ot'<CR>
omap a' :normal vF'of'<CR>

Now, with your cursor on the "a" of "you are here", you can type ci" and add new text between the quotation marks!  Note that it doesn't work for visual mode (vi" only puts you in visual mode).

VimTip 957: Preventing a second copy of VIM from starting
http://vim.sourceforge.net/tip_view.php?tip_id=

Hello everybody.

For me, the most irritating thing when using the wonderful VIM is starging a second copy of VIM while a first one was already running.
For example: openning a file already open in the first VIM instance within a second instance of VIM gives an error message, because the swap file is already in use (Not to mention that this might cause a loss of data).

So I added this to my .vimrc. I don't know if this is the most elegant solution, but it works for me.
I am using GVIM on Windows, but this will probably also work with GVim in other OS's.
You may want to modify it so VIM exists after showing the warning message.

Finally, if someone is familiar with a better option (a built in maybe ?), please post a comment

" ----
  " If the v:servername ends with a number, then this is for sure a second
  " copy of VIM.
  if v:servername =~? '^.*[0-9][0-9]*$'
      echo "MyWarning: Another copy of GVIM or VIM is probably loaded !"
  endif
" ----

VimTip 958: Execute sybase-sql queries and see the result in the splitted window
http://vim.sourceforge.net/tip_view.php?tip_id=

I was killed by Sybase's query tool - SQL Advantage. It's editor so awful that I can't use it at all.
So I decided to engage Vim and sybase database. (I think in that manner you can use Oracle or MS SQL-Server)

First of all, you have to have isql properly setted up.
And here is my "magic" key bind:
au FileType sql map <F12> <C-W><C-O>:silent w !isql -SYourServerName -DYourDatabaseName -UYourUserName -PYourPassword > tmpsqlresult.txt<CR>:split tmpsqlresult.txt<CR>

In short, it closes windows other than your sql  one. Then send current buffer to stdin of isql, which direct its output to a file, which we split then.

Do not forget to provide your own server settings.

If you want splitted window to be appeared below your sql window add
set splitbelow
to your .vimrc.

Hope it will help you :)

VimTip 959: single key buffer switch
http://vim.sourceforge.net/tip_view.php?tip_id=

Anyone who has used the excellent (for it's time - circa 1990) OS/2 "E3" editor may
remember the facility to move forwards/backwards through a ring of buffers with single keypresses; to do this with vim, just define a couple of simple maps in your .vimrc like this:

map <F9> :previous^M
map <F10> :next^M

Then when you hit F9 vim will go back one buffer, and F10 will go forwards one
buffer.  So now you can load up several files and move forwards or backwards
through them at the touch of a key.  You can change which function keys are
used by specifying F1 through F12 in place of F9,F10 above.

VimTip 960: "copy all to clipboard" howto
http://vim.sourceforge.net/tip_view.php?tip_id=

Once my fried asked me: how to copy all the buffer into clipboard?  That time I answered: ggVG<c-ins> (he used to word under windows, so <c-ins> was ok for him.)

Today I've found another way.  I like it much more.  It is:
 :%y+

Happy vimming!  :)

VimTip 961: Search through files
http://vim.sourceforge.net/tip_view.php?tip_id=

When searching all your source files where you left a /TODO/ or where you had version conflicts />>>>/, you may quickly step through all files using a mapping like

nmap <F3> :while !search( @/, "W") \| bnext \| endwhile<cr>

This automatically goes to the next file if the pattern doesn't occur in the current.

VimTip 962: Incremental backup in central backup directory
http://vim.sourceforge.net/tip_view.php?tip_id=

Hi everyone,

  Before using Vim, I used a nice little editor called Crimson.  It had a nice backup feature that I used all the time.  It could be set to automatically backup the current file whenever it was opened up.  And all the backups would go to a dedicated backup directory.  Furthermore, it kept the FULL directory structure.

Example:

1) i edit the file e:\project1\web\show_users.asp, when i open it up, a backup would be created at f:\vim_backups\E\project1\web\show_users.001
2) if i close my editior and re-open the file again in the afternoon, i would get another backup at
f:\vim_backups\E\project1\web\show_users.002

This could lead to a huge number of files but it's easier to retrieve data that is there many times, than to retrieve data that does not exist anymore.  Also, a simple ZIP takes care or any hard drive space issues.  I have gone many times to that backup directory because my supervisor wanted the page to go back to what it was 2 days ago.  It's been very useful.

In vim, however, only 1 backup is created, and it's in the current directory.  You can easily modify VIM to save all backups in a single directory, using the :set backupdir option but then you still only have the one latest backup.  I created this short set of commands to make VIM have similar functionality as Crimson for backups (it uses date and time instead of numbers for the backup extension).  It's the first version, so there might be some bugs, feel free to add/improve to your hearts content.  Also, it's set up for Windows Vim right now, but it should be fairly easy to modify it for use on *nix machines.  I would also like to thank Tim Doerfler vimtip #892 for help on getting started.

I hope this is useful for others too.

Script explanation:

step1:set variables
 this_root_backup_dir = the root directory where all backups will be saved
 this_dir = current directory of file you just opened
 this_filename = current filename of file you just opened
 this_drive = drive where the file you just opened is located (Windows)
 this_backup_dir_drive = drive that should exist in this_root_backup_dir
 this_backup_dir = full backup path starting from the root backup directory
step2:check if the necessary drive letter exist in root backup directory, if not create it
step3:check if the necessary directory exist in root backup directory, if not create it
step4:set the new backupdir option for vim

I have these line in my _vimrc file:

"--Incremental backups, will copy the backup file to a specific backup
"directory and follow the tree structure of the file's directory
"This allows for backup up from multiple drives (on Windows) and easy
"navigation through the backups afterwards.
"Thanks to Tim Doerfler (TIP#892) for the extension part of this script
:let this_root_backup_dir="f:\\vim_backups"
:let this_dir=expand("%:p:h")
:let this_filename=expand("%")
:let this_drive=strpart(this_dir,0,1)
:let this_backup_dir_drive=this_root_backup_dir."\\".this_drive
:let this_backup_dir=this_backup_dir_drive."\\".strpart(this_dir,3)
"--make DRIVE directory if it doesn't exist
if filewritable(this_backup_dir_drive)==0
	sil exe expand("!mkdir ".this_backup_dir_drive)
endif
"--make directory under DRIVE if it doesn't exist
if filewritable(this_backup_dir)==0
	sil exe expand("!mkdir ".this_backup_dir)
endif
"--set new backup dir
exe expand("set backupdir=".this_backup_dir)
"+++++++++ END Auto backups +++++++++++++++++++++++++++++++++++++++

VimTip 963: Highlight tabs which do not appear at the beginning of lines
http://vim.sourceforge.net/tip_view.php?tip_id=

Tabs are fine - as long as they're only used for indentation.  That way, everyone editing the code can change the tab width to their preferred size and be happy.  If tabs are used for lining things up relative to normal characters the spacing looks different for different tab widths.  I like to highlight these tabs for manual cleanup by adding:

    syn match cTodo display "\(\_^\|\_^\t\+\)\@<!\t"

to my syntax file. (see http://vimdoc.sourceforge.net/htmldoc/syntax.html#mysyntaxfile-add for how to add your own syntax options)

VimTip 964: GNU/Linux clipboard copy/paste with xclip
http://vim.sourceforge.net/tip_view.php?tip_id=

xclip,

"
 xclip is a command line utility that is designed to run on any system with an
 X11 implementation. It provides an interface to X selections ("the clipboard")
 from the command line. It can read data from standard in or a file and place
 it in an X selection for pasting into other X applications. xclip can also
 print an X selection to standard out, which can then be redirected to a file
 or another program.
http://people.debian.org/~kims/xclip/
"
I have had a lot of pain with the clipboard until xclip appeared in scene. I mix it with VIM in the following way:

:map   <F7>  :w !xclip<CR><CR>
:vmap  <F7>  "*y
:map <S-F7>  :r!xclip -o<CR>

so with F7 copy all current buffer to clipboard, or a selection.
with shift-F7, paste all clipboard contents.

I prefer doing this way because
"*p
is *slow* when it comes a lot of data. (I never liked "*yy)

VimTip 965: Don't let screen catch your ESC all the time
http://vim.sourceforge.net/tip_view.php?tip_id=

You're using screen to multiplex your terminals? You are also using some keymappings that utilize your Alt-Key (like I use Alt-hjkl and Alt-Cursor for switching screen windows)? But everytime you want to ESCape out of insert mode and press another key fast afterwards, vim does not get that keycode because screen "catches" it, because it thinks you pressed Alt-<something>?

This is due to the fact that a terminal application does not know Alt-<x>, so xterm sends it als ESC and <keycode-of-x> shortly after.

Just try setting

   maptimeout 5

in your .screenrc and screen will 5 milliseconds for the second keycode at most. So, you can use Alt-<bla> for screen but still get ESC-<blub> for vim.

VimTip 966: Multi-line abbreviations are possible!
http://vim.sourceforge.net/tip_view.php?tip_id=

I searched the Internet intently, hoping to find how to
incorporate multi-line abbreviations in VIM.  I was taken
aback when I discovered that everyone maintained that
multi-line abbreviations were not possible.  I've found this
to be untrue. After trying various permutations of carriage
returns, line feeds, and line continuation characters, I've
determined that if you place a line continuation character
(\) and a carriage return (<CR>) at the BEGINNING of each
line, then multi-line abbreviations are possible.  Here is
an example of a multi-line abbreviation:

iab abtest
\<CR>this is line one
\<CR>this is line two
\<CR>this is line three

It's important to note here that there must be a space
following the abbreviation name, in order to avoid
this error when sourcing abbreviations defined like
this:

   E474: Invalid argument

This caveat means that the abreviation definition
quoted looks like this:

   "iab abtest " <--Space after the abbreviation name!

To simplify creating multi-line abbreviations, I've
included two substitution commands which will add
or remove the \<CR> to the beginning of each line.
These are mapped in visual mode, and are bound to the
Ctrl-C and Ctrl-Alt-C keys:

   :vmap <C-c>   :s/^/\\\<\C\R\>/<CR>:nohlsearch<CR>
   :vmap <C-A-c> :s/\\<CR[>]//<CR>:nohlsearch<CR>

To create a multi-line abbreviation using these
mappings, follow these steps. This example creates
a multi-line abbreviation for the proverbial
"hello world" C program:

#include <stdio.h>

void main(void) {

  printf("Hello World\n");

}

1. Place the :vmap key mappings into a file and source it.
2. Place the cursor on the first line and press Shift-V.
3. Press the 'j' key until the entire code block is highlighted.
4. Press Ctrl-C.  This places the \<CR> in front of each line.
   It should now look like this:

\<CR>#include <stdio.h>
\<CR>
\<CR>void main(void) {
\<CR>
\<CR>  printf("Hello World\n");
\<CR>
\<CR>}

5. Add an "iab cmain " (unquoted) just above the abreviation, and insure
   there's a space after cmain. It should look like this:

iab cmain
\<CR>#include <stdio.h>
\<CR>
\<CR>void main(void) {
\<CR>
\<CR>  printf("Hello World\n");
\<CR>
\<CR>}

6. Now simply source the file, and type cmain to expand the abbreviation.
   That's it!  I've included a perl, java, and C multi-line abbreviation below that
   you may find useful.

iab abperl
\<CR>###############################################################################
\<CR>#
\<CR># File:
\<CR>#
\<CR># Date:
\<CR>#
\<CR># Description:
\<CR>#
\<CR># Syntax:
\<CR>#
\<CR># Author:
\<CR>#
\<CR># Copyright (c)
\<CR>#
\<CR>#
\###############################################################################

iab abjava
\<CR>/////////////////////////////////////////////////////////////////////////////
\<CR>//
\<CR>// File:
\<CR>//
\<CR>// Date:
\<CR>//
\<CR>// Description:
\<CR>//
\<CR>// Syntax:
\<CR>//
\<CR>// Author:
\<CR>//
\<CR>// Copyright (c)
\<CR>//
\<CR>//
\//////////////////////////////////////////////////////////////////////////////

iab abc
\<CR>/*****************************************************************************
\<CR>*
\<CR>* File:
\<CR>*
\<CR>* Date:
\<CR>*
\<CR>* Description:
\<CR>*
\<CR>* Syntax:
\<CR>*
\<CR>* Author:
\<CR>*
\<CR>* Copyright (c)
\<CR>*
\<CR>*
\******************************************************************************/

VimTip 967: fast access to the first nine buffers
http://vim.sourceforge.net/tip_view.php?tip_id=

I offten edit more then one file and i do alot of switching between them.
<ESC>:bX - is not so fast. Prev/Next feature (and mapping) is slow too.
I use Alt X to switch between buffers (X - # of buffer).

:map <M-1> :confirm :b1 <CR>
:map <M-2> :confirm :b2 <CR>
...
...
...
:map <M-9> :confirm :b9 <CR>
:map <F3> :confirm :ls <CR>

VimTip 968: Custom keyword completion (works only with Vim 7)
http://vim.sourceforge.net/tip_view.php?tip_id=

With Vim 7 (still in development), you can use complete code completion using CTRL-X CTRL-U. See :help 'completefunc'.

With this small script with which you can complete keywords using some kind wildcards. By default '\k\zs' reg-exp is used as wildcard. Usefull if you are using identifiers with mixed case, so aCN expands to anyCrazyName or anotherCodeName, but not AnotherCodeName neither BadCodeName.

-- Marian

--------------------------------8<--------------------------------8<--------------------------------
" settings:
" g:mkw_any - default regular expression used as wilcard
" - possible settings:
"   - ''
"     every nothing around character in pattern is used as wildcard, so for
"     KEY is '\<\k*K\k*E\k*Y\k*\>' used for matching keywords
"   - '\k\zs'
"     every nothing around characters but the first is used as wildcard, so
"     for KEY is '\<K\k*E\k*Y\k*\>' used for matching keywords
"   - or any other reg.expression (e.g. '\.\.', '', '_', '\\', '::', '`')
"     be carefull it doesn't mixe with language constructs used in your
"     sources (as '\.' in C is used for structure members)
"     if zero-length match is used:
"     - prepend \k\@<= if the first char in pattern must be the first in match
"     - postpend \k\@= if the last char in pattern must be the last in match
" b:mkw_any - regular expression to be used for current buffer as wilcard
"
" other:
" g:mkw_devel - if exists script is reloaded every time it is sourced

if v:version < 700
  echohl ERROR "Smart completion will work only in vim version 7+"
  finish
endif

if !exists("g:mkw_any")
  let g:mkw_any = '\k\zs'
endif

if exists("g:mkw_devel") || !exists("g:mkw_loaded")

  " find start of keyword-match (return) and create regexp for finding
  " matching keyword (s:re)
  " a:line - string to search in, search starts at end of string
  " a:anyre - reg.exp looked for to be replaced by '\k\*'
  fun! MKwFindStart(line,anyre)
    " this can not be used because a:anyre could be 0-length:
    "return match(a:line,'\%(\k*'.a:anyre.'\)*\k*$')
    let line = a:line
    " trims trailing keyword-characters
    let answ = match(line,'\k*$')
    if answ < 0
      let answ = strlen(line)
    else
      let line = strpart(line,0,answ)
    endif
    " trim trailing occurences of keyword-characters followed by anyre
    while answ > 0
      let answ = match(line,'\k*'.a:anyre.'$')
      if answ < 0 || answ == strlen(line) | break | endif
      let line = strpart(line,0,answ)
    endwhile
    " set answ and s:re:
    let answ = strlen(line)
    let line = strpart(a:line,answ)
    let s:re = '\<'.substitute(line,a:anyre,'\\k*',"g").'\>'
    "echo line ">>>" s:re
    return answ
  endfun

  "
  fun! MKwCompleteId(line, base, col, findstart)
    if a:findstart
      " locate start column of word
      if !exists("b:mkw_any")
        let mkw_any = g:mkw_any
      else
        let mkw_any = b:mkw_any
      endif
      return MKwFindStart(strpart(a:line,0,a:col),mkw_any)
    else
      " remember cursor position
      let line = line('.')
      let col = col('.')
      " create word list (it serves as reg.exp too, to exclude words found
      " already)
      let res = ""
      while search('\%(\<\%('.res.'\)\>\)\@!'.s:re,'w') > 0
        let tmp = expand("<cword>")
        let res .= (res == "" ? "" : '\|').expand("<cword>")
      endwhile
      " restore cursor position
      call cursor(line,col)
      "echo s:re ":" res
      return substitute(res,'\\|',"\n","g")
    endif
  endfun

  let g:mkw_loaded = 1
endif

setlocal completefunc=MKwCompleteId

VimTip 969: Highlight simple python syntax errors
http://vim.sourceforge.net/tip_view.php?tip_id=

If you want simple syntax errors highlighted in Python (such as if statements with a missing colon at the end) then do the following:

1. Download and install vimscript #30
2. Search for the line beginning "syn match pythonError". Add the following lines after that:

    syn match pythonError		"^\s*def\s\+\w\+(.*)\s*$" display
    syn match pythonError		"^\s*class\s\+\w\+(.*)\s*$" display
    syn match pythonError		"^\s*for\s.*[^:]$" display
    syn match pythonError		"^\s*except\s*$" display
    syn match pythonError		"^\s*finally\s*$" display
    syn match pythonError		"^\s*try\s*$" display
    syn match pythonError		"^\s*else\s*$" display
    syn match pythonError		"^\s*else\s*[^:].*" display
    syn match pythonError		"^\s*if\s.*[^\:]$" display
    syn match pythonError		"^\s*except\s.*[^\:]$" display
    syn match pythonError		"[;]$" display
    syn keyword pythonError         do

VimTip 970: Vi key-bindings in gtk 2.x
http://vim.sourceforge.net/tip_view.php?tip_id=

There is nifty feature for gtk 2.x (don't know for 1.x) and key bindings. Unfortunate gtk
authors didn't provide us with nice documentation and how to append ours. I mean, nowhere
on the net I couldn't find any usable "paper" for it. But, gtk2.x ships with emacs
"theme", and why we don't start from it.

Since emacs often use <SHIFT> or <CTRL> (some key) for text handling, appending bindings
for it, especially for GtkEntry is not the problem. On other hand, gtk knows only for
<SHIFT>, <CTRL>, <ALT> and mod[1-5] special keys, and appending something like <ESC>(wait
until other key is pressed) is not possible.

So this solution (I know that is limited) is focused only on GtkTextView and GtkTreeView
classes (read this as: you can use keys in non editable text areas and in browser, tree
widgets). Those keys are standard vi "h-j-k-l" for one line movement and <CTRL>-d <CTRL>-u
for scrolling.

Detailed list
----------------------------

Textview widgets (readonly text areas):

h - left
j - down
k - up
l - right
<CTRL>-u - scroll 5 lines up
<CTRL>-d - scroll 5 lines down

'Similar' keys:

<CTRL>-e - down
<CTRL>-y - up
<CTRL>-f - scroll 5 lines down
<CTRL>-b - scroll 5 lines up

Tree widgets (any kind of browser widget, including trees):

h - selection left
j - selection down
k - selection up
l - selection righy

So to do 'the real work', copy next (without lines):

----------------------->8---------------------------------------

#
# A key-binding set for vi-like key-bindings
#

binding "gtk-vi-text-view"
{
  bind "<ctrl>d" { "move-cursor" (display-lines, 5, 0) }
  bind "<ctrl>f" { "move-cursor" (display-lines, 5, 0) }
  bind "<ctrl>u" { "move-cursor" (display-lines, -5, 0) }
  bind "<ctrl>b" { "move-cursor" (display-lines, -5, 0) }
  bind "<ctrl>e" { "move-cursor" (display-lines, -1, 0) }
  bind "<ctrl>y" { "move-cursor" (display-lines, 1, 0) }
  bind "j" { "move-cursor" (display-lines, 1, 0) }
  bind "k" { "move-cursor" (display-lines, -1, 0) }
  bind "l" { "move-cursor" (logical-positions, 1, 0) }
  bind "h" { "move-cursor" (logical-positions, -1, 0) }
}

binding "gtk-vi-tree-view"
{
  bind "j" { "move-cursor" (display-lines, 1) }
  bind "k" { "move-cursor" (display-lines, -1) }
  bind "l" { "move-cursor" (logical-positions, 1) }
  bind "h" { "move-cursor" (logical-positions, -1) }
}

class "GtkTextView" binding "gtk-vi-text-view"
class "GtkTreeView" binding "gtk-vi-tree-view"

----------------------->8---------------------------------------

and save it to 'gtkrc' file. Now create in themes directory (usually placed in
/usr/share/themes) directory named 'Vi' (or 'Vim' if you prefer). In it, make
'gtk-2.0-key' directory too. Copy created 'gtkrc' file there. At the end, you should get
something like:
'/usr/share/themes/Vi/gtk-2.0-key/gtkrc'.

The last part is to note your's local gtk configuration file. Check in your home directory
file named '.gtkrc-2.0'. If is there, nice, and if not, well... "touch" it :) The only
think left to be done is appending:

gtk-key-theme="Vi"

If you used 'Vim' to title directory, instead "Vi", place "Vim".

Now start some gtk2.x application and play with those keys :)

I tested it with gaim and gtk-demo with successful working. Errors are possible,
especially with complex applications (example evolution, I think). Also, know that
mozilla, firefox, thunderbird... etc will not recognize those keys since they use own
key-binding methods :(

PS:
for scrolling I used 5 lines because window size can't be calculated. Increase or decrease scroll jump as you like.

VimTip 971: Substitute with incrementing numbers
http://vim.sourceforge.net/tip_view.php?tip_id=

Say you have a document:

    foo bar
    bar foo
    bar
    foo

and you want to replace the first foo with blah_1, the second with blah_2, the third with blah_3 and so on. There are a number of options. The most obvious is:

    :let i=1 | g//s/foo/\="blah_".i/ | let i = i + 1

This only works if foo only occurs at most once per line. Changing to a global substitute doesn't help, as i will only be incremented once per matching line. The solution is to use setreg():

    :let @a=1 | %s/foo/\="blah_".@a.(setreg('a',@a+1)?'':'')/g

Unfortunately, setreg returns 0 rather than the value of the register it set, so we need to use a ?: block to eliminate this. Another option, which is only available in vim7:

    :let i=[] | %s/foo/\="blah_".len(add(i,''))/g

This uses a growing list rather than a number.

VimTip 972: running native-Windows Vim from cygwin (without a wrapper)
http://vim.sourceforge.net/tip_view.php?tip_id=

To run native-Windows Vim from cygwin, just create one or more of the following aliases (for instance in ~/.bash_profile). You may grab them by copy&paste via the clipboard:

alias vim='VIM=`cygpath -d $VIM` HOME=`cygpath -d $HOME` `cygpath -u $VIM`/vim63/vim.exe'
alias vimd='VIM=`cygpath -d $VIM` HOME=`cygpath -d $HOME` `cygpath -u $VIM`/vim63/vimd.exe'
alias gvim='VIM=`cygpath -d $VIM` HOME=`cygpath -d $HOME` `cygpath -u $VIM`/vim63/gvim.exe'
alias gvimd='VIM=`cygpath -d $VIM` HOME=`cygpath -d $HOME` `cygpath -u $VIM`/vim63/gvimd.exe'

alias v7vim='VIM=`cygpath -d $VIM` HOME=`cygpath -d $HOME` `cygpath -u $VIM`/vim70aa/vim.exe'
alias v7vimd='VIM=`cygpath -d $VIM` HOME=`cygpath -d $HOME` `cygpath -u $VIM`/vim70aa/vimd.exe'
alias v7gvim='VIM=`cygpath -d $VIM` HOME=`cygpath -d $HOME` `cygpath -u $VIM`/vim70aa/gvim.exe'
alias v7gvimd='VIM=`cygpath -d $VIM` HOME=`cygpath -d $HOME` `cygpath -u $VIM`/vim70aa/gvimd.exe'

Notes:
- In each alias, the whole string after the first = is surrounded by single quotes
- This assumes that $VIM and $HOME are correctly defined in the master environment. How to set them is outside the scope of this tip.
- Today (while I'm writing this) the current Vim versions are 6.3 (stable) and 7.0aa (under development). Sooner or later there will be a newer version. Just change the last directory name in the above aliases to reflect it.
- See 'man cygpath' for more info.

VimTip 973: Using native-Windows and cygwin versions of Vim with the same runtime files
http://vim.sourceforge.net/tip_view.php?tip_id=

It is possible to keep native-Windows and Cygwin versions of Vim on a same machine with common runtime files (I have done it; but see vimtip#972 for an alternative solution) Here is what you need to do for that:

1. Install the full Windows distribution in C:\Program Files\vim\vim## where ## is the version (e.g. 63 for Vim 6.3, or 70aa for Vim 7.00aa ALPHA).
2. Install the cygwin executables only (of the same version and sub-version; the patchlevel may be different), in /bin
-- repeat either step 1 or step 2 at each upgrade
3. Set VIM (in the Windows environment) to C:\Program Files\vim and HOME to your home directory
4. In the cygwin startup files (e.g. ~/.bash_profile) add the following lines:

    export VIM=`cygpath -u $VIM`
    export HOME=`cygpath -u $HOME`

5. All runtime files must be in Unix format. If they aren't, do the following in vim (version 7 or later) for native-Windows (it takes some time but it's fairly automatic). (On version 6 it's possible but since ** wildcards are not recognised it is more work.) (See also vimtip#848 about how to install several _different_ versions in parallel.)

    :set nomore
    :args $VIM/**/*.vim
    :argdo setl ff=unix
    :args $VIM/**/*.txt
    :argdo setl modifiable noro ff=unix
    :set more

6. Directories $HOME/vimfiles and $HOME/.vim must be made identical. This can be done in Cygwin bash with the following command:

    cd ~
    ln -s   vimfiles   .vim

-- steps 3 to 6 need be done only once, they remain valid even if you later install a different version.

VimTip 974: integrate gvim with RedHat Source-Navigator
http://vim.sourceforge.net/tip_view.php?tip_id=

The Source-Navigator (http://sourcenav.sourceforge.net) has a built in editor, but you will be unhappy if your fingers are used to vi. To solve this, configure Source-Navigator to use gvim as the editor by,

File > Project Preferences ...

and click on the Edit tab. In the External Editor box, enter

gvim "+call cursor(%l,%c)" %f

Now, double clicking on any symbol, function, etc in Source-Navigator will start gvim and position the cursor in front of the item you clicked.

VimTip 975: su-write
http://vim.sourceforge.net/tip_view.php?tip_id=

I just wrote a little function that uses sudo and cp to save a file whose modes wouldn't allow me to write it.
Obviously, it preserves the modes of the original file, though it is being rewrited. Of course, this tip has to
be used with real caution, as it gets you more power...

TODO:
The only real drawback is there's no check for symlinks, and then, the symlink would get removed and
replaced by a file with the symlink's modes, which are 777...
Another thing that would be nice, would be to integrate it to the interface, to get it work when :w is not
enough, or at least having an alias like :wforce, :w!! or :whatever...

function Suedit() {
   let fname=tempname()
   exe 'w '.fname
   let modes=system('find . -maxdepth 1 -name '.expand("%").' -printf "%m"')
   exec '!sudo cp '.fname.' '.expand("%")
   exec '!sudo chmod '.modes." ".expand("%")
}

VimTip 976: Like :ls but sorted by buffer name
http://vim.sourceforge.net/tip_view.php?tip_id=

REQUIRES:  perl
WARNING:   Overwrites contents of the un-named register
Tested on 6.3

I assume you are familiar with the built-in command :ls.
The output of :ls is sorted by buffer number.
The following command results in a user defined command named :Ls
(all user defined commands need to start with a capital letter).
The output of :Ls is the same as the output of :ls except that the
output is sorted by buffer name.

Here's the command -- written in many lines to improve readability.
I have it as a single line in my vimrc:

  command! Ls redir @" | silent ls | redir END | echo "\n" |
              perl $foo=VIM::Eval('@"');
                   while($foo =~ m/(.*?line\s+\d+)/g)
                   {$val = $1; $val =~ m/"([^"]+)"/; $list{$1} = $val;}
                   VIM::Msg("\n");
                   for $boo (sort keys %list)
                   {VIM::Msg("$list{$boo}\n");}
              <cr>

--Suresh

VimTip 977: Quickly align whole file
http://vim.sourceforge.net/tip_view.php?tip_id=

gg=G would quickly align the whole file, but you will be at the beginiing of the file after that. To align and still remain in the same line where you were, just add this mapping to your .vimrc

map <F7> mzgg=G'z<CR>

Now, just press <F7> whenever you want to align your file.
I just use. Use whatever you prefer instead of <F7>.

VimTip 978: Cobol Editing with VIM
http://vim.sourceforge.net/tip_view.php?tip_id=

If you have used vim with a Cobol file recently you probably noticed something.
All the text is red.  Yes.  All of it.

I looked around on the web and saw other people complaining about it but no fixes so I started playing around with the cobol.vim file in the syntax folder. There is a simple fix:

Open the one of the two files depending on your platform:

C:\Vim\vim63\syntax\cobol.vim
/usr/share/vim/vim63/syntax/cobol.vim

Look for this section: it is line 126 in my vim 6.3 cobol.vim file:

if ! exists("cobol_legacy_code")
" catch junk in columns 1-6 for modern code
syn match cobolBAD "^ \{0,5\}[^ ].*"
endif

Comment the whole thing out so it looks like:

"if ! exists("cobol_legacy_code")
" catch junk in columns 1-6 for modern code
" syn match cobolBAD "^ \{0,5\}[^ ].*"
"endif

Should work OK after that.
Happy vimming!

Bill :-)

VimTip 979: Map search to space bar increased
http://vim.sourceforge.net/tip_view.php?tip_id=

My favorite way to move around is to use the pattern search. It is mapped to / by default, but this key is a little difficult to reach with the little finger, i.e. when touch typing. Thus, I mapped the search command to the biggest key on the keyboard: the space bar, because I noticed that I never used its default mapping (move the cursor forward one character).

nmap <Space>  /
nmap <C-Space>  ?

This sounds like a small change but it astoundingly increases convenience in every day work.

VimTip 981: Commenting out a range of lines
http://vim.sourceforge.net/tip_view.php?tip_id=

Here's a general tip that works for any version of vi, not just vim.

It's very common to need to comment out a range of lines, let's say in a shell script.  One way to do this is to move to the first line and type: I# (insert #<space> as the first non-blank character of the line)
Then use a series of: j. (moving down and repeat the previous command/change)

However, this is tedious; using j.j.j. ...

Another way is to determine the line numbers of the first and last line.  You can use the :f ex command to display these; or you can temporarily use :set nu to enable "number mode" and :set nonu to disable when you're done.

Whatever method you use to find the line numbers they can be used as a range for a substitute command:  :xx,yy s/^/# /

This is a bit tedious because you have to look up the numbers and re-type them.

So we want a method that is repetitive than j.j.j. and involves less manual fussing with line numbers than the ex range/substitute command.  The solution is as old as vi/ex itself though it's often overlooked.

Move to the first line and set a mark with: ma (where "a" is any letter you choose)
Move to the last line and issue the following ex command: :'a,. s/^/# /

This works on the range of lines between the mark (single quote, register letter) and the current line (.) substituting each beginning of line with the string "# " (octothorpe, space).

More elaborate sequences of pure old ex commands can also be used to create boxes around C/C++ blocks; but they are really horrid to type every time so they have to be mapped to some key sequence and entails consistently using the same register every time.

For example:  map  gC :'a,. s/^/ */^M:. s/\(.*\)/\1^V^V^M **************\//^M:'a s/\(.*\)/\/**************^V^V^M\1/^M

maps the sequence gC to a macro which wraps a block of text, from the current line back to the line marked by the "a" in a C style comment like:

 /************************
  *
  * ....
  * ....
  ************************/

The example is a little crude --- it doesn't indent the comment block at all,
for example; and it could use some extra blank lines.  However, it illustrates the point of what we can do even with plain old vi/ex commands.

VimTip 982: Inserting a new-line without entering insert mode
http://vim.sourceforge.net/tip_view.php?tip_id=

As you all know with 'o' or 'O' you can insert a new line before/after the current line. But both commands enter the insert mode, which may sometimes not what you want. I put this in my vimrc-file to insert a new-line after the current line by pressing <ENTER> (<SHIFT+ENTER> for inserting a line _before_ the current line):

map <S-Enter> O<ESC>
map <Enter> o<ESC>

You should not map this to <ENTER> if you use <ENTER> to navigate (obivously).

If you want to stay in the line where you have been before use the following maps:

map <S-Enter> O<ESC>j
map <Enter> o<ESC>k

This is nothing great compared to other useful tips here, but I found it nifty (especially to structure program code etc.)

[I also hope that this has not been posted before as this tip seems very obvious to me...]

VimTip 983: Numbering Mode, Number Line Ranges and Interpolating Sequences
http://vim.sourceforge.net/tip_view.php?tip_id=

There are several tips surrounding numbering here in the collection.
This is an effort to summarize and consolidate them.

One of vi's unique features is the ability to display line numbers
alongside our text.  :set number (or :set nu for short) enables this
mode.  Obviously this is most useful when dealing with code and when
using ex ranges (:xxx,nnn ...).  However, it does tend to push all of
the text several columns to the right which can make for quite a bit of
ugly line wrapping when dealing with text that was already wrapped close
to the width of your text.

Switching the mode on or off can be tedious (8 or 10 keystrokes).  The
following pair of mappings reduces that to just two:

:map gn :set nu^M
:map gN :set nonu^M

Those are so simple they'll work in any version of vi (not just vim).

Alternatively we can just make one macro (vim specific) which toggles
the number mode state:

:map gn :set invnu^M

(The functions in VimTip 757 aren't necessary; if we've read VimTip
37 which covers using the inv prefix to boolean settings to "invert,"
or toggle, their current state).

To make a toggling macro like this in an older version of vi we could
use a moderately ugly hack.  In our .exrc file we'd set the initial
macro/state:

map gn :set nu^M:so ~/.exrc.nonu^M
... and then in our ~/.exrc.nonu file we toggle it:
map gn :set nonu^M:so ~/.exrc.nu^M

In other words; we use the :source command to remap the macro each time
it's called.  (That trick can be used generically for toggles and for
cycling among lists of states, if we're willing to clutter our home
directory with all those little fiddly bits.  Thankfully this is vim and
we can dispense with all that.

Of course these examples are following the common convention of using
"g" as a prefix for our custom mappings since the "g" key is unused in
standard vi and the n and N bindings don't conflict with any vim
defaults.  We could bind them to "zn" and "zN" (since "z" is the other
common vi mapping prefix).  However we would be over-riding a couple of
vim specific mappings (for foldenable related settings).

When vi students ask me about line numbering I have to clarify if they
want the numbers displayed or if they want numbers inserted into
selected sequences of their text.  vi can handle either case with
alacrity.  The following macro will filter a sequence of lines from the
"n" mark to the current one through the UNIX nl (number lines) filter.

:map g# :'n,. !nl^M

So simple it's almost not worthy of a tip.  Of course one could use 'cat
-n' or any simple 'awk' or Perl script in lieu of the 'nl' utility and
one could certainly customize this with custom arguments controlling the
width and number formatting options, at least with the GNU version of
'nl.'  (The Perl script in VimTip 569,  "Insert line numbers or filter
thru perl", would be equivalent to GNU: nl -w3 -s:)

Note I use the "n" marker for this to emphasize that I'm intent on
NUMBERING a range of lines.  That's handy because I usually use the "a"
mark first for general purposes such as yanking or deleting.  Using "n"
here minimizes the risk that I'll inadvertantly number a large range of
lines to one of my general purpose marks. (VimTip 28 offers a function
using vim native built-ins for users on non-UNIX systems without the
'nl' utility.  However my advice to them is: install Cygwin!).

(VimTip 65 offers an unecessarily complex suggestion for numbering
all the lines of a file. One can simply use :%!nl[Enter] for that.
Only six keystrokes for something which is not a common requirement.
The g# macro above is useful for programmers and programming instructors
or technical writers when including and discussing excerpts of code).

VimTip 124 provides a more elaborate function which can take arguments
for starting indices, and offers other features.  However, it's elaborate
enough that I'd probably never remember to call it when I needed it.

In cases where I need to generate a sequence of similar lines which
differ only in a few places by embeded numbers, I generally just write
a simple shell command using a for loop, the GNU 'seq' utility (which,
can be implemented in about 5 lines of shell if you're on a machine that
lacks it) and echo statements).  For example I sometimes find myself
editing DNS zone and reverse zone files and using simple commands like:

:r! for i in $(seq 5 200);do echo -e "dyn$i.my.org\t\tIN A 192.168.1.$i"; done

... to generate most of my text.

VimTip 150 tells us how to generate a column of increasing numbers using
Ctrl-V block/visual and a script.  It's nice but I have to admit I
resort to something a bit more crude.  I create my template line with
some unique string such as "xxx" to be replaced by the numeric sequence.
I then duplicate that using normal vi commands like 100p (to put in a
hundred copies of the template line, for example).  Then I simply use
something like !} (filter from here through the end of the paragraph)
and type is a moderately ugly command like:

awk '{sub(/xxx/,n++);print}'

... as the filter (assuming I want to start with zero).  More tedious
versions are easily concocted using things like:

awk 'BEGIN {n=100};{sub(/xxx/,n-=3);print}'

... to do things like count down from 100 by threes.  Thankfully I
rarely have occasion to need this sort of thing for more than a half
dozen lines where it's generally easier to just type such things by
hand. Otherwise I'd save the specifics to a short script and possibly
map the filtering to another macro like the g# shown above.

A couple of odd vim specific bindings that appear in other tips are
Ctrl-A and Ctrl-X (VimTip 30 and partially duplicated in VimTip 287,
and mentioned in passing in VimTip 305). These find the number nearest
to the cursor and increment or decrement it respectively.  I've never
used that and will probably never quite remember it when I would and
will probably never quite remember it when I would.

So there you have it, a consolidation of about eight tips for toggling
numbering mode on and off and for numbering ranges of lines or filling
in templates with numeric sequences.

It's all a numbers game. :)

JimD

(This tip written in vim and posted with Mozilla with help from mozex, courtesy of VimTip 581)

VimTip 984: Accessing the System Clipboard through the * Register
http://vim.sourceforge.net/tip_view.php?tip_id=

One of the traditional disconnects between vi and modern graphical
environments has been using mouse-driven cut and between our terminal or
command prompt window (running vi) and any other applications
(especially our browsers).

It turns out that vim has extended vi in a subtle way which allows us to
use the * register as a reference to the system clipboard.  So we can
use normal mode commands like: "*dd or 1G"*yG to copy things into the *
register and "*p to paste text from it.  We can also use this * register
with the ex "y" ("yank") command, to :%y * will accomplish the same goal
as 1G"*yG (selecting all into the system clipboard so it can be pasted
into any other X or MS Windows text area dialog).

This * register acts just like any of the normal (single letter)
registers in vi except that it also happens to refer to the system
clipboard in X11 or MS Windows.

I've also found that it's MUCH faster and more reliable than pasting
a large body of text into vi/vim through an xterm.  Normally I run vim
under the Linux screen utility and any more than one screen full of text
was often corrupted and larger (10s of KB) selections would take several
seconds of gnashing and flashing to finish pasting (almost always
corrupted).  On a couple of occasions before I learn about the *
register I resorted to using nedit to handle the cut-n-paste, saving to
a temporary file so I could edit it.  By contrast a couple hundred KB
slected and pasted using "*p is under a second and works perfectly for
me.

I searched extensively though the VimTips collection and only found a
few passing references to this feature in: VimTip 71 (implies it's a
feature of gvim. I find it works in text vim just fine under Linux; I
only use gVim under MS Windows). VimTips 771 and 964 refer to an extra
utility named xclip which is only for X11 and seems to be completely
unnecessary for vim using the * register), and VimTip 960 (misses the
point but the comment thread mentions it a few times).

VimTip 21 is spot on but the title suggests it's for (MS) Windows only.
It also mentions that we can change out settings so the "anonymous"
register is aliased to the * register using:

  set   clipboard=unnamed

VimTip 296 uses the * register in some native vim code (using @*)
without explaining it in general.  VimTip 432 and 600 both echo that.
VimTip 448 also uses it (for converting hex to decimal) but explains it
in passing.  VimTip 478 uses it in a function for copying the results
of a :g search into the * register.  VimTip 687 suggests that MacOS X
doesn't implement the * register (yet?) but suggests a workaround using
the pbcopy and bppase utilities.  VimTip 876 also makes passing reference
to it.

There are several tips for copying the current filename into the
clipboard including: VimTips 296, 432, 891, 600 (most of the fuss is
resolving /'s into \'s for MS Windows paths).

VimTip 985: quickly Get Files in your Environment
http://vim.sourceforge.net/tip_view.php?tip_id=

Abstract:  what are some quick ways to access files?  Environment variables
and the gf command.

Using the mouse to navigate to a directory, then clicking-on an icon or
shortcut is too laborious and time consuming.   Vim is designed to minimize
mouse usage.

Instead of a directory, one could open a file which contains filenames to
edit.   Once your cursor is placed within a filename, the command "gf" will
magically open it.  (I memorize that by 'get file'.)

Some operating systems allow the use of the space character in specifying
directories and files.  Bad idea, for that practically breaks the use of gf.

Assuming that your username is "amen" and that you adhere to the convention of
no-spaces in names, we will proceed with some examples, in your directory
called "theory_e" and a file called "godel-relativity.txt".

In Windows XP, the full path would look something like this:
C:/Documents and Settings/amen/My Documents/theory_e/godel-relativity.txt

Doing a gf on this mess will bring unpredictable results depending on where
your cursor was placed on that line -- because it is not continguous.   Now
luckily that actually fit on one line.  If there were subdirectories, that
line will break past the edge, and again gf will malfunction.

Now gf is not buggy, but rather, the file specification is ugly.  So a
solution might be to create an environment variable (preferably in your
_vimrc):

     let $amen = 'C:/Documents and Settings/amen/My Documents'

Note that the offending spaces are contained within quotes -- which is the
saving grace.   Now let's read our notes, somewhere say from drive D:

     Kurt Godel constructed a model which was consistent with Einstein's
     general theory of relativity in which the direction of time was not
     unidirectional, but rather, circular.  Einstein's critique is found in
     $amen/theory_e/godel-relativity.txt (section 43 needs editing).

Now doing a gf on that filename will open it.  And notice the economy in
style.  If you move to another system where your user path is different, just
change the assignment of $amen.   Your text files need not be revised.  For
example, on your Unix machine, .vimrc might include this sane version:

     let $amen = /home/amen

Generally, I prefer forward slashes when writing paths, to preserve
multi-platform compatibility.   So on a Windows machine which insists on back
slashes, I use this conversion command often:

     command! -range   Sslash    <line1>,<line2>s;\\;/;g
     "  Substitute back slash to forward SLASH.

Thus :Sslash will work on a single line, or a specified range, e.g.
:7,14Sslash for lines 7 through 14.   Or better yet, just visualize an area,
and then execute the command via ":" which brings up the implied range
:'<,'>   --  which can be automated by the following visual mapping,

     vmap ,s   :Sslash<CR>
     "         Visualize the desired area, then hit ",s".

Couple of other tips...  try _directly_ editing a directory,

     :e $amen

Navigate around your file system, using just the <CR> key.   For virgins, this
is a holy smokes moment.  The ".." you see indicates the parent directory one
level up.  While editing a file, try the split-screen directory edit,

     :Sex

which is pretty darn easy to remember (actually it's short for Sexplorer).
For Window users, no more complaining about not being able to print the
directory (hey, now you can yank it).

Finally, environment variables are very useful in creating commands:

     command! Egodel   e $amen/theory_e/godel-relativity.txt

With that in your vimrc, you can quickly edit your favorite file by
simply...

     :Egod

Hope this brightens your day!  (which will re-occur, sooner or later)

Gochess
http://wiki.43folders.com/index.php/Gochess

VimTip 986: Background :grep Searches
http://vim.sourceforge.net/tip_view.php?tip_id=

Many times, I launch recursive searches from the current directory that take a while to run.  These functions allow a search to run in the background and the results to be pulled in later (once the search completes).

" runs a search in the background
function! BackgroundGrep(search, fpatt)
  let g:bg_grep_file = tempname()
  " for Win32
  silent execute "!start cmd /c \"" . &grepprg  . " -R " . a:search  . " " . a:fpatt  . " >"  . g:bg_grep_file . " 2>&1\""
  echo g:bg_grep_file
endfunction

" loads the results of the last background search
function! LoadBackgroundGrepResults()
  if !exists("g:bg_grep_file")
    echohl ErrorMsg | echo "BackgroundGrep() must be run first" | echohl None
    return
  endif

  if !filereadable(g:bg_grep_file)
    echohl ErrorMsg | echo "Cannot open bg_grep_file: " . g:bg_grep_file | echohl None
    return
  endif

  execute "cfile " . g:bg_grep_file
endfunction

In order to make the functionallity work for Unix, you'll have to change the "silent execute..." line of the first function to use the Unix commands (and & to run in the background).  It should be pretty straight forward to modify this line.

VimTip 987: Easy floating point arithmetic
http://vim.sourceforge.net/tip_view.php?tip_id=

I have often found myself wanting to do quick floating point arithmetic within vim.  Here are the maps that I put together to handle such.  They do require access to Perl, but they are a simple solution to simple mathematical needs.  Of course the syntax used for the mathematical expression should follow that of Perl itself.

Evaluate an expression contained on the full current line and place answer in a new line below the current line:
nnoremap <Leader>ma yyp^y$V:!perl -e '$x = <C-R>"; print $x'<CR>-y0j0P

Evaluate an expression contained in a visual selection and place the answer in a new line below the current line:
vnoremap <Leader>ma yo<ESC>p^y$V:!perl -e '$x = <C-R>"; print $x'<CR>-y0j0P

Evaluate an expression contained on the full current line and replace the current line with the answer:
nnoremap <Leader>mr ^"gy0^y$V:!perl -e '$x = <C-R>"; print $x'<CR>^"gP

Evaluate an expression contained in a visual selection and replace the visual selection with the answer:
vnoremap <Leader>mr "aygvrXgv"by:r !perl -e '$x = <C-R>a; print $x'<CR>0"cyWddk:s/<C-R>b/<C-R>c/<CR>

Hope this helps somebody else!

VimTip 988: Surround selection with text
http://vim.sourceforge.net/tip_view.php?tip_id=

Inspired by tip #987 I wrote a small function to surround selected text in Visual-mode with text.

e. g. to quote a selection:

before: bla bla Selected Text bla bla
:'<,'>call Surround('"', '"')<CR>
after   : bla bla "Selected Text" bla bla

fun! Surround(s1, s2) range
    exe "normal vgvmboma\<ESC>"
    normal `a
    let lineA = line(".")
    let columnA = col(".")

    normal `b
    let lineB = line(".")
    let columnB = col(".")

    " exchange marks
    if lineA > lineB || lineA <= lineB && columnA > columnB
        " save b in c
        normal mc
        " store a in b
        normal `amb
        " set a to old b
        normal `cma
    endif

    exe "normal `ba" . a:s2 . "\<ESC>`ai" . a:s1 . "\<ESC>"
endfun

Surround also works for a selection over more than one line.
before: bla bla Selec
ted Text bla bla
:'<,'>call Surround('"', '"')<CR>
after   :  bla bla "Selec
ted Text" bla bla

Some handy mappings:
vnoremap _" :call Surround('"', '"')<CR>
vnoremap _( :call Surround('(', ')')<CR>
vnoremap _[ :call Surround('[', ']')<CR>
vnoremap _{ :call Surround('{', '}')<CR>

I defined it as a command to perform fast on-demand-surroundings
command! -range -nargs=* Sur call Surround(<f-args>)

before: bla bla Selected Text bla bla
:'<,'>Sur (<\ - -\ >)
after   : bla bla (< -Selected Text- >) bla bla

Hope this helps somebody else.

VimTip 989: Word wrap without line breaks
http://vim.sourceforge.net/tip_view.php?tip_id=

When editing a text file, if you want word wrapping, but ONLY want line breaks inserted when you explicitly press the enter key, as with some of mine where my parser only understands that 1 line = 1 paragraph,

:set formatoptions=l
:set lbr

lbr tells vim to word wrap visually, but formatoptions=l tells vim to not insert hard newlines when you edit the middle of a 'paragraph.'  This is almost exactly the behavior of Notepad, Wordpad, Word, and other Microsoft products, possibly the only thing I like about them.  Be sure to set formatoptions in your .vimrc _after_ setting compatibility options, or even near the end of your .vimrc.  Check with

:set formatoptions

...on the : line to make sure it didn't get reset to something stupid like formatoptions=tcq.  =l is what you're going to want.  And lbr to do word wrapping.

VimTip 990: Repeat last :command
http://vim.sourceforge.net/tip_view.php?tip_id=

The last command entered at the ':' can be repeated with @: and further repeats can be done with @@
Useful for commands like e.g. :bnext or :cNext.

VimTip 991: Make views automatic
http://vim.sourceforge.net/tip_view.php?tip_id=

+

Hey folks,

As you know, you can use :mkview to save folds and such when you close a file--but you have to use :loadview next time you use the file.

With two lines in your .vimrc, you can make that automatic.

I got all excited to post this, then found a tip that already mentioned it, back in 2001:
vimtip #122 "Skip blank lines when folding text."  As he put it:

[snip]
And as an added bonus, for those new to text folding, add this to your .vimrc file too:

autocmd BufWinLeave *.* mkview
autocmd BufWinEnter *.* silent loadview

That way whatever folds you set won't get lost when you quit.  I had that happen after spending 15 minutes folding up a 3000+ line file.  Happy vimming!
[/snip]

There you go.

VimTip 992: Very simple shortcut to the helpgrep command
http://vim.sourceforge.net/tip_view.php?tip_id=



 The 'helpgrep' command is very useful for searching through all
 the files located in the .vim/doc directory. This command is especially
 useful if your .vim/doc directory is littered with script documentation
 aswell as language specific documentation such as provided by vimscript #614,
 vimtip #826 or vimscript #1330.

 The following abbreviation provides faster access to 'helpgrep'

    cnoabbrev H helpgrep


 This allows me to type :H<space>uganda to search for the word
 'uganda' in all of the help files.









VimTip 994: manipulate quotes with <CR> and <BS>
http://vim.sourceforge.net/tip_view.php?tip_id=

In java I found that I rarely needed to insert a carriage return in the middle of a string without first adding a "+ to the end. Also I found that when deleting the opening quote of a string which is part of a longer string I almost always indent to connect it back up to the previous line. So here was my solution. This is my first attempt to make something like this with VIM so the coding might be a bit messy, but it gets the job done.

For example when typing this in:

String s = "A very long string <cursor>

If you press enter at this point you will get

String s = "A very long string "+
  "<cursor>

At this point pressing backspace you will be back where you were before.

It's come in handy. Let me know.

" If the cursor is in the middle of a quote block when <CR> is pressed
" a quote is added to the end of the line followed by a plus, a <CR>
" and another quote.
function! Quotereturn()
	let before=strpart(getline(line(".")), 0, col(".")-1)
	"let after=strpart(getline(line(".")), col("."))
	if(before =~ '^\([^"]*"\([^"\\]\|\\.\)*"\)*[^"]*"\([^"\\]\|\\.\)*$')
		return "\"+\"\<Left>\<CR>\<Right>"
	else
		return "\<CR>"
	endif
endf
inoremap <CR> <C-R>=Quotereturn()<CR>

" If you backspace over a quote and it's a continuation fromanother line
" the two strings will be concatenated with quotes, spaces, and + removed.
function! Quotebackspace()
	if( (strpart(getline(line(".")), 0, col(".")-1) =~ '^\s*"$') && (getline(line(".")-1) =~ "\"+$") )
		return "\<Esc>d0kgJhhxxxi"
	else
		return "\<C-H>"
	endif
endf
inoremap <BS> <C-R>=Quotebackspace()<CR>

VimTip 995: Resise window when showing/hiding line numbers
http://vim.sourceforge.net/tip_view.php?tip_id=

When using

: set number

to add the showing of line numbers, your column alignment can be broken. However when you're in a window that supports it, the width of the window can be changed and as long as you've got enough screen real-estate to accomodate the extra columns your column alignment can be retained.

Add this to your .vimrc file

function! Toggle_num()
  if !exists("g:grow")
    let g:grow = 8
  endif
  set number!
  if &number
    exec "set columns+=" . g:grow
  else
    exec "set columns-=" . g:grow
  endif
endfunction

map <M-n> :call Toggle_num()<CR>

So each time you use META-n, line numbers will be toggled and the appropriate number of columns will be added or removed from your vim window.

I've tried this in Win32-gvim and Win32-vim and cygwin-vim (running in an xterm and rxvt).

VimTip 996: Fast jump to line that matches some regular expression
http://vim.sourceforge.net/tip_view.php?tip_id=

Last time I often use the following sequence of commands:
 g/rex/#
   <here I look through the list and choose the line I want, then I type its number as next command>
 <some-line-number>
I do it so often, that I at least decided to write the following command.

It does the following.

:[range]GJ[ump][!]/rex/

(Syntax is exactly as in :global except that you must NOT specify any commands after /rex/.  You may also use some other delimiter in place of "/", for example, ",").

It prints out numbered list of lines matching the /rex/ (or not matching, if you add '!').  Then it allows you to enter the number of line you need and moves cursor to that line.

Here you have this command.  Happy vimming!

"""""""""""""""""""""""""
command! -nargs=* -bang -range=% GJump <line1>,<line2>call GJump('<bang>',<q-args>)
function! GJump(bang,rex) range abort
    let lines = ''
    let i=1
    exe a:firstline ',' a:lastline 'g'.a:bang.a:rex.'echo substitute(strpart(i+1000000,1),"^0\\|\\(0\\@<=0\\)"," ","g") getline(".")|let i=i+1|let lines=lines.(line(".")+1000000)'
    while 1
      let nmr = input('Type in selected number, or just hit <Enter> to exit: ')
      if nmr == ''
        return
      endif
      let nmr = nmr+0 " Make string be number.
      if nmr>0 && nmr<i
        break
      endif
    endwhile
    let nmr = strpart(lines,(nmr-1)*7,7)
    let nmr = nmr-1000000
    silent exe nmr
endfunction

VimTip 997: saving made easy via mapping.
http://vim.sourceforge.net/tip_view.php?tip_id=

to save a file, we do , Escape , :w enter..
but for lazy bums like me, i want it to be done by pressing as many few keys as possible.
like F2.
add the following line in one of the files under the plugin directory,
map <F2> :w! <CR>  , and you can easily save files by pressing F2.
like this you can map several commands like make to different keys.

VimTip 998: HOWTO put boxes around comments in code
http://vim.sourceforge.net/tip_view.php?tip_id=

Though it is bad practice*, programmers sometimes try to put a box around comments in code, esp. function headers as in the example below (perl).
You can do this automatically by just selecting the text and a quick shortcut within vim for commants in any language.

First you need the "boxes" utility. Download and install the boxes utilities from http://boxes.thomasjensen.com/
You can get the source and compile it yourself or there is binary version available for almost all architectures.

Once you have this, the rest is pretty simple. Select the text you want to "boxify" and press F2.

Add the following mapping to your .vimrc

vmap <F2> "ad:enew<CR>"ap:w! c:\selected.txt<CR>:bde<CR><Esc>:r! boxes -dshell c:\selected.txt<CR><Esc>

This is for Windows and you should have boxes in your path (or put it in your winnt directory).
Linux users can change this as required.

EXAMPLE (Best viewed with courier font, size 10pt.)

---------Text to boxify-------

Subroutine   :TestFC
Description  :Runs flight controller test serially and
              genarates a test report
Argument     :$_[0] flight speed kmph, $_[1] wind drag
Returns      :File handle to test result

-----After boxify------------

##########################################################
# Subroutine   :TestFC                                   #
# Description  :Runs flight controller test serially and #
#               genarates a test report                  #
# Argument     :$_[0] flight speed kmph, $_[1] wind drag #
# Returns      :File handle to test result               #
##########################################################

For more details, see
[1] http://www.vmunix.com/vim/util.html
[2] http://boxes.thomasjensen.com/

Boxes has a configfile where you can specify the kind of boxes you want.
* This is a bad practice because, if you have to change the comments, you have to manually align it, thus wasting time.

VimTip 999: Maximize current window
http://vim.sourceforge.net/tip_view.php?tip_id=

Use F5 to maximize current window

Add this to your .vimrc

map <F5> <C-W>_<C-W><bar>

VimTip 1000: Change gui font
http://vim.sourceforge.net/tip_view.php?tip_id=

Use F3 to change font in gvim. Works in Windows only

map <F3> ^[:set guifont=*^M

VimTip 1001: Save a buffer without changing the file's "last modified" attribute
http://vim.sourceforge.net/tip_view.php?tip_id=

There are times when I change something in a file and I've no need for the file's "last modified" time to be changed.

This is often because I'm simply changing a comment in a source file and I don't need my build system to re-compile the file.

If your build of vim has +python you can define the following function and call it instead of using the write command

function! WritePreserveMtime()
python << EEOOFF
import vim
import os.path
import os
fpath = vim.current.buffer.name
atime = os.path.getatime(fpath)
mtime = os.path.getmtime(fpath)
vim.command("w")
os.utime(fpath, (atime, mtime))
EEOOFF
endfunction

See :help python for more help on calling Python from inside vim.

Since I

:map <F3> :w<CR><C-G>

I also

:map <S-F3> :call WritePreserveMtime()<CR><C-G>

VimTip 1002: Reverse lines in a file using !tac
http://vim.sourceforge.net/tip_view.php?tip_id=

Select a block visually and filter it through the unix command "tac" with ":!tac" to reverse the selected lines.

I have found it useful and easy to remember, especially when flipping the order of array definitions or in conjunction with reversing a previously ":!sort"-ed area.

Note: Related to vimtip #813 and vimtip #29, but shells out to unix instead of staying within vim.  The mnemonic for "tac" reversing lines in a file is that "tac" is "cat" reversed.

VimTip 1003: Open files with existing Gvim window in Windows
http://vim.sourceforge.net/tip_view.php?tip_id=

For example,

assoc .php=PHPFile
ftype PHPFile="C:\Program Files\Vim\Vim63\gvim.exe" --remote "%1"

then whenever you double click a .php file in explorer, it will be opened in existing Gvim window (or it will open new Gvim window if there is no already opened Gvim window).

VimTip 1004: Optionally open matching or selected tag in full height vertical window
http://vim.sourceforge.net/tip_view.php?tip_id=

First tip from me... after becoming a vim convert a while ago, I finally got around to trying to mangle tags in a way a like -- I prefer to have a full height window off to the right, most of the time. This script and mappings give both

" preview window... to get it to open vert right, or horiz as desired
function PreviewTag(top)
	"by MW
	set previewheight=25
	exe "silent! pclose"
	if &previewwindow			" don't do this in the preview window
		return
	endif
	let w = expand("<cword>")		" get the word under cursor
	exe "ptjump " . w
	" if any non False arg, open in simple horiz window so simply return
	if a:top
		return
	endif
	" otherwise, make it vertical
	exe "silent! wincmd P"
	if &previewwindow		" if we really get there...
		if has("folding")
			silent! .foldopen		" don't want a closed fold
		endif
		wincmd L " move preview window to the left
		wincmd p " back to caller
		if !&previewwindow	" got back
			wincmd _
                       " make caller full size (I use minibufexplorer and for some reason
                       " the window is altered by the preview window split and manipulation
                       " so wincmd _ sets it back... your mileage may vary
		endif
	endif
endfunction

" right hand window full height preview window
inoremap <C-]> <ESC>:call PreviewTag(0)<CR>
nnoremap <C-]> :call PreviewTag(0)<CR>
" simple "above the caller" preview window,
nnoremap <M-]> :call PreviewTag(1)<CR>
inoremap <M-]> <ESC>:call PreviewTag(1)<CR>
" close preview
noremap <M-[> <ESC>:pc<CR>

While I'm at it, here's what I'm using for Python and Quixote (python web framework) exctags generation (FreeBSD user here) - ptl files are Quixote Python Template Language files, essentially Python, and this exctags cmd line builds an appropriate tags file:

function WritePythonTags()
	let foo = system("/usr/bin/ctags --langmap=python:.py.ptl *.py *.ptl")
endfunction

" attempt to write / update tags file on every save...
" better way? not sure I care, its fast enuf.
au BufWritePost *.py,*.ptl call WritePythonTags()

VimTip 1005: escape and unescape HTML entities
http://vim.sourceforge.net/tip_view.php?tip_id=

if you add the following code to your .vimrc, you can escape your HTML entities (<, >, &) -> (&lt;, &gt;, &amp;) with one shortcut key.

:function HtmlEscape()
silent s/&/\&amp;/eg
silent s/</\&lt;/eg
silent s/>/\&gt;/eg
:endfunction

:function HtmlUnEscape()
silent s/&lt;/</eg
silent s/&gt;/>/eg
silent s/&amp;/\&/eg
:endfunction

vmap <silent> <c-h> :call HtmlEscape()<CR>
vmap <silent> <c-u> :call HtmlUnEscape()<CR>

VimTip 1006: Abbreviation: variable ++  --> variable = variable + 1
http://vim.sourceforge.net/tip_view.php?tip_id=

"if you type x ++ then x = x + 1 will appear on the screen.
"The same for x --.
ab ++ <Esc>1hdiw1hpa = <Esc>pa + 1
ab -- <Esc>1hdiw1hpa = <Esc>pa - 1

VimTip 1007: disable F1 built-in help key
http://vim.sourceforge.net/tip_view.php?tip_id=

It can be really annoying when you keep hitting F1 key by accident and help screen keeps popping up. Here is a solution:

:nmap <F1> :echo<CR>
:imap <F1> <C-o>:echo<CR>

(note: you can't just ":unmap <F1>" because Vim would complain that no such mapping exists)

You could still access help system via :help command or menu.

VimTip 1008: Toggle quickfix Window
http://vim.sourceforge.net/tip_view.php?tip_id=

Using this function & command:

command -bang -nargs=? QFix call QFixToggle(<bang>0)
function! QFixToggle(forced)
  if exists("g:qfix_win") && a:forced == 0
    cclose
    unlet g:qfix_win
  else
    copen 10
    let g:qfix_win = bufnr("$")
  endif
endfunction

Calling ':QFix' will "toggle" the quickfix open and closed.  It's easiest to map this to something fast.  I use:
nmap <silent> \` :QFix<CR>

If you want to force the window open, use ':QFix!' and the window will open or stay open.

VimTip 1009: AutoChange: Version of cw/c$ which snaps back to normal mode after finishing
http://vim.sourceforge.net/tip_view.php?tip_id=

This was in response to a problem stated at :

http://www.vi-improved.org/wiki/index.php/AutoChange

A request was made in #vim for there to be an automatic version of change. This would be a special version of change that would "snap" back to normal mode after a word or line is typed.
For example when using cw and c$, set it so that as soon as soon as enter (or space for cw) is pressed it goes into normal mode?

I was unable to edit the TwiKi page but these two mappings should do the trick:

nmap pw :inoremap <lt>Space> <lt>Space><lt>Esc>:iunmap <lt>lt>Space><lt>CR><CR> cw

nmap p$ :inoremap <lt>CR> <lt>CR><lt>Esc>:iunmap <lt>lt>CR><lt>CR><CR> c$

VimTip 1010: Chance C++ style comments to MISRA complient C style comments
http://vim.sourceforge.net/tip_view.php?tip_id=

Our current development requires everything to be MISRA compliant. One of the MISRA rules are: // style comments are not acceptable. These occurences must be replaced by /* style comments */. The following mapping will do this per line.

:map <Functionkey> /\/\/<enter>xxi/*<esc>A*/<esc>

where with Functionkey being a definable key. So with F5 as Functionkey, the map will be
:map <F5> /\/\/<enter>xxi/*<esc>A*/<esc>
This will do the action per found line. Start at the beginning of the file (:G1) And keep on firing <Functionkey> till the red message occurs at the bottom of the window :)

VimTip 1011: mappings and commands for visual mode + some bonus mappings to quickly copy and paste
http://vim.sourceforge.net/tip_view.php?tip_id=

For those who use Visual mode, here are some commands and mapping that may be
useful :
First of all 'gv' reselect the previous visual area.

prepare a :command on the previous visual selected area ('<,'> is not very fast to type...)
map <M-:> :'<,'>

copy the word under cursor in the clipboard
nnoremap <F4> "+yiw
copy the visual selected area in the clipboard (very easy)
vnoremap <F4> "+y
replace the word under cursor with the content of the clipboard
nnoremap <F5> viw"+p
replace the visual selected area with the content of the clipboard
nnoremap <F5> "+p

prepare the :command to replace the word under cursor
nnoremap <S-F4> "+yiw:%s/\<<C-r>+\>/<C-r>+/gc<LEFT><LEFT><LEFT>
prepare the :command to replace the selected area
vnoremap <S-F4> "+y:%s/\<<C-r>+\>/<C-r>+/gc<LEFT><LEFT><LEFT>

I use the clipboard but you can use whatever register you want ;-)

puts "" around the word under cursor
nnoremap <M-"> ciw"<C-r>+"<esc>
puts "" around the visual selected area
vnoremap <M-"> c"<C-r>+"<esc>

Happy vimming ;-)

VimTip 1012: Quoted Printable to Plain
http://vim.sourceforge.net/tip_view.php?tip_id=

Sometimes I pipe an E-mail into Vim and then I cannot read it because it is encoded in quoted printable. Mentioning this in my .vimrc helps:

function s:FromQuoPri( ) range
  exec a:firstline.",".a:lastline.'s/=\(\x\x\|\n\)/\=submatch(1)=="\n"?"":nr2char("0x".submatch(1))/ge'
endfunc
nnoremap <silent> <leader>Q  :0/^$/+1,$call <SID>FromQuoPri()<cr>
vnoremap <silent> <leader>Q  :call <SID>FromQuoPri()<cr>

The trick is to use a ranged function. Otherwise the = line continuations won't be substituted correctly.

VimTip 1013: Print all available characters (unicode)
http://vim.sourceforge.net/tip_view.php?tip_id=

Here's a fun one-liner to echo all available characters on your system. Just paste (Ctrl-* or Ctrl-+) the following single line at the command line:

let n = 0 | let i = 32 | let @x = "" | while n+i < 65535 | let @x = @x . nr2char(n+i) | if i % (&columns/2) == 0 | echo @x | let @x = "" | endif | let i = i + 1 | endwhile | echo @x

The line above works best if your system and font supports unicode (http://www.unicode.org). If not, reduce the 65535 upper limit to something smaller like 255 or 512.

VimTip 1014: Visual selection of indent block
http://vim.sourceforge.net/tip_view.php?tip_id=

This command will make a visual selection of the lines that have the same indent level or more as the current line. Somebody told me that this would be useful when programming Python.

:exe "normal V" | let temp_var=indent(line(".")) | while indent(line(".")+1) >= temp_var | exe "normal j" | endwhile

VimTip 1015: Preview file on localhost
http://vim.sourceforge.net/tip_view.php?tip_id=

Try this mapping in your .vimrc to
-Save current file
-Preview it on localhost

Edit the number of */ to fit your localhost installation eg. How much of the path to strip from the left.

It also assumes the file you are editing is within you localhost installation. Also I have only tested it
in bash

map <F8> :w^M:!mozilla `echo http://localhost/${PWD\#*/*/*/*/}/%`^M

JA.

VimTip 1016: Moving through camel case words
http://vim.sourceforge.net/tip_view.php?tip_id=

If you want to move through a camel case word, like CamelCaseWordWeWantToMoveThrough, word by word (eg from the 'C' on Camel to the 'C' on Case to the 'W' in word), you can add the following maps to assign Ctrl-right and Ctrl-left to do the job

(inspired by http://groups.google.com/group/comp.editors/browse_thread/thread/863891edbd961691/280b68b9686e346e%23280b68b9686e346e?sa=X&oi=groupsr&start=0&num=2)

imap <C-Right> :call search('\<\<Bar>\u', 'W')<CR>
imap <C-Left> :call search('\<\<Bar>\u', 'Wb')<CR>
map <C-Right> :call search('\<\<Bar>\u', 'W')<CR>
map <C-Left> :call search('\<\<Bar>\u', 'Wb')<CR>

VimTip 1017: Highlight text inside matching parentheses
http://vim.sourceforge.net/tip_view.php?tip_id=

Sometimes (specially when programming in lisp dialects) it's
useful to easily find matching parentheses. vim provides
the showmatch option but you need to (re)type the closing
parenthesis in order to find the opening one. Alternatively,
you can also type '%' over an already written parenthesis
so the cursor travel to its matching pair. This is almost ok,
but if you are inside a parenthesized form perhaps you
don't want to lose you current cursor position but just
to find the delimiting parenthesis and continue typing
(or whatever you were doing). So I find more convenient
to define the following simple key bindings:

nmap <a-key> m[%v%:sleep 350m<CR>`[

imap <a-key> <ESC>m[%v%:sleep 350m<CR>`[a

They simply put a mark, visit the opening parenthesis
with '%', enter visual mode (to highlight the parenthesized
block), travel to the closing parenthesis with '%', sleep
for a while and return to the mark. The second one is for
visual mode, so it enters normal mode first and returns
to visual mode via 'a' at the end. Of course, they both
work with (:), [:], {:} or whatever pairs the matchpairs
option happens to be setted to.
Personally I prefer <M-p> for the key.

VimTip 1018: Look up tags using regular expressions
http://vim.sourceforge.net/tip_view.php?tip_id=

I use tags a lot. I usually have one tag file per subsystem and I add and remove them from my tags variable when my "focus" changes.

Anyway, one circumstance that I find myself in some times is that I know a function exists and I have a good idea what it's called but can't remember the exact name.

Scenario: find the event handler function.

Ambiguity: is it handleEvent, HandleEvent, handle_the_event

Solution: Use regular expressions and command completion to guess

:tj /handle.*event<C-D>

When using the tag family of commands you can search through tags when the first character of the keyword you give to the command is /

When used in conjunction with command-line completion (using CTRL-D) you get "instant" feedback on whether your regular expression was close enough.

In a simpler scenario all tag searches using the / character are case insensitive, so even when used without a regular expression, / can help you find the tag you're looking for.

VimTip 1019: Keep indent for new lines
http://vim.sourceforge.net/tip_view.php?tip_id=

The help for autindent says:
...If you do not type anything on the new line except <BS> or CTRL-D and then type <Esc> or <CR>, the indent is deleted again...

This give some difficulties (at least for me :p) like
- if I type <Enter>, the cursor moves to the new line and indented, but when I type <Esc>, the indent is deleted (the cursor moves the the leftmost position)
- if I type <Enter>, and then paste something, the first line of the pasted text is not indented (the pasted text is not positioned from the cursor position).

To fix this, I use the mapping :
imap <CR> <CR> <BS>

At least, now if I pasted some text after pressing <Enter>, it starts from the current cursor position.

VimTip 1020: Auto end-quote html/xml attribute values as you type in insert mode
http://vim.sourceforge.net/tip_view.php?tip_id=

I often use Vim with the xml.vim plugin script from Devin Weaver (vimscript #301) for html/xml editing, however it seem to lack the auto-quoting of xml attribute values feature that you find in a lot of IDEs these days. So here is a simplistic but still pretty useful mapping tip you might want to add to your favorite xml plugin Vim script or vimrc:

inoremap " ""<LEFT>
inoremap ' ''<LEFT>

It simply replaces the double or single quotation mark character that you just typed with a pair of them and then moves the cursor in between the pair so you are ready to type the attribute's value.

This mapping can get annoying if you find yourself typing quote characters for reasons other than attributes, and you don't want the matching end-quote--you could make it better using a function along the lines of vimtip #102 to maybe only do it when the prior charater is an equal sign '=' , but I ended up liking it this simple way.

VimTip 1021: Use glimpse from within vim
http://vim.sourceforge.net/tip_view.php?tip_id=

To use glimpse to search your files instead of grep -r, you can use these mappings:

set grepformat+=%f:\ %l:%m
set grepprg=glimpse\ -nyH\ $HOME/indexdir\ $*
nnoremap <silent> \g :grep <cword><CR>:cwindow<CR>
nnoremap <silent> \G :!glimpseindex -F -H $HOME/indexdir -b ${PWD}<CR>

You must:
1. have glimpse installed on your system. (see webglimpse.net)
2. Precompile an index with glimpseindex. The mapping above lets glimpseindex decide which files to scan and puts the index in $HOME/indexdir. You can change that if you like.
3. Grep away using the mapping above or, alternatively:
:grep pattern

Searches are blinding fast with even large projects. By using the grepprg option, you get the benefit of using the quickfix window to browse through your search results.

VimTip 1022: Using folds like grep
http://vim.sourceforge.net/tip_view.php?tip_id=

It doesn't work exactly like grep, but I hope it will useful for someone:

:set foldmethod=expr
:set foldexpr=getline(v:lnum)!~\"regex\"

Now you can do zM and edit your grep result
Remember zR to go back

Thanks for vim !

VimTip 1023: exhance Ctrl-^: when there is no alternate file, go to next file, otherwise act as notmal Ctrl-^
http://vim.sourceforge.net/tip_view.php?tip_id=

" Ctrl-^ is very handy command in the normal mode. Ctrl-^
" switches to "alternate file". When there is no "alternate file",
" I wanted Ctrl-^ to jump to next file in the list.
" Insert following commands into your ~/.vimrc , then
" Ctrl-^ will be enhanced so that when there is no alternate file
" but there is next file, it will jump to the next file.

" {{{ my remapping of <C-^>. If there is no alternate file, then switch to next file.
function! MySwitch()
     if expand('#')=="" | : next
     else
         :exe "normal! \<c-^>"
    endif
endfu
map <C-^> :call MySwitch()<cr>
" }}} my remapping of <C-^>.

VimTip 1024: Put text to register while typing
http://vim.sourceforge.net/tip_view.php?tip_id=

This script is useful if you know that you'll need some peace of text again in this session

" You can just type <C-s> "type more" <C-s><choose register>
" to put "type more" into a register
" You can use <C-R>reg to insert it again from insert mode as widely known.

imap <C-s> <Esc>:call StartStopPuttingtoReg()<CR>a

function StartStopPuttingtoReg()
  if exists('b:isputtingtoreg')
    " copy . register to user defined register
    "
    echo "stop putting to reg"
    let reg=nr2char(getchar())
    unlet b:isputtingtoreg
    normal a
  else
    " go to insert mode
    echo "start putting to reg"
    let b:isputtingtoreg=1
    normal a
  endif
endfunction

VimTip 1025: Simple PHP Debugging Maps
http://vim.sourceforge.net/tip_view.php?tip_id=

Hi,

I use the following 4 maps

The first two just spit out the debug code and I hand type in any variables I want to display:-

iab phpb exit("<hr>Debug     ");

iab phpv echo "<hr><pre>";var_dump($a);exit("debug ");

The 2nd two automatically display any variables I have yanked into register 'a'
In fact I use this all the time. eg yank in all the parameters of a function

iab phpbb exit("<hr>Debug <C-R>a  ");

iab phpvv echo "<hr><pre>";var_dump(<C-R>a);exit("debug ");

Var_dump is used for displaying arrays (note the use of <pre>)

VimTip 1026: Resize xterm when running vimdiff
http://vim.sourceforge.net/tip_view.php?tip_id=

Below is a bash script that one can wrap vimdiff with. It will resize the width of ones
xterm so that vimdiff has a little more room. It uses xtermcontrol (which you will
have to download and build - its rather useful).

#!/bin/bash
#
# toggle xterm size when running vimdiff
#
# download xtermcontrol from: http://www.thrysoee.dk/xtermcontrol/
#

# where is vimdiff
VIMDIFF=/usr/local/bin/vimdiff

# get current xterm geometry
declare -r GEO=$( xtermcontrol --get-geometry )
#echo GEO=$GEO

# get width and increase by 50%
# Note: It would be better to get the full screen size and the font size
# of the current xterm. Then figure out the new width of the xterm that
# would fill the screen horizontally (new_width = screen_width / font_width).
# If you did this you would also have change the X,Y position of the
# xterm.
declare -i width=${GEO%%x*}
#echo width=$width
declare -i newwidth=$(( $width + $width / 2 ))
#echo newwidth=$newwidth

# get the rest of the geometry string (whats left after width and 'x')
declare -r therest=${GEO#*x}
#echo therest=$therest

# form new geometry string
declare -r NEWGEO=${newwidth}x$therest
# echo NEWGEO=$NEWGEO

# change xterm window size
xtermcontrol --geometry=$NEWGEO

$VIMDIFF $@

# reset xterm window size
xtermcontrol --geometry=$GEO

VimTip 1028: This tip will let vim  read tag files from all of the directories in your path
http://vim.sourceforge.net/tip_view.php?tip_id=

In my development environment,  I have several header files directories. I need
these directories to be both in my path, and in my tags list.

To accomplish this I use the following python based script:

In my development environment,  I have several header files directories. I need
these directories to be both in my path, and in my tags list.

set path=.,$_WINCEROOT/.,$_WINCEROOT/public/,$_WINCEROOT/public/common/oak/inc,$_WINCEROOT/public/common/ddk/inc,$_WINCEROOT/public/common/sdk/inc,$_WINCEROOT/private/cellcore/dtpt/inc
set tags=./tags,../tags,../inc/tags

function! BuildTagsFromPath()
python << EOF
import sys
import vim
paths = vim.eval("&path") # &path gets the option path.
pathsSplit = paths.split(",")

# prepend  original tag list before path.
tags = vim.eval("&tags")
for path in pathsSplit:
    tags +=  "%s/tags," % (path)

cmdSetTags = "set tags=%s" % tags
vim.command(cmdSetTags)
EOF
endfunction

call BuildTagsFromPath()

VimTip 1029: of the usefulness of the ". register
http://vim.sourceforge.net/tip_view.php?tip_id=

I sometimes want to insert text at the beginning of a line, but if I happen to already be at the beginning of that line, I use the i command instead of the I (capital i). Then, I realize that the same text has to be inserted at the beginning of other lines as well: I go there and hit ".", and the text gets inserted wherever I am in the line (which is of course seldom the beginning). So I have to "u"ndo, hit "I", retype my text and go one moving around and hit "." whenever I want the same text at the beginning of that line.

What bothers me is the retyping. I would like to change the "repeat last command", so that it becomes "insert at the beginning" instead of "insert wherever you happen to be".

Here comes the ". register. All I do now, is "u"ndo to remove the text that was wrongly inserted in the middle of the line, hit "I" to start inserting at the beginning of the line, then <C-R>. (that's Ctrl-R followed by a dot), which inserts whatever I had just inserted with the "i" command, and <esc>, of course.

Now the "repeat command" (.) will rightfully insert at the beginning of the lines where I invoke it, and I didn't have to retype my inserted text in full.

VimTip 1030: Show diff view of current buffer compared to the unmodified file
http://vim.sourceforge.net/tip_view.php?tip_id=

RichiH asked on #vim for a way to see a diff between the currently edited file and its unmodified version in the filesystem, here is a function/command to do this. Just put this in your .vimrc or in the plugins directory, open a file, make some modifications without saving them and do  :Diff  (or choose a better name if you like)

function! s:DiffWithSaved()
  diffthis
  new | r # | normal 1Gdd
  diffthis
  setlocal bt=nofile bh=wipe nobl noswf ro
endfunction
com! Diff call s:DiffWithSaved()

To get out off diff view you can use the :diffoff command on vim7 or the nodiff.vim script from vimscript #1198

VimTip 1031: Vim inside Java
http://vim.sourceforge.net/tip_view.php?tip_id=

If you would like to embed VIM inside your java application I found, that best way how to do it, is java terminal emulation. Download jta26.jar from http://javassh.org/space/start . Then start VIM from your java program and redirect STDIN and STDOUT to and from terminal emulator. For some unknown reason you have to use VIM without GUI support, mean GUI support isn't compiled into binary. You have to use pure terminal VIM. If you are interested in more details please send me an email to firstname.secondname AT gmail.com.

VimTip 1032: Decode MIME text using perl in vim
http://vim.sourceforge.net/tip_view.php?tip_id=



REQUIRES:  Vim 6.x with perl support
           Uses perl module MIME::Base64

  If you have MIME Base64 or Quoted-Printable encoded
  text in a vim buffer, the following commands can be
  used to replace the encoded lines with their decoded
  information.  Just visually select the lines
  corresponding to the encoded text and issue the
  appropriate command (:Decode64 or DecodeQP).

     command! -range=% Decode64 :w | <line1>,<line2>delete | let foo = @" | perl my $foo=VIM::Eval(foo); my ($r, $c)=$curwin->Cursor(); $curbuf->Append($r-1, split '\n', MIME::Base64::decode($foo));

     command! -range=% DecodeQP :w | <line1>,<line2>delete | let foo = @" | perl my $foo=VIM::Eval(foo); my ($r, $c)=$curwin->Cursor(); $curbuf->Append($r-1, split '\n', MIME::QuotedPrint::decode_qp($foo));

VimTip 1033: Toggling yes<->no
http://vim.sourceforge.net/tip_view.php?tip_id=

I'm bored of retyping things like 'ciwyes<Esc>' all the time when editing config files. So I define:

function s:ToggleYesNo()
  let w=expand("<cword>")
  if     w=="yes"    | let w="no"
  elseif w=="no"     | let w="yes"
  elseif w=="on"     | let w="off"
  elseif w=="off"    | let w="on"
  elseif w=="manual" | let w="auto"
  elseif w=="auto"   | let w="manual"
  else               | let w=""
  endif
  if w!=""
    exec "normal! \"_ciw\<C-R>=w\<cr>\<Esc>b"
  endif
endfunc
nnoremap gy  :call <SID>ToggleYesNo()<cr>

VimTip 1034: hungy backspace
http://vim.sourceforge.net/tip_view.php?tip_id=

I got tired of hitting the ENTER key by mistake and having to
backspace several times over the automatic indent function's indents.
I searched the internet and found this script which adds an
emacs-like hungry delete function that removes all whitespace back to
the previous "real" char.  Being a bad typist, it is easily my most
useful script addon.

Unfortunately, it only seems to work when the line contains no other
characters (which is the case if I just hit the ENTER key accidentally
and want to return to the end of the previous line).  If anyone knows
how to make it work in all circumstances, I would love to see the
changes.

I did not write this script and the author signed it only as "Scott",
but I got it from here:
http://groups.yahoo.com/group/vim/message/31991

function! GreedyBackspace()
let c = getline(line("."))[col(".") - 1]
if c == ' ' || c == "\t" || col("$") == 1
while c == ' ' || c == "\t" || col("$") == 1
if col("$") == 1
if line (".") == 1
break
endif
normal k$gJ
else
normal x
endif
let c = getline(line("."))[col(".") - 1]
endwhile
else
normal x
endif
endfunction
imap <> <Esc>:call GreedyBackspace()<CR>a

VimTip 1035: View NFO-files correctly
http://vim.sourceforge.net/tip_view.php?tip_id=

create a ftplugin for filetype *.nfo and include this line:
edit ++enc=cp437

cp850 might work, but some characters might be distorted then.

VimTip 1036: changing the color scheme.
http://vim.sourceforge.net/tip_view.php?tip_id=

In gvim , sometimes we change the default color scheme (say to morning) , but the next time we start gvim, this setting will be lost.
One way to retain this is by adding the following line in one of the vim scripts under the plugin directory >>
colorscheme <scheme_name>
for example:
colorscheme morning " for morning color scheme when gvim is started.

VimTip 1037: VIM sessions & Windows shell (creating project files with vim)
http://vim.sourceforge.net/tip_view.php?tip_id=

If you are often switching around different projects you may start to find it a pain to load the files you want to currently look at. This tip teaches you how to create vim session files and then shows you how to create some registry entries that will allow you to launch the vim session directly from the Windows shell by double clicking on the icon.

1. Load the files you want to pull into a project. This can be as many or as few as you want. I like to organize my vim sessions along the various modules I'm working on.

2. Save the session by typing :mkession <path> (remember to use the tab key for auto path completion and saving files to your desktop is only a few tabs away)

3. Give the session an extension you will continue to use for all your extensions. I use .vis (VIm Session)

Save the following into a .reg text file. Remember to change the .vis extensions in the file to the one you picked.
===========================================
Windows Registry Editor Version 5.00

[HKEY_CLASSES_ROOT\vim_source_file\shell\edit\command]
@="C:\\Program Files\\Vim\\vim64\\gvim.exe -c \":source %1\""

[HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.vis\OpenWithList]
"a"="NOTEPAD.EXE"
"MRUList"="ab"
"b"="gvim.exe"

[HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.vis\OpenWithProgids]
"vim_source_file"=hex(0):

[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\.vis]
@="vim_source_file"

[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\.vis\OpenWithList]

[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\.vis\OpenWithList\gvim.exe]
===========================================

Session files make working with many files at a time much more enjoyable.  To remove this registry change delete the registry keys that have the new association.

VimTip 1038: Search for selected text
http://vim.sourceforge.net/tip_view.php?tip_id=

You'll probably know about the '*' command, that search for the word under the cursor.
But sometimes I want to search for two words, or an expression, or just a few characters, and I have to press '/' and copy them by hand.
Now, with this map I can just select the text and press '*'.

:vnoremap * y/<C-R>"<CR>

It first copies the selection to the unnamed register, and then pastes it into the search line.

Did you know that '#' works just like '*' but backwards?
So, just for completeness, this does the same with selections:

:vnoremap # y?<C-R>"<CR>

PD: For some reason, in gvim, the * in the numeric keypad doesn't get vmapped. Is it a bug?

Regards.
Rodrigo.

VimTip 1039: disable all auto-indenting with 'set nopaste' mode (so that imap work)
http://vim.sourceforge.net/tip_view.php?tip_id=

The 'set paste' disables autoindenting, but the downside
is that imaps (insertion-mode maps) do not work.

I needed the imap-s to work *and* autoindenting disabled, together.

This means I had to disable all autoindenting *and* have 'set nopaste'.
This combination turned out surprisingly difficult to grok.  Finally I
found the 6 relevant options, and the proper autocommand to
resists persistent attempts of filetype-scripts to turn the autoindenting on.

Here is the solution that finally worked for me:

" {{{ begin disable-autoindent-with-nopaste stuff
set noai noautoindent nocin nocindent nosi nosmartindent nopaste
au BufWinEnter * :set noci nocindent indentexpr= indentkeys=
map \a :call ShowAutoIndent()<cr>
fu! ShowAutoIndent()
    20verbose set ai? cin? si? paste? indentexpr? indentkeys?
endfu
" }}} disable-autoindent-with-nopaste

If indenting is *still* not disabled, you can diagnose the problem
using the \a, or :call ShowAutoIndent()<cr>. This will show you
which script turned autoindenting back on.

The 'correct' output (all autoindenting disabled) shall look like this:
  noautoindent
  nocindent
  nosmartindent
  nopaste
    indentexpr=
    indentkeys=

VimTip 1040: Good leading and trailing whitespace highlighting
http://vim.sourceforge.net/tip_view.php?tip_id=

highlight WhiteSpaceEOL ctermbg=darkgreen guibg=lightgreen
match WhiteSpaceEOL /^\s*\ \s*\|\s\+$/
autocmd WinEnter * match WhiteSpaceEOL /^\s*\ \s*\|\s\+$/

Put the above lines in your .vimrc, and you can enjoy highlighting of trailing whitespace and also highlighting of any leading whitespace consisting of spaces.
Basically, no highlighting will occur if your leading whitespace is *only* tabs and there is no trailing whitespace.

VimTip 1041: Snippets for JavaScript, HTML and Python
http://vim.sourceforge.net/tip_view.php?tip_id=

The Vim Code:
========================================================
   "You can use <c-j> to goto the next <++> - it is pretty smart ;)


   "JavaScript
   autocmd BufRead,BufNewFile *.tmpl,*.htm,*.js inorea <buffer> cfun <c-r>=IMAP_PutTextWithMovement("function <++>(<++>) {\n<++>;\nreturn <++>;\n}")<cr>
   autocmd BufRead,BufNewFile *.tmpl,*.htm,*.js inorea <buffer> cfor <c-r>=IMAP_PutTextWithMovement("for(<++>; <++>; <++>) {\n<++>;\n}")<cr>
   autocmd BufRead,BufNewFile *.tmpl,*.htm,*.js inorea <buffer> cif <c-r>=IMAP_PutTextWithMovement("if(<++>) {\n<++>;\n}")<cr>
   autocmd BufRead,BufNewFile *.tmpl,*.htm,*.js inorea <buffer> cifelse <c-r>=IMAP_PutTextWithMovement("if(<++>) {\n<++>;\n}\nelse {\n<++>;\n}")<cr>

   "HTML
   autocmd BufRead,BufNewFile *.tmpl,*.js,*.htm inorea <buffer> cahref <c-r>=IMAP_PutTextWithMovement('<a href="<++>"><++></a>')<cr>
   autocmd BufRead,BufNewFile *.tmpl,*.js,*.htm inorea <buffer> cbold <c-r>=IMAP_PutTextWithMovement('<b><++></b>')<cr>
   autocmd BufRead,BufNewFile *.tmpl,*.js,*.htm inorea <buffer> cimg <c-r>=IMAP_PutTextWithMovement('<Â¿mg src="<++>" alt="<++>" />')<cr>
   autocmd BufRead,BufNewFile *.tmpl,*.js,*.htm inorea <buffer> cpara <c-r>=IMAP_PutTextWithMovement('<p><++></p>')<cr>
   autocmd BufRead,BufNewFile *.tmpl,*.js,*.htm inorea <buffer> ctag <c-r>=IMAP_PutTextWithMovement('<<++>><++></<++>>')<cr>
   autocmd BufRead,BufNewFile *.tmpl,*.js,*.htm inorea <buffer> ctag1 <c-r>=IMAP_PutTextWithMovement("<<++>><cr><++><cr></<++>>")<cr>

   "Python
   autocmd BufNewFile,BufRead *.py inorea <buffer> cfun <c-r>=IMAP_PutTextWithMovement("def <++>(<++>):\n<++>\nreturn <++>")<cr>
   autocmd BufRead,BufNewFile *.py inorea <buffer> cclass <c-r>=IMAP_PutTextWithMovement("class <++>:\n<++>")<cr>
   autocmd BufRead,BufNewFile *.py inorea <buffer> cfor <c-r>=IMAP_PutTextWithMovement("for <++> in <++>:\n<++>")<cr>
   autocmd BufRead,BufNewFile *.py inorea <buffer> cif <c-r>=IMAP_PutTextWithMovement("if <++>:\n<++>")<cr>
   autocmd BufRead,BufNewFile *.py inorea <buffer> cifelse <c-r>=IMAP_PutTextWithMovement("if <++>:\n<++>\nelse:\n<++>")<cr>

   "Presse c-q insted of space (or other key) to complete the snippet
   imap <C-q> <C-]>

Explanation:
========================================================
If you in a Javascript document type cfun<C-q> then this will be unfolded to:
function |(<++>) {
<++>;
return <++>;
}

| is where the text indicator is.
<++> are place-holders. You can press <C-j> to get to the next <++> and edit there.
This approach makes it very fast to create new functions, if-else statements etc.

It reduces the movement and you get pretty addicted to these snippets.

It's very easy to create similar snippets for other languages.

Requirement:
========================================================
I have used the modified version of imaps.vim...
The modified version of imaps.vim is found in the LaTeX-Suite package and it can be downloaded from my own site (http://amix.dk/vim/imaps.vim). This script gives the needed functionality.

My vimrc:
========================================================
While I am at it I have also uploaded my very good documented vimrc (it's about 800 lines). Check it out at http://www.amix.dk/vim/vimrc.html

Cya,
4mix

VimTip 1042: use maven with quickfix
http://vim.sourceforge.net/tip_view.php?tip_id=

Using maven with quickfix is pretty simple, just add:

compiler ant
set makeprg=maven\ -q\ -f\ project.xml\ jar:install

to your .vimrc. I use the jar:install goal but java:compile will suffice.

VimTip 1043: joinging two lines of text throughout a document
http://vim.sourceforge.net/tip_view.php?tip_id=

let's say you copy and pasted a bunch of output from CVS like this:

/opt/data/cvs/ofc/ofc/R1/wlthmgmt/common/feeds/state/logship.state.conf,v  <-- logship.state.conf
new revision: 1.4; previous revision: 1.3
done
Checking in statemch/logship.statemch.conf;
/opt/data/cvs/ofc/ofc/R1/wlthmgmt/common/feeds/statemch/logship.statemch.conf,v  <--  logship.statemch.conf
new revision: 1.4; previous revision: 1.3
done
Checking in swift/logship.swift.conf;
/opt/data/cvs/ofc/ofc/R1/wlthmgmt/common/feeds/swift/logship.swift.conf,v  <-- logship.swift.conf
new revision: 1.3; previous revision: 1.2
done
Checking in tmark/logship.tmark.conf;
/opt/data/cvs/ofc/ofc/R1/wlthmgmt/common/feeds/tmark/logship.tmark.conf,v  <-- logship.tmark.conf
new revision: 1.4; previous revision: 1.3

and you want to submit the filename and revision as a promotion request . . !
you can do a bunch of ":s/foo//" commands to get rid some of the junk there, and a ":g/^Check/d" and ":g/^done" to get rid of the extranneous line and you be left with maybe something like this in the end:

wlthmgmt/common/feeds/bank53/logship.53.conf
 -- 1.4 -- install
wlthmgmt/common/feeds/bankamer/logship.bankamer.conf
 -- 1.2 -- install
wlthmgmt/common/feeds/bankamer/logship.pos.conf
 -- 1.4 -- install
wlthmgmt/common/feeds/bankamer/logship.txn.conf
 -- 1.5 -- install
wlthmgmt/common/feeds/bny/logship.bny.conf
 -- 1.3 -- install

What would you do to "join" the lines with filenames with lines with versions and commands?  What *would* you do!?

g/conf/j

it could be anything on the line with the filename on it, but you want to say globally search for "whatever" (conf) in this case, and do the ex/ed command "j" on it which joins it with the next line

VimTip 1045: great wildmode/wildmenu and console mouse
http://vim.sourceforge.net/tip_view.php?tip_id=

set wildmenu
set wildmode=list:longest,full

Put those two in your .vimrc, and you'll enjoy the greatest wildmode that isn't fully documented in the vim help.
"set wildmenu" first enables a menu at the bottom of the vim/gvim window.
The meaning of "list:longest,full" is so that when you do completion in the command line via tab, these events will happen:
1. (on the first tab) a list of completions will be shown and the command will be completed to the longest common command.
2. (on second tab) the wildmenu will show up with all the completions that were listed before.

To test it out, type ":spe" and then hit tab once to see 1 and hit tab again to see 2.

set mouse=a

Put that line in your .vimrc to enable full mouse support in the console.
This way you won't have to wait for gvim's excessively long startup (1.5 secs) and just run vim in an xterm, having full mouse/scrollwheel support.

With both the above features, vim in the console is practically just as good as gvim. (":emenu" command could be used to access the gvim menus)

VimTip 1046: Whitespace hungry backspace/delete
http://vim.sourceforge.net/tip_view.php?tip_id=

I saw a tip the other that came close, and I was intrigued.  So I think I figured out good whitespace hungry delete.

imap <bs> <esc>d?\S?e1<cr>i

In short, it deletes from the cursor position backwards in the file until it finds the first non-whitespace character and then changes the match end offset to avoid deleting that non-whitespace char.  Let me know what you think.

VimTip 1048: add classname based on filename while in input mode
http://vim.sourceforge.net/tip_view.php?tip_id=

I often copy or rename java files and then go in and have to change the name of the class to match the filename (minus the path to the file and the .java extension).  To do this I added an abbreviation.  I chose ,f as the abbreviation, but you can use anything.  To try this out put the following lines in your _vimrc or just run it at the : prompt to play with it.

" classname (the filename minus the path and extension)
iab <unique> ,f <c-r>=fnamemodify(getreg('%'), ':r')<cr>

<c-r>= is Control-R followed by the equal sign.  This is very useful in input mode.  getreg() gets the contents of the % register which has the filename (which may or may not have the full path depending on how you loaded the file).  :r is is a filename modifier that removes the path and the extension (:help filename-modifiers for more info).

I believe this may work in older versions of Vim, but I use it in 6.3 and 6.4.

VimTip 1050: Join Up
http://vim.sourceforge.net/tip_view.php?tip_id=

Let's say you have some C or Java that looks like this:

// get the age of the person
age = person.getAge();

If you want to compact your code a bit you might want to stick the comment at the end of the statement instead of on its own line.  Essentially you want to "join up":

<map> <CS-j> ddpkJk

Used on the example above, you will now have:

age = person.getAge(); // get the age of the person

VimTip 1051: Buffers in GVIM
http://vim.sourceforge.net/tip_view.php?tip_id=

When working with GVIM, I like to "tear off" the buffermenu to keep track of my open buffers.
You can do this very quick by hitting: Alt-b [enter]
The floating buffermenu will be positioned at your mouse cursor.

You can also automate this by putting this in your .vimrc file:
au VimEnter * :te Buffers

To open a file in a new buffer instead of opening a new window everytime:
- When opening files in Windows Explorer: read vimtip #1003: Open files with existing Gvim window in Windows
- When opening files in Cygwin: add this to your .bashrc : alias vi='gvim --remote-silent'
- When opening files in a DOS window add this to your doskey configuration: vi=gvim --remote-silent $*

When working in VIM, I recomend you use the minibuffer explorer: minibufexpl.vim : Elegant buffer explorer - takes very little screen space

VimTip 1052: Autoselect the right compiler using the filetype
http://vim.sourceforge.net/tip_view.php?tip_id=

Every time you edit a file you have to set the right type of compiler for this file, one solution is to edit the file for your language in ftplugin and add a compiler statement.
But there's an easier solution. Why not use the name of the type of file to set the right compiler on-the-fly and each time a file is open ? It's as simple as this :

Modify your vimrc and add this line :

au BufRead * try | execute "compiler ".&filetype | catch /./ | endtry

This runs a the compiler command each and every time a file is open and set the compiler to the filetype which was determined by the file type scripts. If there's no compiler for the filetype you're editing it just fails silently and does not show the list of available compilers

VimTip 1053: Lookup word in dict
http://vim.sourceforge.net/tip_view.php?tip_id=

Hi,

put this in your vimrc to lookup the inner or selected word in dict. Please adjust latin1 to your encoding.

nnoremap ,l mayiw`a:exe "!dict -P - $(echo " . @" . "\| recode latin1..utf-8)"<CR>
vnoremap ,l may`a:exe "!dict -P - $(echo " . @" . "\| recode latin1..utf-8)"<CR>

VimTip 1054: Modified undo behavior
http://vim.sourceforge.net/tip_view.php?tip_id=

I was getting frustrated with the default undo behavior (undo the last change) in vim because sometimes one of my "changes" would be very long (ex. many lines; and I would want to undo one line at a time). So I came up with the idea to change the behavior with the following code that can be inserted into your .vimrc:

function! EnterStuff()
	let theLine = getline(line("."))
	let pos = col("'^")
	execute "normal mqu\<C-r>`q"
	if(pos > len(theLine))
		startinsert!
	else
		if(pos > 1)
			normal l
		endif
		startinsert
	endif
endfunction
function! ChangeUndoMode(theNum)
	if(a:theNum == 1)
		inoremap <C-w> <C-w>^O^[
		inoremap <Enter> <ESC>:call EnterStuff()<Enter><Enter>
	elseif(a:theNum == 2)
		inoremap <C-w> <C-w>^O^[
		inoremap <BS> <BS>^O^[
		inoremap <DEL> <DEL>^O^[
		inoremap <Enter> <ESC>:call EnterStuff()<Enter><Enter>
	else
		iunmap <C-w>
		iunmap <BS>
		iunmap <DEL>
		iunmap <Enter>
	endif
endfunction
call ChangeUndoMode(1)
nmap \sun :call ChangeUndoMode(1)<Enter>
nmap \gun :call ChangeUndoMode(2)<Enter>
nmap \bun :call ChangeUndoMode(3)<Enter>

Be sure to write "^O^[" as two characters: ctrl-o and ESC.

So the above code works fairly well. <C-w>, <BS>, <DEL>, <ENTER> all add to the undo list. The <ENTER> one took me a long time to figure out. The way it is done in the above code is the only way I know that doesn't mess up indentation. ^O^[ automatically screws up indentation. If anyone can figure out a better way to accomplish <ENTER> adding to the undo list, please post.

VimTip 1055: Faster directory browsing from command line
http://vim.sourceforge.net/tip_view.php?tip_id=

I have made some mappings that makes directory browsing faster from the commandline.

Here is the usage of $c:
Imagine you are editing "~/Desktop/project/view/core/admin/MenuEdit.tmpl" and the cwd (current working directory) is "~/Desktop/project".
Now imagine that you need to edit something else in the MenuEdit directory (admin dir), but you don't want to change the cwd.
Then you go-to the vim commandline and press $c, and it will transform to "e ~/Desktop/project/view/core/admin/".
I.e. the $c expands to "e " + The directory of the current file.

I also found out that I sometimes needed to go to a parent directory from the commandline and I found it really tiring to use backspace.
Here is the usage of <C-q>:
Imagine you are editing "~/Desktop/project/view/core/admin/MenuEdit.tmpl" and you would like to step to core/ directory to edit a file there.
Enter commandline and press $c, then press <C-q><C-q>, your commandline should then be  "e ~/Desktop/project/view/core/".
I.e. the <C-q> on commandline deletes text till last slash.

Why use this?
It's nice to have when working on bigger projects. It's especially useful for MVC (model, view and controller) kind of applications - - where the different parts are split in different directories.
It's also useful in Java application where you have source in one directory and tests in another.

func! Cwd()
   let cwd = getcwd()
   return "e " . cwd
endfunc

func! DeleteTillSlash()
   let cmd = getcmdline()
   let cmd_edited = substitute(cmd, "\\(.*/\\).*", "\\1", "")
   if cmd == cmd_edited
       let cmd_edited = substitute(cmd, "\\(.*/\\).*/", "\\1", "")
   endif
   return cmd_edited
endfunc

func! CurrentFileDir()
   return "e " . expand("%:p:h") . "/"
endfunc

cno $c e <C-\>eCurrentFileDir()<cr>
cmap <C-q> <C-\>eDeleteTillSlash()<CR>

VimTip 1058: Selecting changes in diff mode
http://vim.sourceforge.net/tip_view.php?tip_id=

Assumption: 2-window vertical diff mode

The idea: Use c] and c[ to go to a specific change. Then use M-, and M-. to patch using the version on the left or right respectively. The cursor is then positioned in the file that changed for ease of saving, etc.

I find this more intuitive than using diffput and diffget because I no longer need to remember which window the cursor is in.

The code:
function! DiffTake(dir, oppdir)
    let l:old = winnr()
    exec "wincmd ".a:dir
    " Assumption: just 2 windows side by side.
    if (winnr() == l:old)
        diffput
        exec "wincmd ".a:oppdir
    else
        wincmd p
        diffget
    endif
endfunction

function! SetupDiffMappings()
    if &diff
        map <Esc>, :call DiffTake("h", "l")<CR>
        map <Esc>. :call DiffTake("l", "h")<CR>
    endif
endfunction

" vim -d
call SetupDiffMappings()
" Entering diff mode from within vim - diffsplit, etc.
autocmd FilterWritePost * call SetupDiffMappings()

VimTip 1059: Save each line of a text in separated numbered files
http://vim.sourceforge.net/tip_view.php?tip_id=

Create this function

function! SaveLines()
	execute line(".") . "w " . line(".") . ".xml"
endf

And call it

%call SaveLines()

The generated files are:
1.xml
2.xml
...

each containing a single line.

VimTip 1061: SmartHome & SmartEnd over wrapped lines
http://vim.sourceforge.net/tip_view.php?tip_id=

The Smart Home function allows the cursor to toggle between the start position and the first non-whitespace character position of the line. This is useful for skipping past indentation, whether it be tabs or spaces. Likewise, the Smart End function toggles past trailing whitespaces at the end of a line.

This topic has been discussed before: "Smart <home>" vimtip#315

The reason I am bringing this up again is because previous implementations of the Smart Home functionality have not worked well over lines that are wrapped. The implementation below works pleasingly well even when lines are wrapped, stepping through the wrapped lines by <Home> or <End> one by one. It also solves the "<Home> for one character on a line" insert mode problem, and is Replace mode friendly.

Of course, cursor positioning can be achieved via vanilla Vim way: using 0, ^, g0, g$, g_, etc. but it's easier and faster when two keys take care of all of the functions. Especially over wrapped lines.

=====
"place in vimrc
nmap <silent><Home>      :call SmartHome()<CR>
nmap <silent><End>       :call SmartEnd()<CR>
imap <silent><Home>       <C-r>=SmartHome()<CR>
imap <silent><End>         <C-r>=SmartEnd()<CR>
vmap <silent><Home> <Esc>:call SmartHome()<CR>msgv`s
vmap <silent><End>  <Esc>:call SmartEnd()<CR>msgv`s

""""""""""""""""""""
"smart home function
function SmartHome()
  let curcol = col(".")

  "gravitate towards beginning for wrapped lines
  if curcol > indent(".") + 2
    call cursor(0, col(".") - 1)
  endif

  if curcol == 1 || curcol > indent(".") + 1
    if &wrap
      normal g^
    else
      normal ^
    endif
  else
    if &wrap
      normal g0
    else
      normal 0
    endif
  endif

  return ""
endfunction

"""""""""""""""""""
"smart end function
function SmartEnd()
  let editmode = (mode() == "i" || mode() == "R")
  let curcol = col(".")
  let lastcol = editmode ? col("$") : col("$") - 1

  "gravitate towards ending for wrapped lines
  if curcol < lastcol - 1
    call cursor(0, col(".") + 1)
  endif

  if curcol < lastcol
    if &wrap
      normal g$
    else
      normal $
    endif
  else
    normal g_
  endif

  "correct edit mode cursor position, put after current character
  if editmode
    call cursor(0, col(".") + 1)
  endif

  return ""
endfunction
=====

VimTip 1063: Send results of a g// to a new window
http://vim.sourceforge.net/tip_view.php?tip_id=

" .vimrc
nmap <F3>  :redir @a<CR>:g//<CR>:redir END<CR>:new<CR>:put! a<CR><CR>

How to Use:-
perfect your g/regexp/
The when you are satisfied hit <F3>

Explanation:-
:redir @a            redirect output to register a
:g//                    repeat last global command
:redir END          end redirection
:new                  create new window
:put! a                paste register a into new window

Idea  by Peppe (map by me zzapper)

VimTip 1064: C/C++ syntax folding with Vim 6
http://vim.sourceforge.net/tip_view.php?tip_id=

DISCLAIMER: The C/C++ syntax scripts from Vim 7 CVS currently (as of 1/12 - 05) work fine with Vim 6, but it's possible that they might use commands that Vim 6 does not support in the future. Be sure to make backups before replacing any scripts.

Syntax folding is a very handy feature that makes Vim automatically create folds in a sensible way according to file type. In C/C++ files, for example, each function and other block will get its own fold. With these folds, it's easy to get an overview of your program by folding blocks you currently don't need to see. It also makes it very easy to move whole functions and other blocks around.

The commands that set the folding rules for a file type appear in its syntax script, which is usually located in $VIM/vim<version>/syntax. Note that VIM is not a shell variable. Do ':echo $VIM' in vim to find out its value (/usr/share/vim on my system).

Unfortunately, the C/C++ syntax scripts that come with Vim 6 do not define any syntax folding rules. These can however be replaced with the syntax files from Vim 7 that do. Go to Download->Development for instructions on getting the Vim 7 source from CVS. The scripts you need are in the folder vim7/runtime/syntax, namely c.vim and cpp.vim .

Replace the Vim 6 c.vim and cpp.vim files with the Vim 7 versions (don't forget to backup the old versions). Enable syntax folding with ':set foldmethod=syntax' and you should be set.

Happy folding!
Ulf

VimTip 1065: Mighty Mouse
http://vim.sourceforge.net/tip_view.php?tip_id=

As much as it is against the Vim-way of doing things, it would be nice to have the mouse do the right thing when it is used once in a while. This tip refines this previous tip:

[ "Use Alt+Mouse to select blockwise (MS Word like)" (vimtip#743) ] - for *GUI* Vim
Holding down Alt + dragging the left mouse button will activate the Visual Block, much like how MS Word works. Holding down Shift + dragging will switch it back to Visual mode, and vice versa. Insert-Visual[Block] mode is called if mouse highlight is activated from Insert mode. This tip also fixes some issues with the default Alt/Shift + clicking to make it work more seamlessly. Give it a try!

This tip also attempts to resolve an issue that was brought up in the Vim mailing list:

*Console/terminal* Vims that are not compiled with the +xterm_clipboard option (see :version) have trouble pasting from external sources. They are not able to access the clipboard, and have to make use of the middleclick paste function. Unfortunately, if the mouse option was set as ':set mouse=a', the middleclick paste will act funny. On the other hand, if the mouse option wasn't set, the middleclick paste would work fine but instead, many of the console mouse functionalities such as positioning, wheel-scrolling and window sizing would not work.

This is fixed by only allowing middleclick paste to work in Insert mode. Extended mouse functionalities are sacrificed in Insert mode but will work in other modes like Normal and Visual modes.When a middleclick paste is issued in Normal mode, it switches to Insert mode to do the paste. If it is issued in Visual mode, it cuts the highlighted text, and switches to Insert mode to do the paste to simulate a "paste over selection".

To avoid indentation when middleclick pasting: hit <F7> first to enable paste mode, middleclick, and hit <F7> again to disable paste mode (see :help 'paste')

=====
"place in vimrc
set nopaste
if has("gui_running")
  "mouse visual block (ala MS Word)
  nmap <A-LeftMouse> ms<LeftMouse><C-v>`so
  imap <A-LeftMouse> <Esc><C-v>`^ms<Esc>gi<LeftMouse><C-o><C-v>`so
  vmap <A-LeftDrag>  <LeftDrag>
  vmap <A-LeftMouse> <C-v><LeftMouse>msgv`s
  vmap <S-LeftMouse> v<LeftMouse>msgv`s
  set mouse=ra
else
  "paste toggle
  nmap <F7>      :set paste! paste?<CR>
  imap <F7> <C-o>:set paste!<CR>
  vmap <F7> <Esc>:set paste!<CR>gv
  "xterm mouse with middleclick paste
  nnoremap <MiddleMouse> i<MiddleMouse>
  vnoremap <MiddleMouse> s<MiddleMouse>
  set pastetoggle=<F7> mouse=rnv
  "choose either one
  set ttymouse=xterm
  "set ttymouse=xterm2
endif
=====

VimTip 1066: Quickly adding and deleting empty lines
http://vim.sourceforge.net/tip_view.php?tip_id=

When programming, I often find myself adding and deleting empty lines. The way I used to do it was to press o (or O) to open a new line, press Enter if I wanted additional lines, and then press ESC to exit insert mode. Often I wanted to find my way back to where I began the insertion, and so had to do a few kkk, jjj:s (this was before I discovered the '[ and '] motions). This was getting cumbersome, and so I came up with another mechanism.

The following remaps C-j to add empty lines below the cursor and C-k to remove empty lines below the cursor (you'll find these are intuitive "up/down" operations). A-k and A-j do the same thing above the cursor. Lines containing something other than whitespace are not deleted, and so the delete operations can be "hammered on" without risk. The cursor maintains its position in the window if possible. You should probably set scrolloffset to something other than 0 for optimum comfort.

function! AddEmptyLineBelow()
    call append(line("."), "")
endfunction

function! AddEmptyLineAbove()
    let l:scrolloffsave = &scrolloff
    " Avoid jerky scrolling with ^E at top
    " of window
    set scrolloff=0
    call append(line(".") - 1, "")
    if winline() != winheight(0)
        silent normal! ^E
    end
    let &scrolloff = l:scrolloffsave
endfunction

function! DelEmptyLineBelow()
    if line(".") == line("$")
        return
    end
    let l:line = getline(line(".") + 1)
    if l:line =~ '^\s*$'
        let l:colsave = col(".")
        .+1d
        ''
        call cursor(line("."), l:colsave)
    end
endfunction

function! DelEmptyLineAbove()
    if line(".") == 1
        return
    end
    let l:line = getline(line(".") - 1)
    if l:line =~ '^\s*$'
        let l:colsave = col(".")
        .-1d
	silent normal! ^Y
        call cursor(line("."), l:colsave)
    end
endfunction

noremap <silent> <C-j> :call AddEmptyLineBelow()<CR>
noremap <silent> <C-k> :call DelEmptyLineBelow()<CR>
noremap <silent> <A-j> :call DelEmptyLineAbove()<CR>
noremap <silent> <A-k> :call AddEmptyLineAbove()<CR>

Note that ^E and ^Y should be the real things and not entered with ^ and E/Y as separate cahracters. Press C-V C-E, C-V C-Y to insert them.

VimTip 1067: C like comment for PHP
http://vim.sourceforge.net/tip_view.php?tip_id=

When coding PHP, the ' * ' in multiline comments do not align correctly. It happened to be like this

/*
*
The cause is the indentexpr setting for PHP filetype. I do not know how to fix the indentexpr :p so I use this modeline when editing PHP files

// vim: tw=0 ts=4 sw=4 sts=4 formatoptions=qroct comments=sr\:/*,mb\:*,ex\:*/,\:// indentexpr=

and now the ' * 's can be (automatically) aligned like this ^_^

/*
 *

Is there any other (correct) way to do this ?

VimTip 1068: Fixing missing gvim context menu in windows
http://vim.sourceforge.net/tip_view.php?tip_id=

* Windows only *

OK, so you move your vim folder and suddenly the context menu 'edit with vim' that appeared when you right click on a file in explorer  is missing. To fix it, run regedit and set the following values into the 'corrent' one :

[HKEY_LOCAL_MACHINE\SOFTWARE\Vim\Gvim]
path=C:\Program Files\vim\vim64\gvim.exe

[HKEY_CLASSES_ROOT\CLSID\{51EEE242-AD87-11d3-9C1E-0090278BBD99}\InProcServer32]
(Default) = C:\Program Files\vim\vim64\gvimext.dll

VimTip 1070: Inline integer arithmatic
http://vim.sourceforge.net/tip_view.php?tip_id=

I do a lot of mathematical operations on data in text files, and I wanted a way to do it inline instead of having to copy it to a spreadsheet, perform the operations, and copy it back.  The following map the 4 keypad operators, plus, minus, multiply, divide, to their equivalent operation.  There's two versions, one for command mode and one for visual mode.

Problems:

I tried hard to get the cursor location to act the same for the multiply and divide as the built in add and subtract, but there's a few conditions where it doesn't.
It also clobbers your last search in the process.

If anyone can improve the multiply and divide command mode mappings, please post it here.

noremap <kMinus> <C-X>
vnoremap <silent><kMinus> :<C-U>'<,'>s%\(-\?\d\+\)%\=submatch(1) - v:count1%g<CR>:noh<CR>gv
noremap <kPlus> <C-A>
vnoremap <silent><kPlus> :<C-U>'<,'>s%\(-\?\d\+\)%\=submatch(1) + v:count1%g<CR>:noh<CR>gv
noremap <silent><kMultiply> :<C-U>s%\(-\?\d*\%#\d\+\)%\=submatch(1) * v:count1%<CR><C-O>h/\d\+/e<CR>:noh<CR>
vnoremap <silent><kMultiply> :<C-U>'<,'>s%\(-\?\d\+\)%\=submatch(1) * v:count1%g<CR>:noh<CR>gv
noremap <silent><kDivide> :<C-U>s%\(-\?\d*\%#\d\+\)%\=submatch(1) / v:count1%<CR><C-O> ?\d\+?e<CR>:noh<CR>
vnoremap <silent><kDivide> :<C-U>'<,'>s%\(-\?\d\+\)%\=submatch(1) / v:count1%g<CR>:noh<CR>gv

VimTip 1071: Simple placeholders
http://vim.sourceforge.net/tip_view.php?tip_id=

I was very impressed with the functionality of placeholders in the Latex-Suite
scripts vimscript #475
so I decided to add a similiar functionality to my .vimrc. I can't really say if it's done in a healthy way, I don't have that much experience with vim.

" A syntax for placeholders
" Pressing Control-j jumps to the next match.
inoremap <c-j> <ESC>/<++><CR><ESC>cf>

You could of course use any key-sequence for this.
I use it with my code for () completion.
It can be equaly well used with templates and other abbreviations.

" Completions using placeholders
"
inoremap ( ()<++><ESC>F)i
inoremap [ []<++><ESC>F]i
inoremap { {}<++><ESC>F}i

This doesn't care if the code is entered free or if it's inside a block of text. In which case I think it aught to not expand. But I find it helpfull none the less.

If someone has better ways to do any of this I'd be much obliged. =)
I'm quite sure there is one.

VimTip 1072: Shadow your Comments
http://vim.sourceforge.net/tip_view.php?tip_id=

       Sometimes you get bugged with all the comments in your working file.
       With all the Fixes and Patches and previous comments, code looks miserable.
        I don't know whether there is any better way of getting rid of Comments
        This is not a generic tip that will work for all color settings. I dont know
         how i will get the background color of the currently active theme.

        For those using Black background in VIm as I. they can use the following command
       :hi Comment guifg=black


        For those using White background can try this
       :hi Comment guifg=white

       Again for restoring  the previous comment color, i need the know the present Comment
       color ....You can put any other contrasting color to your comment to restore., or you can
       source your previous theme (but a time consuming deal).

        If someone helps me out to access different colors of group, i will attempt to write
a generic tip, which will work for all settings...

     anyway i hope this tip(although a simple one ) will help you out to  view Comments free code
and work efficiently.










VimTip 1073: Mathing valid IP address
http://vim.sourceforge.net/tip_view.php?tip_id=

classical regex ((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)

can be matched by the following code in ~/.vimrc due to colouring the IP addresses or whatever...

match ipaddr /\(\(25\_[0-5]\|2\_[0-4]\_[0-9]\|\_[01]\?\_[0-9]\_[0-9]\?\)\.\)\{3\}\(25\_[0-5]\|2\_[0-4]\_[0-9]\|\_[01]\?\_[0-9]\_[0-9]\?\)/

VimTip 1074: Detect encoding from the charset specified in HTML files
http://vim.sourceforge.net/tip_view.php?tip_id=

If one needs to edit files encoded in multiple legacy encodings, then the Vim fileencodings option cannot help much.  Some hacks can be used to put the file encoding in the file (see Tip #911).  However, in the case of HTML files, the encoding information is often in the HTML file already, esp. for non-Latin1 Web pages, i.e.:

<meta http-equiv="Content-Type" content="text/html; charset=gb2312">

The following code can be put in _vimrc to detect and use such encoding specification:

---- code begins -----
if has('autocmd')
  function! ConvertHtmlEncoding(encoding)
    if a:encoding ==? 'gb2312'
      return 'cp936'            " GB2312 imprecisely means CP936 in HTML
    elseif a:encoding ==? 'iso-8859-1'
      return 'latin1'           " The canonical encoding name in Vim
    elseif a:encoding ==? 'utf8'
      return 'utf-8'            " Other encoding aliases should follow here
    else
      return a:encoding
    endif
  endfunction

  function! DetectHtmlEncoding()
    if &filetype != 'html'
      return
    endif
    normal m`
    normal gg
    if search('\c<meta http-equiv=\("\?\)Content-Type\1 content="text/html; charset=[-A-Za-z0-9_]\+">') != 0
      let reg_bak=@"
      normal y$
      let charset=matchstr(@", 'text/html; charset=\zs[-A-Za-z0-9_]\+')
      let charset=ConvertHtmlEncoding(charset)
      normal ``
      let @"=reg_bak
      if &fileencodings == ''
        let auto_encodings=',' . &encoding . ','
      else
        let auto_encodings=',' . &fileencodings . ','
      endif
      if charset !=? &fileencoding &&
            \auto_encodings =~ ',' . &fileencoding . ','
        silent! exec 'e ++enc=' . charset
      endif
    else
      normal ``
    endif
  endfunction

  " Detect charset encoding in an HTML file
  au BufReadPost *.htm* nested      call DetectHtmlEncoding()
----  code ends  -----

Please notice that the nested autocommand is used to ensure the syntax highlighting is OK and the remembered cursor position is still kept.

It is recommended to use `set encoding=utf-8' in order to ensure successful encoding conversion.

VimTip 1075: beauty of gf - it can take a count
http://vim.sourceforge.net/tip_view.php?tip_id=

gf stands for "goto file"
it opens the file under cursor. it is very useful for opening include files. it searches for files in the directories set by path option
in my case, i have the same include file name in different folders (for different projects, let us say) and my path option includes all these folders.
SO whenever i use gf on include file, it was opening an include file (which is not the one i want to open).
while reading the help, i found that gf can take a count and it will open the count' th file that is found

try the following:
 gf
2gf
3gf etc

if there are several with the same names, one can give the count to open the exact file needed.

VimTip 1076: Hex or Unhex strings.
http://vim.sourceforge.net/tip_view.php?tip_id=

Here are a couple of handy searches that you can use to convert a hex string to unhexed string, or vice versa. I found these particularly helpful when debugging html, or writing/editing bookmarklets.

to convert hex to readable stuff ->
:s@%\(\x\x\)@\=nr2char('0x'. submatch(1))@g

to convert back to gobbledy gook.

:s@\([;()\{\}\[\]\+ ,\-><\|=%&^\\\/"']\)@\="%". ConvertToBase(char2nr(submatch(1)),16)@g

Note: You need Christian Robinson's base conversion function from here:

vimtop #54

VimTip 1077: Move Function Parameters with macro
http://vim.sourceforge.net/tip_view.php?tip_id=

"Move after next comma
  nmap ,mc "zdiWxf,a <esc>"zp

"Move until next parenthesis
  nmap ,mp "zdiWxf)hi, <esc>"zpx

Given:
   foo = compare( "first", second, theThird );

Putting cursor on "first" and ",mc" will move the "first" parameter after the following comma:
   foo = compare( second, "first", theThird );

Putting cursor on "second" parameter and ",mp" will move it to the parenthesis:
   foo = compare( "first", theThird, second );

This is similar to the old "xp" trick (which will trans(x)-pose two characters) with a delete and a put.  The parameter under the cursor is snipped with "diW" (delete Inner FullWord), which will include the comma.  To put it after a comma is simply a paste in the right spot (f,p).  To put it as the last parameter, you've got to add a comma to the last paramter and remove it's last comma.

This is dependent on spaces between parameters or will require some tweaking to match how you work.  BE CAREFUL AS IT WILL EAT YOUR CODE IF YOU DON'T WATCH IT CLOSELY!  I always had wanted a command to help me re-order parameters in method calls and it finally hit me how to do it in the general case.

Note: this tip will destructively modify the "z" copy/paste buffer, tips welcome on how to avoid that!  ;^)  In a little further testing, it looks like it also doesn't correctly deal with strings that have spaces, so be aware of that limitation as well.

--Robert

VimTip 1078: Best way to close (delete) buffer without closing its window
http://vim.sourceforge.net/tip_view.php?tip_id=

"delete the buffer; keep windows
function Kwbd(kwbdStage)
	if(a:kwbdStage == 1)
		let g:kwbdBufNum = bufnr("%")
		let g:kwbdWinNum = winnr()
		windo call Kwbd(2)
		execute "bd! " . g:kwbdBufNum
		execute "normal " . g:kwbdWinNum . ""
	else
		if(bufnr("%") == g:kwbdBufNum)
			let prevbufvar = bufnr("#")
			if(prevbufvar > 0 && buflisted(prevbufvar) && prevbufvar != g:kwbdBufNum)
				b #
			else
				bn
			endif
		endif
	endif
endfunction

-- That's a very simple function I wrote to enable someone to close the current buffer (like :bd) yet not close any associated windows with that buffer. I haven't seen anything easier and/or simpler than this. To use this function, just do :call Kwbd(1)

VimTip 1079: map <F3> to find exactly one word
http://vim.sourceforge.net/tip_view.php?tip_id=

map <F3> /\<\><left><left><c-r><c-w>
imap <F3> <esc>/\<\><left><left><c-r><c-w>

<esc>   exit insert mode
/     begin find
\<   begin word
\>   end word
<left> "two times" move cursor to \<"position"\>
<c-r><c-w> command get word under cursor to command line or find

VimTip 1083: Map caps-lock to ESC
http://vim.sourceforge.net/tip_view.php?tip_id=

I've always been annoyed about the $*@#! caps-lock key. Every now and then, I inadvertendly hit it instead of the TAB or SHIFT key. Attached is a windows registry file that maps the caps-lock key to the ESC key. Now, it is very easy to switch to command mode, even on notebooks and small keyboards. Of course, the real ESC key is preserved and works as it used to work.

Instructions:

    1. Paste the reg file contents below in a reg file (e. g. caps2esc.reg)
    2. Execute the reg file (e. g. by double-clicking it in Windows Explorer)
    3. Reboot
    4. Enjoy!

--------8<---------


Windows Registry Editor Version 5.00

[HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Keyboard Layout]
"Scancode Map"=hex:00,00,00,00,00,00,00,00,02,00,00,00,01,00,3a,00,00,00,00,00

--------8<---------

VimTip 1084: Setting Clearcase View as the title of the gvim window
http://vim.sourceforge.net/tip_view.php?tip_id=

When working in clearcase,
    It would be very useful to set the title of the window to the view from which we are opening the gvim.
    This is very helpful for developers who has more than one view and one project open at the same time.

let &titlestring = expand("$CLEARCASE_ROOT")
echo expand("$CLEARCASE_ROOT")

Thanks for Jurgen Kramer for helping me in getting this work.

VimTip 1087: quick reference of current function(for csharp,c,c++,pascal,sql)
http://vim.sourceforge.net/tip_view.php?tip_id=

It is obliged for me to share this trick with you guys -- my firend.
It is useful for programmer who always want to know what function they are in and what parameters the current function have.
With marks, it is still boring with mark and jump,mark and jump every time you went into a function.
Here is the solution I use:
1.(to avoid the "Hit ENTER or type command to continue" message. )I suggest that you'd better set your command line height to 2 or more,because many functions definition have long width.
2.add this into your _vimrc
"""""""""""""""""""""""""""""
:set cmdheight=2
nmap _F :call CurrentFunc()<CR>
" side effect: REGISTER k and MARK k will be changed
func! CurrentFunc()
    exec "normal mk"
    " c-type code have remarkable definitions from other OO code.
    let l:extension = expand("%:e")
    if l:extension == "c"
        exec "normal ][%b%b"
    else
        exec "?private\\|public\\|protected\\|procedure\\|function\\s\\+\.*("
    endif
    "TODO: maybe you need to open your closed fold at first
    exec "normal v$\"ky`k"
    exec "echo @k"
endfunc " CurrentFunc
"""""""""""""""""""""""""""""

now, when you are editing or viewing a file ,exit to command mod, and type _F to see which is the current function.

If you wanna know or add some  parameters followed by the definition, just type CTRL and O (<C-O>) to jump to the definition, and type `k can jump back.

.cs, .pas,.c,.sql filetype is supported with this trick.

thanks for readding.
Happy vimming.

----------------------------email:IknowUknow2@hotmail.com

VimTip 1088: Find and edit any file in a directory using tag-like pattern matching
http://vim.sourceforge.net/tip_view.php?tip_id=

Often, you work in a huge code base containing a lot of directories and source files (C++, C#, etc.) and you want to quickly edit a file.  If you know at least some part of the file, you can use this tip to look up the file and edit it.

What you need:
Some Unix tools such as find, cat, sed and sort.  GNU Windows versions of these will do as well.  (Actually, I think there must be a way to do this without these tools but haven't tried)

How:
Put the following in a batch file (for Windows; You can do equivalent thing for Unix):
@find [directory] > c:\files.txt
@cat c:\files.txt | sed -f c:\tags.sed | sort > c:\files.tags

Note: Replace [directory] with whatever directory you want to find the files in.  For example, c:\root.

Here, c:\tags.sed contains the following:

s/\\/\//g
s/\(.*\/\)\(.*\)/\2	\1\2	1;"	F/g
s/
//g
/.*RECYC.*/d

Once, this is done, you simply do the following in your _vimrc:
set tags=c:\files.tags

That's it!  You can now look up and edit any file

Example:
If you have c:\root\Foo.cpp and c:\root\FooBar.cpp and you gave c:\root to find tool above, then doing :tj Foo<tab> will give you completion for Foo.cpp and FooBar.cpp!

Enjoy!

VimTip 1090: How to get inline help for PHP functions
http://vim.sourceforge.net/tip_view.php?tip_id=

Do you want to get inline help for PHP functions? Use this extreme simple command:
map <C-F1> "vyiw:new<CR>:execute "r!lynx -dump http://localhost/phpman/function.".@v.".html"<CR>:1<CR>
Place cursor on PHP function name and press <C-F1>. You will see new window opened with textual help page.

Of course you have to install httpd, php documentation (I think you have yet!), and also lynx text WWW browser.

VimTip 1091: Hide/show useless parts of your code.
http://vim.sourceforge.net/tip_view.php?tip_id=

Sometimes you see too much code,
To organise the code clutter in your screen
You can hide/show blocks of code (not) of interest to you
(this tip does not change your source file, only the display)

1. Put this in your vimrc:
      :set foldmethod=manual
      :map +   v%zf

2. Now put your cursor on any parenthesis of block you want to hide (fold) and press '+' key.
3. You can also view/unfold the hidden block by just pressing space inside the folded text.
4. To find out more about this feature do,
    :help folding


5. To hide arbitary block, use these key strokes:
        v<move>zf

VimTip 1092: keeping SQL*PLUS command (Windows OS)
http://vim.sourceforge.net/tip_view.php?tip_id=

Oracle's SQL*PLUS command line is very spare and simple, and an enjoyable challenge to use, but it does not keep a command history. vimtip #41 addresses this, but I could not get that to work for various reasons. I made a solution that is complicated in some ways (it requires a one-liner .bat file and a one-liner .sql file in addition to an entry in _vimrc), but for me it was simpler in that I could get it to work in my situation

I wanted a log (sqlplus.log) file of my previous sql commands, stored in my %SQLPATH% where my login.sql and other Oracle scripts live. I wanted to see that file even after I quit from the afiedt.buf (the default file created by Oracle upon executing the "edit" command in SQL*PLUS). This is the aspect of vimtip#41 that I could not get to work. Oracle requires that the process that creates that afiedt.buf return control back to Oracle (i.e. you must :wq from afiedit.buf). I would have liked a split window viewing both afiedit.buf and sqlplus.log, but have not been able to do that.

So I looked for a way to accomplish these three things
a) append the contents of afiedt.buf to a log file
b) keep the log file visible after :wq from afiedit.buf
c) pass the control back to Oracle properly so Oracle could see the contents of afiedt.buf

While in SQL*PLUS, I enter
@edit
at the command prompt to access this one-liner file named edit.sql placed in %SQLPATH% (where Oracle could always find it):
--filename edit.sql
host runvim

Upon reading this file, SQL*PLUS  executes the command "runvim" from a newly made shell.
Here is the file runvim.bat, placed in my %PATH%:

:: filename runvim.bat
START /B gvim %SQLPATH%sqlplus.history

This starts gvim without making a console window, opening the file "sqlplus.history" in the path %SQLPATH%, an Oracle environment variable set previously .

I edit my SQL commands from sqlplus.history, and copy-paste them to SQL*PLUS when I am done making typos :-). Or, I can invoke the SQL*PLUS command "edit" (as opposed to my "@edit" invocation which calls the edit.sql file). The "edit" command creates the afiedt.buf file. I want to append the contents of afiedit.buf onto sqlplus.history. I added this little function to my _vimrc to do that:

fu! Sqllog()
   1,$-1w! >> $SQLPATH/sqlplus.history
endf
au BufWrite afiedt.buf call Sqllog()

Also, I have this in my _vimrc to ensure that vim does not fork a new process; I believe it is necessary in using the builtin SQL*PLUS "edit" command:

set guioptions +=f  "so gvim does not fork new process

To Do:
I would prefer to append the contents of afied.buf  *after it is quit from*, instead of after it is wrtten to, but I am not completely sure how to do that now. Also, the split window between sqlplus.log and afiedt.buf would be nice to have.

References:
:h fu
:h au
:h BufWrite
:h gui-fork

VimTip 1093: A couple folding tips
http://vim.sourceforge.net/tip_view.php?tip_id=

 - Instead of keeping 'zc' and 'zo' in your head, just use 'za' to toggle a fold open or closed.
 - Map '[{V%zf' to some key sequence (I use <leader><leader>) to fold the current code block (in languages which use '{,}' as block delimiters.
 - Use folds liberally.  If you fold every function, when you open the file, you will be presented with a quick reference of what functions are defined in the file.
 - Don't nest too many folds, it grows to be a pain if you use more than 2 levels of nested folds.
 - If you think you need more than 2 levels of folds, you probably need to refactor your code.

VimTip 1101: xml-plugin changes matchit behavior
http://vim.sourceforge.net/tip_view.php?tip_id=

Matchit (http://www.vim.org/scripts/script.php?script_id=39) is great as is the xml plugin (http://www.vim.org/scripts/script.php?script_id=301).

Note that if you are used to matchit, as I was, and install the xml plugin, the behavior of % changes, so that you now use <leader>% to jump between tags.  With matchit alone % is smart about where to jump depending on whether or not you are on a <> or the tag name.

I am sure there is configuration to deal with this, but it is minor enough at least for me to use <leader>% instead when matching tags.

Anyway, since I spent 1/2 an hour to figure out why % had stopped working I thought I would pass it along.

VimTip 1103: Correct scrolling in vim with trackpoint (UltraNav)
http://vim.sourceforge.net/tip_view.php?tip_id=

If you are using an pointing device called Trackpoint (or TouchStyk as Synaptics calls it) you might encounter a problem with scrolling in gvim: When you use split windows, the scrolling function will always scroll one window and does not care where the cursor is.

To correct this (works for me with the Synaptics driver version 08/01/2005, 8.1.2.0):

backup the file tp4table.dat in C:\Programme\Synaptics\SynTP
edit the file tp4table.dat in C:\Programme\Synaptics\SynTP:

insert at line 128 (after Java support)

; gvim support
*,*,gvim.exe,*,*,*,WheelStd,0,9

after restarting SynTPEnh.exe (e.g. reboot) it will work.

Enjoy :-)

VimTip 1107: J2ME development by Vim + WTK22
http://vim.sourceforge.net/tip_view.php?tip_id=

If you are same as me, using Vim to write mobile program (J2ME), you may try this.

I did a search during the weekend, no luck to find similar tips/scripts, so i tried to
collect some and put it there, it works for me, but rather hardcode, especially on
emulator part, it's not perfect, welcome for any comments =)

Edit: c:\progra~1\vim\_vimrc,  put these:
-------------------------------------------------------------------------------
set makeprg=jikes\ -nowarn\ -classpath\ tmpclasses\ -d\ tmpclasses\ -sourcepath\ src\ -Xstdout\ +E\ %
set errorformat=%f:%l:%c:%*\\d:%*\\d:%*\\s%m
"  Above is [stolen] from vimtip #3 , thanks Scott for the great tips.

map <M-1> :make<CR>:cw5<CR>
" cw5 help you to see the error, my favorite, (stolen from :help :cn)
map <M-2> :!preverify -classpath c:\wtk22\lib\cldcapi10.jar;c:\wtk22\lib\midpapi10.jar -d bin tmpclasses<CR>
" preverify is important before running the WTK emulator, i use Alt-2 to do this, may change.

" This emulator is specific for ZhanGuo project:  (change zhanguo.jad to yourfile.jad)
" it's the best that the jad is generated by WTK22 such that it
" place it in :  c:\wtk22\apps\zhanguo (zhanguo is your project name)
map <M-3> :!c:\wtk22\bin\emulator.exe -classpath bin -Xdescriptor:zhanguo.jad<CR>

cmap %/ <C-R>=expand("%:p:h")."/"<CR>
"  Above is [stolen] from comment inside vimtip #2 , thanks yulya@vdcom.ru for the great tips.
------------------------------------------------------------------------------
Note on path:
You need to have path on c:\wtk22\bin  (or else you need full path in many places, lazy)
SET PATH=c:\wtk22\bin;%PATH%
Need to create 2 directories, normally created by WTK22 or by hand:

cd c:\wtk22\apps\[project]
mkdir tmpclasses
mkdir bin

Also, u need to start editing in the project path, not the src path.
e.g.
cd c:\wtk22\apps\[project]
vim src\MyMidlet.java

do not go out of the [project] path, if you need to edit another file, do:
:e %/
This will auto expand to the current [editing] directory.  see the vimtip #2, great one.

VimTip 1108: Replace selected shell command with full path when editing scripts
http://vim.sourceforge.net/tip_view.php?tip_id=

I am in the situation where I write some bash scripts and sudoers file, but it was tiresome going to a bash shell to find the paths of certain commands, so I'd thought that I could use the 'which' command to return the path of the selected word, however, this would not work directly with the 'which' command. To get around this I instead used< drum roll>:
!which $(cat) .

So convert a bash command to a fully-explicit bash command the key sequence would be "w!which $(cat)". $(cat) simply uses the selected text from the pipe and uses this text as an argument to the 'which' command. This method is great for using commands that use arguments instead of stdin., however, as far as I know it works only in bash, I don't know enough about other shells to know whether this will be effective or not.

This command could be mapped to some key sequence if required, but there are a million other tips that show you how to do this.

VimTip 1109: Maintain cursor & screen position
http://vim.sourceforge.net/tip_view.php?tip_id=

This is for script writers who wish to save & restore the position of the normal cursor and its screen.
To save: call CurPos(currentline, currentcol)
To restore: call CurPos()

Example:
"pressing <F2> shouldn't change a thing! try with special characters and such
nmap <F2> :call Test()<CR>
fun Test()
  let curcol = col(".")
  let curline = line(".")
  " save positions
  call CurPos(curline, curcol)
  " cursor now at same position but screen position isn't

  " next, insert code that changes cursor position
  normal gg

  " restore positions
  call CurPos()
endfun

===
set lazyredraw
"note: makes use of mark 'i
function CurPos(...)
  if a:0 > 0
    let b:saveve = &virtualedit
    let b:savesiso = &sidescrolloff
    set virtualedit=all
    set sidescrolloff=0
    let b:curline = a:1
    let b:curcol = a:2
    let b:curvcol = virtcol(".")
    let b:curwcol = wincol()
    normal g0miM
    let b:midline = line(".")
    call cursor(b:curline, b:curcol)
    let &virtualedit = b:saveve
    let &sidescrolloff = b:savesiso
  else
    set virtualedit=all
    set sidescrolloff=0
    call cursor(b:midline, 0)
    normal zz0
    let nw = wincol() - 1
    if b:curvcol != b:curwcol - nw
      normal `izs
      let s = wincol() - nw - 1
      if s != 0
        execute "normal ".s."zl"
      endif
    endif
    call cursor(b:curline, b:curcol)
    let &virtualedit = b:saveve
    let &sidescrolloff = b:savesiso
    unlet b:saveve b:savesiso b:curline b:curcol b:curvcol b:curwcol b:midline
  endif
endfunction
===

VimTip 1110: Toggle gvim window size
http://vim.sourceforge.net/tip_view.php?tip_id=

You can easily switch between the maximized and original window size
using the following script.
Unfortunately, this seems to work only in win32 gvim.

F11: maximize/restore height
Shift-F11: maximize/restore width
Ctrl-F11: maximize/restore height and width

function ToggleWindowSize(act)
    if a:act < 0 || a:act > 2 | return | endif

    let posX = getwinposx()
    let posY = getwinposy()

    let actTab = "XXX__X_XR__XX_X__RRRR__R"
    let idx = ((exists("g:twsWM") + exists("g:twsHM") * 2) * 3 + a:act) * 2
    let actW = strpart(actTab, idx, 1)
    let actH = strpart(actTab, idx + 1, 1)

    " note. g:tws + [Width,Height,X,Y] + [Maximized,Saved]
    if actW == "X"
        let g:twsWS = &columns | let g:twsXS = posX
        set columns=999
        let posX = getwinposx()
        let g:twsWM = &columns | let g:twsXM = posX
    elseif actW == "R"
        if g:twsWM == &columns
            let &columns = g:twsWS
            if g:twsXM == posX | let posX = g:twsXS | endif
        endif
        unlet g:twsWM g:twsWS g:twsXM g:twsXS
    endif

    if actH == "X"
        let g:twsHS = &lines | let g:twsYS = posY
        set lines=999
        let posY = getwinposy()
        let g:twsHM = &lines | let g:twsYM = posY
    elseif actH == "R"
        if g:twsHM == &lines
            let &lines = g:twsHS
            if g:twsYM == posY | let posY = g:twsYS | endif
        endif
        unlet g:twsHM g:twsHS g:twsYM g:twsYS
    endif

    execute "winpos " . posX . " " . posY
endfunction

nnoremap <F11>   :call ToggleWindowSize(2)<CR>
nnoremap <S-F11> :call ToggleWindowSize(1)<CR>
nnoremap <C-F11> :call ToggleWindowSize(0)<CR>
imap     <F11>   <C-O><F11>
imap     <S-F11> <C-O><S-F11>
imap     <C-F11> <C-O><C-F11>

VimTip 1111: Map semicolon (;) to colon (:)
http://vim.sourceforge.net/tip_view.php?tip_id=

To avoid the extra 'shift' keypress when typing the colon to go to cmdline mode, I mapped the semicolon key to do the same thing.

:nmap ; :

This overwrites the original mapping of repeating the last f or t command.

VimTip 1112: Something better than just :ls
http://vim.sourceforge.net/tip_view.php?tip_id=

nnoremap <m-:> :ls\|sleep<enter><enter>

So actually, this uses :ls. However, this is much more convenient. This mapping (alt-:) will show the results of :ls for one second. Pressing alt-: 3 times will show the :ls listing for 3 seconds.

You can also hold down alt-: to indefinitely show the file list; and you can press ctrl-c when you're done looking at it. This can be very useful when working with many files.

VimTip 1114: Step Increment & Replace
http://vim.sourceforge.net/tip_view.php?tip_id=

This allows a search, and step-by-step confirm & replace, while having the replace string incremented each time if it contains a number at the end of the string. To search for occurences of "abc", to replace with "xyz0" for the first "abc", "xyz1" for the second "abc", etc.,  simply do

:SReplace abc xyz0 1

At any step, you can change from "xyzN" to "defN", and pick up where you left off with the same increment.

Usage: SReplace <search> <substitute> <increment>

===
command -nargs=+ SReplace call StepReplace(<f-args>)
"makes use of register y
function StepReplace(...)
  if a:0 == 1
    let @y = input("Replace with: ", @y)
    let y = @y
    if @y =~ "\\d\\+$"
      let n = substitute(@y, ".\\{-}\\(\\d\\+\\)$", "\\1", "") + a:1
      let @y = substitute(@y, "\\(.\\{-}\\)\\d\\+$", "\\1".n, "")
    endif
    return y
  elseif a:0 == 3
    let @y = a:2
    execute "%s/".a:1."/\\=StepReplace(".a:3.")/".(&gdefault ? "" : "g")."c"
  else
    echo "Usage: SReplace <search> <substitute> <increment>"
  endif
endfunction
===

VimTip 1117: Use tab instead of escape
http://vim.sourceforge.net/tip_view.php?tip_id=

People get tired of hitting Escape all the time to get into normal mode. Others have given advice of using Control-[ or mapping CapsLock to Escape.
I now give the advice to use Tab for getting to normal mode.

Tab is by far faster than Escape or Control-[; and there is no burden of configuring every machine you go on to map CapsLock to Escape.

Now that you've read my advice and decided to start using Tab for Escape, the thought arises, "how will I insert tabs?".
You can always shift lines using << and >> when in normal mode. When in insert mode, you can use Control-T and Control-D to do what >> and << do, respectively. I personally like to map Alt-i to insert a Tab, because it's the fastest key combination.

Enough talk; here's the setup:

inoremap <m-i> <tab>
nnoremap <tab> <esc>
vnoremap <tab> <esc>gV
onoremap <tab> <esc>
inoremap <tab> <esc>`^

Notes: the gV makes sure to deselect the selection; and the `^ puts the cursor back to where it was last in insert mode (so there is no going back a char when escaping to normal mode).

VimTip 1118: repeating an ex command on multiple blocks
http://vim.sourceforge.net/tip_view.php?tip_id=

There are several ways to repeat a command in Vim, but here is the one I like most when it comes to repeating a command on several blocks in a buffer, mainly because this method doesn't require a macro and uses the ex mode, with all its associated benefits (such as the history editing).

This can be explained more easily starting with an example. Say you want to sort blocks of text, each separated by a single empty line (including one before the first block and one after the last block, for the sake of simplicity). You can sort a single block after the cursor position using the command:

:/^$/,/^$/-1!sort

Now, the trick is getting this repeated on all such blocks in the buffer. This can be achieved with the ";" Ex command (:help :;) as below (which incidentally works in the plain old Vi too):

:g/^$/;,/^$/-1!sort

The above command stops when there are no more matches to be found.

VimTip 1119: How to use Vim like an IDE
http://vim.sourceforge.net/tip_view.php?tip_id=

I personally use Vim for all text editing, even software development. At one point I stopped using IDEs. One major reason is that Vim can do all the major things I need from IDEs (tabs, file trees, greping, syntax highlighting, indentation, completion, "quickfix"ing, etc.). Vim 7 will be introducing one of the most critical features: completion (intellisense).

Still Vim needs plugins to do some IDE-like things that aren't built in.
One thing you might want is the vtreeexplorer (http://vim.org/scripts/script.php?script_id=184) plugin, which allows you to have a "file list" in a vertically split window. Another thing worth considering is the minibufexpl (http://vim.org/scripts/script.php?script_id=159) plugin, which will allow for tabs of all your files (works really well).

Yet another thing is in a former tip of mine (http://www.vim.org/tips/tip.php?tip_id=1078), which allows you to delete a buffer without actually closing the window. Also, below, I have a new, more complicated version of it. The below script will actually create a scratch buffer if there are no listed buffers left. The script, in addition, takes care of a small annoyance. Before, if you 1) open vim, 2) :e a file, 3) :bd, 4) :e the same file... then there will be two buffers listed (that file and a [no name] buffer). The following script ensures this doesn't happen.

(Everything in this tutorial and in most of my other tips/tutorials assumes the user does "set hidden".)
Using this Kwbd function (:call Kwbd(1)) will make Vim behave like an IDE; or maybe even better.

"here is a more exotic version of my original Kwbd script
"delete the buffer; keep windows; create a scratch buffer if no buffers left
function Kwbd(kwbdStage)
    if(a:kwbdStage == 1)
        if(!buflisted(winbufnr(0)))
            bd!
            return
        endif
        let g:kwbdBufNum = bufnr("%")
        let g:kwbdWinNum = winnr()
        windo call Kwbd(2)
        execute "normal " . g:kwbdWinNum . ""
        let g:buflistedLeft = 0
        let g:bufFinalJump = 0
        let l:nBufs = bufnr("$")
        let l:i = 1
        while(l:i <= l:nBufs)
            if(l:i != g:kwbdBufNum)
                if(buflisted(l:i))
                    let g:buflistedLeft = g:buflistedLeft + 1
                else
                    if(bufexists(l:i) && !strlen(bufname(l:i)) && !g:bufFinalJump)
                        let g:bufFinalJump = l:i
                    endif
                endif
            endif
            let l:i = l:i + 1
        endwhile
        if(!g:buflistedLeft)
            if(g:bufFinalJump)
                windo if(buflisted(winbufnr(0))) | execute "b! " . g:bufFinalJump | endif
            else
                enew
                let l:newBuf = bufnr("%")
                windo if(buflisted(winbufnr(0))) | execute "b! " . l:newBuf | endif
            endif
            execute "normal " . g:kwbdWinNum . ""
        endif
        if(buflisted(g:kwbdBufNum) || g:kwbdBufNum == bufnr("%"))
            execute "bd! " . g:kwbdBufNum
        endif
        if(!g:buflistedLeft)
            set buflisted
            set bufhidden=delete
            set buftype=nofile
            setlocal noswapfile
            normal athis is the scratch buffer
        endif
    else
        if(bufnr("%") == g:kwbdBufNum)
            let prevbufvar = bufnr("#")
            if(prevbufvar > 0 && buflisted(prevbufvar) && prevbufvar != g:kwbdBufNum)
                b #
            else
                bn
            endif
        endif
    endif
endfunction

VimTip 1120: Syntax highlighting when starting a string: fix annoyance
http://vim.sourceforge.net/tip_view.php?tip_id=

Did you ever notice how syntax highlight of the whole screen below current line changes when you start a string line (at least, in .py python files)? Vim thinks the rest of the screen is inside a string and highlights it as such. I find this extremely annoying and I found a very neat fix: you have to edit the syntax file for python (or some other language), and add 'oneline' to the relevant line:

syn region pythonString		matchgroup=Normal start=+[uU]\='+ end=+'+ skip=+\\\\\|\\'+ contains=pythonEscape oneline
syn region pythonString		matchgroup=Normal start=+[uU]\="+ end=+"+ skip=+\\\\\|\\"+ contains=pythonEscape oneline

This way only current line will change, from cursor to the end of line. Usually you're entering the string at the end of line, so you'll have no changes in syntax at all.

VimTip 1123: vimrc example with some arguably good stuff in it
http://vim.sourceforge.net/tip_view.php?tip_id=

" the following is my personal .vimrc file; and you will find wealth in it
" let me know if anything is missing

"main settings
set nocompatible
syntax enable
filetype plugin on
filetype indent on
set hidden
set tabstop=4
set mouse=a
set showbreak=>
set whichwrap+=<,>,[,],h,l
set display+=lastline
set rulerformat=%22(%M%n\ %=%l,%c%V\ %P%)
set selectmode=mouse
set selection=inclusive
set showcmd
set showmatch
set matchtime=8
set shiftwidth=4
set textwidth=0
set scrolloff=2
set winaltkeys=no
set nohls
set ruler
set laststatus=2
set backspace=2
set formatoptions-=c
set formatoptions-=o
set formatoptions+=r
set ignorecase
set incsearch
set autoindent
set smartindent

"terms
if(&term == "Eterm")
    set ttymouse=xterm
endif

"the whitespace indicators
set listchars=precedes:$,extends:$,tab:»·,trail:·
"set list
highlight WhiteSpaceEOL ctermbg=darkgreen guibg=lightgreen
"highlight leading spaces and trailing whitespace
match WhiteSpaceEOL /\(^\s*\)\@<=\ \|\s\+$/
autocmd WinEnter * match WhiteSpaceEOL /\(^\s*\)\@<=\ \|\s\+$/
nnoremap \wsh :highlight WhiteSpaceEOL ctermbg=darkgreen guibg=lightgreen<enter>
nnoremap \wsa :match WhiteSpaceEOL /\(^\s*\)\@<=\ \\|\s\+$/<enter>
"highlight only trailing whitespace
nnoremap \wst :match WhiteSpaceEOL /\s\+$/<enter>
nnoremap \cs1 :colorscheme desert<enter>:normal \wsh<enter><c-l>

"autos
autocmd BufRead crap.txt set nowrap
autocmd BufReadPost quickfix if(!strlen(bufname("%"))) | set nobuflisted | endif
autocmd FileType * set fo-=c fo-=o fo+=r
autocmd FileType vim normal \lc"
autocmd FileType cs,c,cpp,java,jsp normal \lc/

"global vars
let g:leave_my_textwidth_alone = 1
let g:leave_my_cursor_position_alone = 1
let g:miniBufExplUseSingleClick = 1

"save and exit
noremap <f3> <esc>:w<enter>
inoremap <f3> <c-g>u<esc>:w<enter>gi
cnoremap <f3> <end><c-u><bs>
noremap <f4> <esc>:qa!<enter>
inoremap <f4> <esc>:qa!<enter>
cnoremap <f4> <c-c>:qa!<enter>
noremap <m-d> <esc>:w<enter>
inoremap <m-d> <esc>:w<enter>`^
inoremap <m-c> <c-g>u<esc>:w<enter>gi
nnoremap <m-e> :confirm qa<enter>
inoremap <m-e> <esc>:confirm qa<enter>
vnoremap <m-e> <esc>:confirm qa<enter>
cnoremap <m-e> <end><c-u><bs>
cnoremap <c-g> <end><c-u><bs>
noremap \\ :confirm qa<enter>
inoremap \\ <esc>:confirm qa<enter>

"stuff for commentation
set timeout timeoutlen=700 ttimeoutlen=90
"set <m-w>=w
"set <m-q>=q
let g:commentprefix="#"
nnoremap <silent> \lc/ :let g:commentprefix="\\/\\/"<enter>
nnoremap <silent> \lc" :let g:commentprefix="\""<enter>
nnoremap <silent> \lc' :let g:commentprefix="'"<enter>
nnoremap <silent> \lc; :let g:commentprefix=";"<enter>
nnoremap <silent> \lc# :let g:commentprefix="#"<enter>
nnoremap <silent> \lc! :let g:commentprefix="!"<enter>
noremap <silent> <m-w> :s/^/<c-r>=commentprefix<enter>/<enter>:noh<enter>
noremap <silent> <m-q> :s/^<c-r>=commentprefix<enter>//<enter>:noh<enter>
inoremap <silent> <m-w> <esc>:s/^/<c-r>=commentprefix<enter>/<enter>:noh<enter>A
inoremap <silent> <m-q> <esc>:s/^<c-r>=commentprefix<enter>//<enter>:noh<enter>A
"for c# coding:
iabbrev /// /// <summary><enter><c-u>///<enter><c-u>/// </summary><up>

"emacs
inoremap <m-f> <esc>:normal e<enter>a
inoremap <m-b> <c-o>b
cnoremap <m-f> <s-right>
cnoremap <m-b> <s-left>

inoremap <m-j> <c-o>gj
inoremap <m-k> <c-o>gk
cnoremap <m-j> <c-n>
cnoremap <m-k> <c-p>
noremap! <m-h> <left>
noremap! <m-l> <right>
inoremap <m-J> <c-x><c-e>
inoremap <m-K> <c-x><c-y>
cnoremap <m-J> <down>
cnoremap <m-K> <up>
noremap <m-J> <c-e>
noremap <m-K> <c-y>
noremap! <m-H> <home>
noremap! <m-L> <end>
noremap <m-H> <home>
noremap <m-L> <end>
noremap <m-h> <pageup>
noremap <m-l> <pagedown>
noremap <m-j> gj
noremap <m-k> gk

inoremap <m-{> <esc>{i
inoremap <m-}> <esc>}i
nnoremap <c-j> i<enter><esc>
inoremap <m-_> <c-o>_
inoremap <m-.> <c-a>
"these five are great:
inoremap <m-o> <c-g>u<esc>o
inoremap <m-O> <c-g>u<esc>O
noremap <m-o> o<esc>
noremap <m-O> O<esc>
nnoremap <m-:> :ls\|sleep 900m<enter><enter>

" * is x primary selection, + is clipboard, " is vim
nnoremap <m-+> :let @+ = @"<enter>
nnoremap <m-"> :let @" = @+<enter>

"better escape mapping: tab
inoremap <m-i> <tab>
nnoremap <tab> <esc>
vnoremap <tab> <esc>gV
onoremap <tab> <esc>
inoremap <tab> <esc>`^

nmap [6^ :bn<enter>
nmap <c-pagedown> :bn<enter>
nmap [5^ :bp<enter>
nmap <c-pageup> :bp<enter>
nmap [3^ :call Kwbd(1)<enter>
nmap <c-del> :call Kwbd(1)<enter>

nmap \sh :source ~/.vim/stuff/vimsh/vimsh.vim<enter>
nmap \te :source ~/.vim/stuff/tetris.vim<enter>
nmap \tl :source ~/.vim/stuff/taglist.vim<enter>:Tlist<enter>
nmap \sc :runtime autoload/syntaxcomplete.vim<enter>
nmap \pb :ProjectBrowse .<enter>
nmap \ss :set spell<enter>
nmap \us :set nospell<enter>
nmap \sw :set wrap<enter>
nmap \uw :set nowrap<enter>
nmap \ls1 :set ls=1<enter>
nmap \ls2 :set ls=2<enter>
noremap <m-v> <c-v>
noremap! <m-z>v <c-v>
"in case i forget
nnoremap <m-x>v :echo "This is Vim " . v:version . " Crap Edition"<enter>
nnoremap Y y$
nnoremap S 0D
vnoremap <bs> d
nnoremap <bs> X
nnoremap <space> i<space><esc>l

"macro related
noremap <f2> @q
inoremap <f2> <esc>`^@q
set t_F8=[12þ
"these are to end recording while in selection mode
vnoremap <t_F8> :normal q<enter>
vnoremap <m-f2> :normal q<enter>
inoremap <t_F8> <c-o>q
inoremap <m-f2> <c-o>q

"delete the buffer; keep windows; create scratch buffer when no buffers left
function Kwbd(kwbdStage)
    if(a:kwbdStage == 1)
        if(!buflisted(winbufnr(0)))
            bd!
            return
        endif
        let g:kwbdBufNum = bufnr("%")
        let g:kwbdWinNum = winnr()
        windo call Kwbd(2)
        execute "normal " . g:kwbdWinNum . ""
        let g:buflistedLeft = 0
        let g:bufFinalJump = 0
        let l:nBufs = bufnr("$")
        let l:i = 1
        while(l:i <= l:nBufs)
            if(l:i != g:kwbdBufNum)
                if(buflisted(l:i))
                    let g:buflistedLeft = g:buflistedLeft + 1
                else
                    if(bufexists(l:i) && !strlen(bufname(l:i)) && !g:bufFinalJump)
                        let g:bufFinalJump = l:i
                    endif
                endif
            endif
            let l:i = l:i + 1
        endwhile
        if(!g:buflistedLeft)
            if(g:bufFinalJump)
                windo if(buflisted(winbufnr(0))) | execute "b! " . g:bufFinalJump | endif
        else
            enew
            let l:newBuf = bufnr("%")
            windo if(buflisted(winbufnr(0))) | execute "b! " . l:newBuf | endif
    endif
    execute "normal " . g:kwbdWinNum . ""
endif
if(buflisted(g:kwbdBufNum) || g:kwbdBufNum == bufnr("%"))
    execute "bd! " . g:kwbdBufNum
endif
if(!g:buflistedLeft)
    set buflisted
    set bufhidden=delete
    set buftype=nofile
    setlocal noswapfile
    normal athis is the scratch buffer
endif
    else
        if(bufnr("%") == g:kwbdBufNum)
            let prevbufvar = bufnr("#")
            if(prevbufvar > 0 && buflisted(prevbufvar) && prevbufvar != g:kwbdBufNum)
                b #
            else
                bn
            endif
        endif
    endif
endfunction

"undo mods
inoremap <c-w> <c-g>u<c-w>
inoremap <enter> <c-g>u<enter>
"inoremap <bs> <c-g>u<bs>
"inoremap <del> <c-g>u<del>

"alt-backspace stuff
set t_F9=[3þ
map! <t_F9> <m-f><c-w>
map! <m-del> <m-f><c-w>
map! ÿ <c-w>
map! <m-bs> <c-w>

"selection of indented region
nmap \sir :call SelectIndented()<enter>
function SelectIndented()
    let temp_var = indent(line("."))
    while indent(line(".")-1) >= temp_var
        exe "normal k"
    endwhile
    exe "normal V"
    while indent(line(".")+1) >= temp_var
        exe "normal j"
    endwhile
endfun

"copy/paste stuff
nnoremap <silent> <sid>Paste :call <sid>Paste()<cr>
vnoremap <c-x> "+x
vnoremap <c-c> "+y
map <c-v> "+gP
cmap <c-v> <c-r>+
func! <sid>Paste()
    let ove = &ve
    set ve=all
    normal `^
    if @+ != ''
        normal "+gP
    endif
    let c = col(".")
    normal i
    if col(".") < c
        normal l
    endif
    let &ve = ove
endfunc
inoremap <script> <c-v> x<bs><esc><sid>Pastegi
vnoremap <script> <c-v> "-c<esc><sid>Paste

"for the wildmenu and menu stuff
nmap \me :source $VIMRUNTIME/menu.vim<enter>
set wildmenu
set wildmode=list:longest,full
set cpo-=<
"set wcm=<c-z>
"nmap \mu :emenu <c-z>

"go to scratch buffer
if(!strlen(bufname("%")))
    call Kwbd(1)
endif

VimTip 1124: Turn off per-filetype auto indentation
http://vim.sourceforge.net/tip_view.php?tip_id=

That's quite hard to find how to really turn off all auto indentation.
I tried to place "set noai" in vimrc, but the auto-filetype-detecting feature will override "set noai" if your file has for instance ".cpp" or ".java" common extension.

Ive checked in fact the default setting of vim is noai, therefore we dont need set noai.

My solution is placing these in wimrc: "filetype plugin indent off" and "filetype indent off".

VimTip 1125: quickly go to next buffer.
http://vim.sourceforge.net/tip_view.php?tip_id=

"
" quickly cycle-through buffers.
"
noremap <C-n> :bnext<CR>
noremap <C-p> :bprev<CR>

VimTip 1126: Automatically set screen title
http://vim.sourceforge.net/tip_view.php?tip_id=

Screen's title field can automatically be updated to the name of the currently opened file (or whatever you like).
Just add the following to your .vimrc

let &titlestring = hostname() . "[vim(" . expand("%:t") . ")]"

if &term == "screen"
  set t_ts=^[k
  set t_fs=^[\
endif

if &term == "screen" || &term == "xterm"
  set title
endif

This will make a title like hostname[vim(filename)], but that's only my personal preference. That way, you can
easily keep track on which window in your screen you have which file opened.

VimTip 1127: fast one session mapping
http://vim.sourceforge.net/tip_view.php?tip_id=

" A little nice idea I got today...
"
" I've noticed that I often use one session mappings .. Sometimes :bn
" sometimes :make specialtarget
" in each case I need it often.
" vim supports this by @: but there are cases when I want to press one key only
" and other cases I want to user other commands as well.
" Having to type :map <F5> :<cmd><CR> does need some time and I'm lazy ;-)
" So just copy this text, put it  into .vim/plugins/mapFromF1ToF12.vim and enjoy
" Try
" :echo "dummy"<CR>
" <F5>
" now you can use F5 to execute :echo "dummy"
" Perhaps you want to have mappings local to your buffer only.
" Then use map <buffer> and unmap <buffer> instead

function MapLastCommandToKeys(keysToMapTo)
	exe "unmap ".a:keysToMapTo
	exe "map ".a:keysToMapTo." :".histget("cmd")."<CR>"
endfunction

function PrepareMap(keysToMapTo)
	exe "map ".a:keysToMapTo." :call MapLastCommandToKeys('".a:keysToMapTo."')<CR>"
endfunction

" This will allow you to use F1
PrepareMap('<F1>')
" This while loop will allow you to use F2,F3,..,F12
let i=2
while i<13
	call PrepareMap('<F'.i.'>')
	let i=i+1
endwhile
" of cause you can use any mapping eg \a:
PrepareMap("\a")

VimTip 1128: Detecting non-unicode Xterms
http://vim.sourceforge.net/tip_view.php?tip_id=

I like to do my editing work in Unicode (say: UTF-8) and Vim is quite good at this: setting encoding=utf8 does the job. But there are terminals which do not work natively in UTF-8. A good example is the Linux text console: you may set it to Unicode mode, but with a Spanish keymap you won't be able of entering accented characters without reverting to non-Unicode mode. Another example is Xterm, either old Xterms or ones which are not started un UTF-8 mode. My vimrc contains the following snippet which selects the a sane value for termencoding in those terminals:

if has("multi_byte")
    set encoding=utf-8
    if $TERM == "linux" || $TERM_PROGRAM == "GLterm"
        set termencoding=latin1
    endif
    if $TERM == "xterm" || $TERM == "xterm-color"
        let propv = system("xprop -id $WINDOWID -f WM_LOCALE_NAME 8s ' $0' -notype WM_LOCALE_NAME")
        if propv !~ "WM_LOCALE_NAME .*UTF.*8"
            set termencoding=latin1
        endif
    endif
endif

VimTip 1129: getting alt key to work in terminals
http://vim.sourceforge.net/tip_view.php?tip_id=

xterm, by default, sets eightBitInput to true, meaning that the eighth bit is set for metacharacters (combinations with the Alt key, for instance). Not all terminals have this feature enabled by default, and therefore work differently (they send an ESC before the character key).

So for the xterm, with enables the eight bit, you can just do something like, map <m-a> ggVG
However, with the terminal that's in 7 bit mode, you have to do this:
set <m-a> = ^[a
map <m-a> ggVG
"the ^[ is an ESC char that comes before the 'a'

My tip is to just set all terminals to work in 8 bit mode.
Here are two examples:
Eterm -8
rxvt --meta8

VimTip 1130: Format a code block: =i{
http://vim.sourceforge.net/tip_view.php?tip_id=

= is the formatting command, which has a default behavior of using Vim's internal formatting/indentation features.
i{ is a text object selection which selects a code block: vi{

combine the two, and you can format a code block by typing =i{

learn more about text object selections by typing :h text-objects

more and more of these text objects keep getting added (by Vim7 I know there are some really useful ones: it (inner tag, for xml editing) and i" (inside quotes) and more)

VimTip 1131: selectively formatting individual lines.
http://vim.sourceforge.net/tip_view.php?tip_id=

You want to format/wrap long lines, but not touch shorter lines.

Example: for each line longer than 80 chars, run that line thru the par text formatter.
     :g/.\{80,\}/  .!par w70

This need arises when you cut/paste a programming snippet from your web browser into vim.
and you want to leave the indented code alone, but format the long explanation.
See vim tip 584, on the capabilities of par.

VimTip 1132: Easy block selection with mouse
http://vim.sourceforge.net/tip_view.php?tip_id=

In some editors it is possible to make a block selection by holding the Alt-key and the left mouse key. Since <M-LeftMouse> is not used in Vim, nor is <M-LeftDrag>, it is reasonable to enable this behavior in Vim, too. To do this, just add the following mappings to your vimrc file:

noremap <M-LeftMouse> <4-LeftMouse>
inoremap <M-LeftMouse> <4-LeftMouse>
onoremap <M-LeftMouse> <C-C><4-LeftMouse>
noremap <M-LeftDrag> <LeftDrag>
inoremap <M-LeftDrag> <LeftDrag>
onoremap <M-LeftDrag> <C-C><LeftDrag>

Happy vimming!

VimTip 1133: dont load twice (load my script only once) in one line + vimrc function
http://vim.sourceforge.net/tip_view.php?tip_id=

note:
let a.="abc"  means  let a=a."abc" (vim 7)

----- _dontloadtwice.vim (make sure it's loaded first) -------
" In most plugins there is used:
" if exists("loaded_myplugin")
"    finish
" endif
" let g:loaded_myplugin=1
" which takes some space and needs some effort to copy paste/ remember / type
" and is easier to read (IMHO)
"
" I think
"    exec DontLoadTwice("myplugin")"
" is much easier to use
" put this into your .vimrc:

" returns the well known if exists("..") then finish endif let g:..=1 code
" use it this way: call DontLoadTwice("myscriptname")
function DontLoadTwice(globalIdentifier)
  let dltcmd ="if exists(\"g:".a:globalIdentifier."\")\n"
  let dltcmd.="  finish\n"
  let dltcmd.="endif\n"
  let dltcmd.="let g:".a:globalIdentifier."=1\n"
  return dltcmd
endfunction

--------------
Of cause if you want to redistribute your script and the others don't have this function you need at least one comment: (see vim tip .. ;-) So not much gained then. Might be handy for your own quick and dirty scripts

VimTip 1134: How to read base64 raw string/email directly in vim
http://vim.sourceforge.net/tip_view.php?tip_id=

Although this tip is very useful for me, but I think it is somehow
complex for needing a outter command tool.

The most important things today I do with the internet is receiving
and sending emails.

But sometimes I just got some base64 raw string like that:
aGFwcHkgdmltbWluZyA=

do you know what does it mean? -_-;
Maybe i need to copy&paste it into a .eml format file
 and to use some email tools like OE to read it.

But...thanks for VIM!
I can use a system command to read it in VIM directly.
Please follow me......

1. You need an outter command just like decode64.exe (3,072bytes)
to en/decode strings. this is a tool I produced with asm language.
.But unfortunately, I just test it under WIN2K/2003 only.
download it from here
http://iknowuknow2.bokee.com/inc/encode64.zip

After that, please put the decode64.exe/base64dll.dll into somewhere
your %path% enviromental variable included in, such as %SystemRoot%\System32\

2. You need write some script in your _vimrc
"""""""""""""""""""begin""""""""""""""""""""
vnoremap ;mme "ey:call CalcEncode64(1)<CR>
vnoremap ;mmd "ey:call CalcEncode64(0)<CR>
function! CalcEncode64(pattern) " #region
    let has_equal = 0

    let l:rege=@e
    let l:regk=@k
    let l:regl=@l
    " 1=encode 0=decode
    let l:elen = strlen(@e)     " TOTAL length
    let l:rightmark=strpart(@e, l:elen-4, 3)

    if l:rightmark == "==="
        let @e = strpart(@e,0,l:elen-4)
        let has_equal = 1
    endif

    if a:pattern == 1
        let @k = @e
    elseif a:pattern == 0
        let @k = substitute (@e, "\n", "", "g")
    else
       return ""
    endif

    let l:nsize = 1200 " nsize must be multiples of 4 (byte, for base64 code 4 byte is an unit)
    let l:len = strlen(@k)     " TOTAL length
    let l:vleft=l:len/l:nsize  " the .n block
    let l:vright=l:len/l:nsize " the .n block total
    let l:answerstr = ""
    while 0< l:vleft
      let l:answerstr = l:answerstr . s:normalExecode(l:vleft,l:nsize,l:len,l:vright,a:pattern)
      let l:vleft = l:vleft-1
    endwhile

    " last block < nsize byte
    let l:answerstr = l:answerstr . s:lastExecode(l:vleft,l:nsize,l:len,l:vright,a:pattern)

    let @k=l:answerstr
    if has_equal == 1
        :normal `>"kp
    else
        echo "answer = ".l:answerstr
    endif
    let @l=l:regl
    let @k=l:regk
    let @e=l:rege
endfunction " #endregion
function! s:lastExecode(vleft,nsize,len,vright,pattern) " #region
    let l:answer=""
    let l:nstart=a:nsize*a:vright
    let @l=strpart(@k, l:nstart, a:len-a:nsize*a:vright)
    let l:answer = s:ExeDecode(a:vleft,a:nsize,a:len,a:vright,a:pattern)
    return l:answer
endfunction " #endregion
function! s:normalExecode(vleft,nsize,len,vright,pattern) " #region
    let l:nstart=(a:vright-a:vleft)*a:nsize
    let @l=strpart(@k, l:nstart, a:nsize)
    let l:answer = s:ExeDecode(a:vleft,a:nsize,a:len,a:vright,a:pattern)
    return l:answer
endfunction " #endregion
function! s:ExeDecode(vleft,nsize,len,vright,pattern) " #region
    " 1=encode 0=decode
    " TODO: when encode,the string must NOT contains any char of pipe '|'
    " which conflicts whith the windows shell command, I really dont know
    " how to deal with it.
    if a:pattern == 1
       let @l = substitute (@l, "\n", "", "g")
       let @l = substitute (@l, "\r", "", "g")
       let l:answer = system("echo " . @l . " \| ENCODE64.exe ")
       let @*="echo " . @l . " \| ENCODE64.exe "
    elseif a:pattern == 0
       "let l:answer = system("echo " . @l . " \| DECODE64.exe -D")
       let l:answer = system("echo " . @l . " \| ENCODE64.exe -D")
    else
       return ""
    endif
    return l:answer
endfunction " #endregion
"""""""""""""""""""end  """"""""""""""""""""

3. now open a new gvim instance and copy and paste

aGFwcHkgdmltbWluZyA=

into it, use virtual mode select it. and press ;mmd
you can see the output strings at the bottom of editor:

answer = happy vimming

4. If you append three = after the original base64 string
such as

aGFwcHkgdmltbWluZyA=
===
instead of
aGFwcHkgdmltbWluZyA=

and use virtual mode select the both line. the result decode
 string will append to ===

Just like the following strings:
aGFwcHkgdmltbWluZyA=
===happy vimming

[NOTE]when ENCODING multi-line string,(Virutal-Select string
and press ;mme)
I removed all the line feed and carriage return,
just because I don't know how to input multi-line in windows shell.

and | char is not allowed in the string.
just because I don't know how to distinguished it from shell command |
. Someone may help me-_-;

Thanks for reading!
Happy vimming!

VimTip 1141: command PP: print lines like :p or :# but with with current search pattern highlighted
http://vim.sourceforge.net/tip_view.php?tip_id=

This command (PP) prints lines (like :p or :#) with search pattern highlighted. I use g//p
quite often, and I was missing the highlighting of search pattern. To test this command, try
something like:
            :g/a/PP
If you supply optional argument # (PP #) then line numbers are also printed a-la :#

"-------------------------------------------------------------------------------------------------
" command PP: print lines like :p or :# but with with current search pattern highlighted
command! -nargs=? -range -bar PP :call PrintWithSearchHighlighted(<line1>,<line2>,<q-args>)
function! PrintWithSearchHighlighted(line1,line2,arg)
    let line=a:line1
    while line <= a:line2
        echo ""
        if a:arg =~ "#"
            echohl LineNr
            echo strpart("       ",0,7-strlen(line)).line."\t"
            echohl None
        endif
        let l=getline(line)
        let index=0
        while 1
            let b=match(l,@/,index)
            if b==-1 |
                echon strpart(l,index)
                break
            endif
            let e=matchend(l,@/,index) |

            echon strpart(l,index,b-index)
            echohl Search
            echon strpart(l,b,e-b)
            echohl None
            let index = e
        endw
        let line=line+1
    endw
endfu

VimTip 1142: map . to .['
http://vim.sourceforge.net/tip_view.php?tip_id=

I rely on this behavior so much, I'm always surprised when I use VIM on a system that doesn't have this map installed:
    nmap . .`[

This changes the behavior of the very useful . command to leave the cursor at the point where it was before editing started. This means that if I have, say, a list of files from a change summary that look like this:
    .../foo/bar/pick.c
    .../cram/bar/yup.c
    .../drop/bar/slop.c

And I want to change the leading path, I can go to the first one, and type (say) c3t/anotherdir<ESC> This gives me:
    anotherdir/pick.c
    .../cram/bar/yup.c
    .../drop/bar/slop.c

Now I can just go the beginning of the second line and hit .j. to change the second and third lines. Of course I could you can also use an RE for stuff like this, but often . is a little faster and saves precious brain cells.

:help .

VimTip 1146: project browsing using find.
http://vim.sourceforge.net/tip_view.php?tip_id=

Tip is for loading project files that you know the names for but do not necessarily remember their paths.

Usually when you are working on a project and you want to load a particular file that is somewhere deep in the directory hierarchy, you have to either find the file on the command line and then load it into vim, or use vim tab completion to navigate and load the file. You can use vim's "find" feature instead.

Make the following entry in you .vimrc:
set path=$PWD/**

This will set your path variable to current directory (from which you launched vim) and to all directories under current directory recursively.

Now all you have to do is to open vim/gvim from the base directory of your project. Then if there is a file that you want to open but dont remember the path for it, do a
:find <full-file-name-including-extension>

and it will open the file that you want.

Caveats:
- If you have multiple files with the same name, then you are in trouble. Find will not list them out (like cscope/ctags) before it opens the file. You may end up making edits in the wrong file.
- The find does not take any wildcards. So you cannot afford to make spelling mistakes in the file names (esp. java names)

In spite of the caveats, finding in this manner is far faster than navigating through directories to look for files (esp. if you are a touch typist.)

Variations:
You can change your path variable anytime to change the find path.
You can use :sfind instead of :find to open it in a split window.

Coupled with cscope (see :help cscope) you editing code across files becomes very convenient.

What would be a great feature in vim would be something similar to the "Fast Open Class" feature in Netbeans. Type Alt-shift-O in Netbeans and it will give you a dialog where you can type the file that you are looking for. While typing, it incrementally displays the classes that match your search. Press enter when you have found what you want. (No need of using the mouse at all..)

VimTip 1147: function key as mapleader.
http://vim.sourceforge.net/tip_view.php?tip_id=

Hello,

When finetuning my plugins I noticed that vim does not correctly assing maps using <Leader> when the mapleader is functions key (like <F12>),  You have to use execute to get a correct mapping:

    execute "nnoremap <unique> " . escape(g:mapleader . "1" , '\') .      " :call <SID>Set_Font (1) <CR>"
    execute "nnoremap <unique> " . escape(g:mapleader . "2" , '\') .      " :call <SID>Set_Font (2) <CR>"
    execute "nnoremap <unique> " . escape(g:mapleader . "3" , '\') .      " :call <SID>Set_Font (3) <CR>"
    execute "inoremap <unique> " . escape(g:mapleader . "1" , '\') . " <C-O>:call <SID>Set_Font (1) <CR>"
    execute "inoremap <unique> " . escape(g:mapleader . "2" , '\') . " <C-O>:call <SID>Set_Font (2) <CR>"
    execute "inoremap <unique> " . escape(g:mapleader . "3" , '\') . " <C-O>:call <SID>Set_Font (3) <CR>"

Similar you can se then add menues using execute (but I think that's old news):

    execute "48amenu Plugin.Font.Small<Tab>"  . escape(g:mapleader . "1" , '\') . " :call <SID>Set_Font (1)<CR>"
    execute "48amenu Plugin.Font.Medium<Tab>" . escape(g:mapleader . "2" , '\') . " :call <SID>Set_Font (2)<CR>"
    execute "48amenu Plugin.Font.Large<Tab>"  . escape(g:mapleader . "3" , '\') . " :call <SID>Set_Font (3)<CR>"

The examples where taken from my font plugin, see http://www.vim.org/scripts/script.php?script_id=1337 for full details.

Martin

VimTip 1148: Unique sorting
http://vim.sourceforge.net/tip_view.php?tip_id=

This tip is actually for Vim 7, but that wasn't an option:

Vim 7 has a built-in function called sort() that takes a List and an optional comparator.  It works really well, but unlike the Vim 7 command :sort, there is no way to have the function remove duplicates from the list.  Hence, this function:

" Works just like the Vim 7 sort(), optionally taking in a comprator (just like the original), except that duplicate
" entries will be removed.
function! SortUnique( list, ... )
  let dictionary = {}

  for i in a:list
    execute "let dictionary[ '" . i . "' ] = ''"
  endfor

  let result = []

  if ( exists( 'a:1' ) )
    let result = sort( keys( dictionary ), a:1 )
  else
    let result = sort( keys( dictionary ) )
  endif

  return result
endfunction

Call it just like you would sort().  Note that because it removes duplicate entries, the return List isn't necessarily going to be the same size as the original.  Furthermore, unlike sort(), this can't do things in place.  To replace the original List, do this:

let theList = SortUnique( theList )

VimTip 1149: Using balloonexpr effectively
http://vim.sourceforge.net/tip_view.php?tip_id=

This is another Vim 7 tip, the initial idea for which I got from a suggestion in an email from the Vim list (sincere apologies for not remembering who).

Vim 7 allows the use of an option call 'balloonexpr', which basically calls a function and displays the return value in a tooltip whenever the mouse cursor is at rest over a piece of text for a short period of time.  Thus, we have:

" Returns either the contents of a fold or spelling suggestions.
function! BalloonExpr()
  let foldStart = foldclosed(v:beval_lnum )
  let foldEnd   = foldclosedend(v:beval_lnum)

  let lines = []

  " If we're not in a fold...
  if foldStart < 0
    " If 'spell' is on and the word pointed to is incorrectly spelled, the tool tip will contain a few suggestions.
    let lines = spellsuggest( spellbadword( v:beval_text )[ 0 ], 5, 0 )
  else
    let numLines = foldEnd - foldStart + 1

    " Up to 31 lines get shown okay; beyond that, only 30 lines are shown with ellipsis in between to indicate too much.
    " The reason why 31 get shown okay is that 30 lines plus one of ellipsis is 31 anyway...
    if ( numLines > 31 )
      let lines = getline( foldStart, foldStart + 14 )
      let lines += [ '-- Snipped ' . ( numLines - 30 ) . ' lines --' ]
      let lines += getline( foldEnd - 14, foldEnd )
    else
      let lines = getline( foldStart, foldEnd )
    endif
  endif

  return join( lines, has( "balloon_multiline" ) ? "\n" : " " )
endfunction

set balloonexpr=BalloonExpr()

Now, if the mouse is hovering on a fold, this will show the contents of the fold in the tooltip.  If the number of folded lines is too big, it will display the first and last 15 lines only, with a comment in between indicating the number of lines that it ate.

If, however, the cursor is on a misspelled word (only works if 'spell' -- another Vim 7 feature -- is set), then the tooltip will instead display a small set of suggestions for correction.

VimTip 1150: Java/C/C++ folding
http://vim.sourceforge.net/tip_view.php?tip_id=

Here are some functions I use to fold Java code; they are probably easily applicable to C/C++ code also:

" Javadoc comments (/** and */ pairs) and code sections (marked by {} pairs) mark the start and end of folds.  All other
" lines simply take the fold level that is going so far.
function! MyFoldLevel( lineNumber )
  let thisLine = getline( a:lineNumber )

  " If the entire Javadoc comment or the {} pair is on one line, then don't create a fold for it.
  if ( thisLine =~ '\%(\%(/\*\*\).*\%(\*/\)\)\|\%({.*}\)' )
    return '='
  elseif ( thisLine =~ '\%(^\s*/\*\*\s*$\)\|{' )
    return "a1"
  elseif ( thisLine =~ '\%(^\s*\*/\s*$\)\|}' )
    return "s1"
  endif

  return '='
endfunction

setlocal foldexpr=MyFoldLevel(v:lnum)
setlocal foldmethod=expr

The 'foldexpr' basically folds away multi-line JavaDoc and {} blocks.  This is different from setting up:

set foldmethod=marker
set foldmarker={,}

in that it also fold away JavaDocs -- the {} pair folding is the same effect as these two settings, however.

I need to improve this to also fold away imports; any suggestions would be great!

VimTip 1151: [I search visually
http://vim.sourceforge.net/tip_view.php?tip_id=

To display all the lines where the word under the cursor occurs, simply do in Normal mode: [I

This can be useful to find a count of lines of search occurences. Each line displayed is numbered. Try it to see for yourself :)

In order to jump to the <n>th line of occurence, do: <n>[<Tab>
This means type in the <n>umber first, hit '[', and then the Tab button. If <n> is not typed, the jump defaults to the line where the first (uncommented) word appears.

The function and mappings below allow for [I and <n>[<Tab> to work in visual mode too, so that the search will be done for the visual highlight.
===
"place in vimrc
nmap <silent>[I     :<C-u>cal OSearch("nl")<CR>
nmap <silent>[<Tab> :<C-u>cal OSearch("nj")<CR>
vmap <silent>[I     :<C-u>cal OSearch("vl")<CR>
vmap <silent>[<Tab> :<C-u>cal OSearch("vj")<CR>

function! OSearch(action)
  let c = v:count1
  if a:action[0] == "n"
    let s = "/\\<".expand("<cword>")."\\>/"
  elseif a:action[0] == "v"
    execute "normal! gvy"
    let s = "/\\V".substitute(escape(@@, "/\\"), "\n", "\\\\n", "g")."/"
    let diff = (line2byte("'>") + col("'>")) - (line2byte("'<") + col("'<"))
  endif

  if a:action[1] == "l"
    try
      execute "ilist! ".s
    catch
      if a:action[0] == "v"
        normal! gv
      endif
      return ""
    endtry
    let c = input("Go to: ")
    if c !~ "^[1-9]\\d*$"
      if a:action[0] == "v"
        normal! gv
      endif
      return ""
    endif
  endif

  let v:errmsg = ""
  silent! execute "ijump! ".c." ".s
  if v:errmsg == ""
    if a:action[0] == "v"
      execute "normal! ".visualmode().diff."\<Space>"
    endif
  elseif a:action[0] == "v"
    normal! gv
  endif
endfunction
===

References:
vimtip#116
vimtip#563
:help [I
:help :ilist
:help :ijump

VimTip 1152: Improved version of Highlight_Matching_Paren
http://vim.sourceforge.net/tip_view.php?tip_id=

This tip requires VIM 7.0 with the searchpairpos function and CursorMoved autocommands.
It is an improved version of the example code which now only matches parens outside of strings or comments.
See :help match-paren for details.

let s:paren_hl_on = 0

function! s:skip_string_or_comment()
    let attr = synIDattr(synIDtrans(synID(line("."), col("."), 0)), "name")
    if attr ==? 'constant' || attr ==? 'comment'
        return 1
    else
        return 0
    endif
endfunction

function! s:Highlight_Matching_Paren()
    if s:paren_hl_on
        match none
        let s:paren_hl_on = 0
    endif
    let c_lnum = line('.')
    let c_col = col('.')

    if s:skip_string_or_comment() != 0
        return
    endif

    let c = getline(c_lnum)[c_col - 1]
    let plist = split(&matchpairs, ':\|,')
    let i = index(plist, c)
    if i < 0
        return
    endif
    if i % 2 == 0
        let s_flags = 'nW'
        let c2 = plist[i + 1]
    else
        let s_flags = 'nbW'
        let c2 = c
        let c = plist[i - 1]
    endif
    if c == '['
        let c = '\['
        let c2 = '\]'
    endif

    let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, 's:skip_string_or_comment()')

    if m_lnum > 0 && m_lnum >= line('w0') && m_lnum <= line('w$')
        exe 'match Todo /\(\%' . c_lnum . 'l\%' . c_col .
                    \ 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
        let s:paren_hl_on = 1
    endif
endfunction

autocmd CursorMoved,CursorMovedI * call s:Highlight_Matching_Paren()
autocmd InsertEnter * match none

VimTip 1153: apply range to any command that does not accept ranges
http://vim.sourceforge.net/tip_view.php?tip_id=

Some commands do not accept ranges, but you want to execute for every line in the range.
This trick allows to apply the range to any command that does not accept range directly:
    :n1,n2 g/^/ command
That is, you add g/^/ between the range and the command.

Credit: Tim Chase

VimTip 1154: auto selections with mouse.
http://vim.sourceforge.net/tip_view.php?tip_id=

With this tip, just selecting text with mouse in gvim, will copy that text
to the clipboard for pasting into other applications (on MSwin and on Xwindows (ala Xterms))

Put these commands in ~/.gvimrc

" Method 1 (for Xwindows and mswindows), this map is different from the one shown in vim documentation:
:noremap <LeftRelease> "+y<LeftRelease>

" Method 2 (works only on ms-windows vim63):
:set guioptions=a

For advanced discussions on clipboard see vim doc.

VimTip 1155: Easier 'set'
http://vim.sourceforge.net/tip_view.php?tip_id=

This function/command works just like the built-in 'set' except that it escapes out the spaces on the rhs, making things a bit more easy:

Regular set:
  set fp=par\ 70j

Our set:
  Set fp=par 70j

Just like the regular 'set', multiple options may still be specified:

  Set fp=par 70j tw=100 ai! ai?

The only known caveat is in single word options:

  Set fp=par 70j ai

What you'll end up with is 'fp' set to 'par 70j ai' because Set uses the presence of the =, ! or ? symbols to differentiate the current word as the start of a new option rather than part of the last one.

Of course, there is no real reason to use Set unless there is an obscure set, such as:

  Set mp=texify -b -p --src-specials %

vs.
  set mp=texify\ -b\ -p\ --src-specials\ %

Of course, there is:

  let &mp='texify -b -p --src-specials %'

I like the ability to use Set, however; requires much less thought and planning:  if I do a regular 'set' and get an error, I just go up a line in the command-line history and change the 'set' to 'Set' and forget it...

function! Set( ... )
  let result = ''

  for i in a:000
    if ( i !~ '[=!?]' )
      let result .= '\'
    endif

    " Escaping out any existing spaces takes care of the case where we passed in escaped spaces.
    let result .= ' ' .escape( i, ' ' )
  endfor

  execute 'set' .result
endfunction
com! -nargs=+ -complete=option Set call Set( <f-args> )

This has been written for Vim 7, but replacing the above loop using something like this should make it work for 6.x:

let count = 1
while ( exists( 'a:' . count ) )
  let i = a:{count}

  if ( i !~ '[=!?]' )
    let result = result . '\'
  endif

  " Escaping out any existing spaces takes care of the case where we passed in escaped spaces.
  let result = result . ' ' .escape( i, ' ' )

  let count = count + 1
endwhile

VimTip 1156: View Source from Internet Explorer in gvim
http://vim.sourceforge.net/tip_view.php?tip_id=

Turns out that Internet Explorer executes "Notepad %1" when a user says view source by right clicking etc

so just drop a "Notepad.bat" on your desktop,  to execute your choicest scripts, which in this case would be

gvim %1

above will start gvim with the source. simple.

oh! and the file notepad.bat has to be on "your desktop"

VimTip 1157: from vim to web search... via firefox & google
http://vim.sourceforge.net/tip_view.php?tip_id=

vmap g "gy:silent! exec 'cd C:\Archivos de programa\Mozilla Firefox\ <bar> !Start firefox "www.google.com/search?q='@g'&ie=utf-8"'<cr>

VimTip 1158: Duplicate Previous Line, Word by Word
http://vim.sourceforge.net/tip_view.php?tip_id=

Hi Vimsters,
This is a simple tip, which I have found REALLY useful for coding and documentation. So much so that I've allocated it
two precious function buttons.

Mary had a little lamb<Press F2>
Mary <press F1>
Mary had<press F1>
Mary had a<etc etc>

imap <F1>  @<ESC>kyWjPA<BS>
nmap <F1>  @<ESC>kyWjPA<BS>

imap <F2>  <ESC>o<ESC>kyWjPA<BS><space>
nmap <F2>  <ESC>o<ESC>kyWjPA<BS><space>

Please consider giving it a try you'll likely find it addictive

(thanks to various contributors to this tip)
zzapper vimtip #305

VimTip 1159: Prevent frequent commands from slowing things down
http://vim.sourceforge.net/tip_view.php?tip_id=

This function will work in Vim 6.3+, though I designed it specifically to work around the new Vim 7 CursorMoved and CursorMovedI autocommands that trigger every time the cursor is, well, moved.

If something happens very frequently (such as through the result of a cursor motion) and takes a small bit of time, repeating the operation can be slow:  for example, holding the h key down (to move left) with a CursorMoved autocommand set up.  The solution that I came up with (after some discussion on the Vim email list) is to prevent the operation from happening unless one of two conditions is met:  either a specified interval since the last time has elapsed OR the operation has been requested a certain number of times.

For example, highlighting the parentheses surrounding the cursor position is nice, but can be slow (because of the search required to locate them); thus:

autocommand CursorMoved * call MatchParens()

Can be slow.  However:

autocommand CursorMoved * if LongEnough( "g:MatchParens"1, 3 ) | call MatchParens() | endif

Makes things a bit better.  Now, the expression 'if LongEnough...' will only return true (1) if either at least 1 second has elapsed since the last time it returned true OR, if 1 second has NOT yet elapsed (because a motion key was held down, repeatedly triggering the autocommand), then it will return true (1) only once every third time, basically compromising the update frequency for a gain in speed.  If the cursor hangs around anywhere for more than a second, then the next time it's moved, it'll get updated.

Note that this is different from CursorHold because we're not triggering on IDLE behaviour (which is passive), but rather on actual movement (which is active).  Of course, it is often useful to combine the two, as in this example:

autocommand CursorHold call MatchParens()

The CursorHold doesn't require a delay in processing because it is only called after a delay...

Note that the first parameter is the name of the variable in which the timer values will be stored (to determine how long it has been since the last time it was invoked) and another variable with the name of <yourVar>_callCount will be created -- in this example, it would be g:MatchParens_callCount -- to hold the number of times it has been called since the last invocation.

You CAN just call LongEnough with the variable name and a time, in which case it will only allow the trigger after the time has elapsed, ignoring the total number of invocations altogether.

" Returns true if at least delay seconds have elapsed since the last time this function was called, based on the time
" contained in the variable "timer".  The first time it is called, the variable is defined and the function returns
" true.
"
" True means not zero.
"
" For example, to execute something no more than once every two seconds using a variable named "b:myTimer", do this:
"
" if LongEnough( "b:myTimer", 2 )
"   <do the thing>
" endif
"
" The optional 3rd parameter is the number of times to suppress the operation within the specified time and then let it
" happen even though the required delay hasn't happened.  For example:
"
" if LongEnough( "b:myTimer", 2, 5 )
"   <do the thing>
" endif
"
" Means to execute either every 2 seconds or every 5 calls, whichever happens first.
function! LongEnough( timer, delay, ... )
  let result = 0

  let suppressionCount = 0
  if ( exists( 'a:1' ) )
    let suppressionCount = a:1
  endif

  " This is the first time we're being called.
  if ( !exists( a:timer ) )
    let result = 1
  else
    let timeElapsed = localtime() - {a:timer}

    " If it's been a while...
    if ( timeElapsed >= a:delay )
      let result = 1
    elseif ( suppressionCount > 0 )
      let {a:timer}_callCount += 1

      " It hasn't been a while, but the number of times we have been called has hit the suppression limit, so we activate
      " anyway.
      if ( {a:timer}_callCount >= suppressionCount )
        let result = 1
      endif
    endif
  endif

  " Reset both the timer and the number of times we've been called since the last update.
  if ( result )
    let {a:timer} = localtime()
    let {a:timer}_callCount = 0
  endif

  return result
endfunction

VimTip 1160: Auto Save files when focus is lost.
http://vim.sourceforge.net/tip_view.php?tip_id=

This tip is a time saver, when in one gvim window you are editing some
source files and in other windows you are compiling/debugging
the same source. Especially useful with window AutoRaise feature.

Enable it with
:call Mosh_FocusLost_SaveFiles()

" Put this in ~/.vimrc, add custom commands in the func
function! Mosh_FocusLost_SaveFiles()
    :exe ":au FocusLost" expand("%") ":wa"
endfunction

then whenever the mouse leaves the gvim window, the
edited file will be saved to disk.

VimTip 1161: Updating the functionality of :windo
http://vim.sourceforge.net/tip_view.php?tip_id=

The :windo, :bufdo, :argdo (and, in Vim 7, :tabdo) series of commands are great.  However, they have one side-effect that I don't like:  they change the current window/buffer/tab and make it the last one.  Toward that end, I have the following commands defined in my environment:

" Just like windo but restores the current window when it's done
function! WinDo(command)
  let currwin=winnr()
  execute 'windo ' . a:command
  execute currwin . 'wincmd w'
endfunction
com! -nargs=+ -complete=command Windo call WinDo(<q-args>)

" Just like Windo except that it disables all autocommands for super fast processing.
com! -nargs=+ -complete=command Windofast noautocmd call WinDo(<q-args>)

" Just like bufdo but restores the current buffer when it's done
function! BufDo(command)
  let currBuff=bufnr("%")
  execute 'bufdo ' . a:command
  execute 'buffer ' . currBuff
endfunction
com! -nargs=+ -complete=command Bufdo call BufDo(<q-args>)

Using them is no different from using the standard :windo or :bufdo, except that when you're done, you're right back where you were.

Examples:

:Windofast set nu

Turns on line-numbers in all windows -- quickly (because no autocommands trigger) -- and leaves your cursor exactly where it was so that you may continue with what you were doing.

Here's another example, one that I have defined permanently (this is in keeping with other tips already provided, so I'm not enclosing it as a separate tip):

function! SetAutoSaveAndRestore( enable )
  augroup SaveAndRestoreAll
    au!
    if a:enable
      au FocusLost * silent! Windo call UpdateIfPossible()
      au FocusGained * silent! checktime
    endif
  augroup END
endfunction
" Automatically write all changed buffers every time we move out of the Vim window
call SetAutoSaveAndRestore( 1 )

" Writes out the current file if it isn't read-only, has changed and has a name; useful from the autocommand that saves
" all files upon Vim's losing focus.
function! UpdateIfPossible()
  if expand('%') == ''
    return
  elseif &ro || !&modified
    return
  endif

  update
endfunction

Whenever the Vim window is left (to go to an IDE for concurrent development, for example), all modified and writable files are saved.  Conversely, the call to 'checktime' automatically updates the contents of any files that may have been modified with the latest version on disk.

The above should be combined with 'autoread' and 'autowrite' for best results.

VimTip 1162: add closing brace automatically on code blocks
http://vim.sourceforge.net/tip_view.php?tip_id=

When I type an opening brace '{' I want the closing brace '}' to be inserted automatically.  The following abbreviation does that as long as you code in the following style:

class blah
{

}
Just define the following abbreviation and then whenever you hit the '{' you get the rest for free and the cursor is placed between the two braces.

iab { {<CR>}<UP>

I imagine this could be extended to work with brackets as well.

VimTip 1164: How long does a command take to execute?
http://vim.sourceforge.net/tip_view.php?tip_id=

Here's a funcion to help figure out how long something takes to execute -- it's useful for determining which of a number of ways of doing something is faster, for example.

Sample call:  echo HowLong( "echo 'test'", 100 )

This will execute "echo 'test'" 100 times and display the number of seconds it took to do so.

Multiple commands can be separated by a |.

" Times the number of times a particular command takes to execute the specified number of times (in seconds).
function! HowLong( command, numberOfTimes )
  " We don't want to be prompted by a message if the command being tried is an echo as that would slow things down while
  " waiting for user input.
  let more = &more
  set nomore

  let startTime = localtime()

  for i in range( a:numberOfTimes )
    execute a:command
  endfor

  let result = localtime() - startTime

  let &more = more

  return result
endfunction

If using Vim 6, the loop will have to be rewritten as:

let i = 0
while ( i < a:numberOfTimes )
  execute a:command

  let i = i + 1
endwhile

Note that this will skew the time returned somewhat because of the extra operationgs required to do the addition for the loop (which is why I posted the Vim 7 version at all).

Salman.

VimTip 1166: Sort lines - easy use of existing vim capability
http://vim.sourceforge.net/tip_view.php?tip_id=

This is just a reminder of how to take advantage of existing VIM capability. I had not needed to sort before and took a few minutes to find a good example.

Sort lines in vim using blocks:

:<range>!sort

Yes, its that simple.

Key strokes:

1) Place cursor at first line of range to be sorted.
2) Use marker (ma) to mark starting point
3) Go to last line of range to be sorted
4) Issue command from marker (a) to here as follows:
:'a,.!sort

Hope this little reminder helps.

VimTip 1167: Prevent escape from moving the cursor one character to the left
http://vim.sourceforge.net/tip_view.php?tip_id=

From the Vim FAQ:
>10.2. In insert mode, when I press the <Esc> key to go to command mode, the
>     cursor moves one character to the left (except when the cursor is on
>     the first character of the line). Is it possible to change this
>     behavior to keep the cursor at the same column?
>
>No. It is not possible to change this behavior. The cursor is *always*
>positioned on a valid character (unless you have virtual-edit mode
>enabled). So, if you are appending text to the end of a line, when you
>return to command mode the cursor *must* drop back onto the last character
>you typed. For consistency sake, the cursor drops back everywhere, even if
>you are in the middle of a line.
>
>You can use the CTRL-O command in insert mode to execute a single ex
>command and return back to insert mode without moving the cursor column.

If you don't care about consistency and only want the cursor to drop back when necessary when exiting insert mode, try:

inoremap <silent> <Esc> <C-O>:stopinsert<CR>

If the cursor is not on a valid character (for example, at the end of a line), it will still be moved back one character (unless virtual-edit mode is enabled).
If you are in paste mode and hit <Esc>, the cursor will still be moved back one character (since all mappings are ignored in paste mode).
But, otherwise, when using this mapping, <Esc> generally won't move the cursor.

If you have any other mappings which begin with <Esc> (for example, 'map <S-Up> ...' doesn't seem to work right for me, so I use 'map ^[[1;2A ...', which starts with <Esc>), then 'timeoutlen' will apply to this mapping, and the cursor will move one character to the left until 'timeoutlen' expires, then will move back to the proper position.

VimTip 1168: Folding for Plain Text files based on indentation
http://vim.sourceforge.net/tip_view.php?tip_id=

I like to organize my notes/outlines/etc in a heirarchical tree format.  I wanted to be able to hide branches of the heirarchy that I'm not currently working on, but I also wanted to be able to store everything in a plain text file with minimal special formatting to implement the hiding.  So, I decided to use Vim's folding features for this.

Folding based on indentation is the easiest and most intuitive way to hide sections of a file with minimal special formatting.
However, I wanted a section of lines with the same indent to fold into a heading with less indent - the default behavior is to fold into the first line with the same indent:
Unfolded text:
    heading A
        line 1
        line 2
        line 3
    heading B
Default Behavior (folded based on indent):
    heading A
        line 1
    heading B
What I wanted when folded:
    heading A
    heading B

So, I put this in my .vimrc to implement folding:

setlocal foldmethod=expr
setlocal foldexpr=(getline(v:lnum)=~'^$')?-1:((indent(v:lnum)<indent(v:lnum+1))?('>'.indent(v:lnum+1)):indent(v:lnum))
set foldtext=getline(v:foldstart)
set fillchars=fold:\ "(there's a space after that \)
highlight Folded ctermfg=DarkGreen ctermbg=Black

This will create folds based on a single-space indent (I wanted to be able to build a heirarchy many many levels deep, and using a tab for the fold indents very quickly pushed my text off the window, but I didn't want to mess with the tabstop).  Blank lines are folded based on the surrounding indentation (they are not counted as a 0 indent line).

I quickly got annoyed by the default key mappings for folding/unfolding sections, so I remapped Shift-Left/Shift-Right to close/open:
nnoremap ^[[1;2C zo
inoremap ^[[1;2C <C-O>zo
nnoremap ^[[1;2D zc
inoremap ^[[1;2D <C-O>zc
" Shift-Up Shift-Down (incase Shift is held while browsing folds)
nmap ^[[1;2A <Up>
imap ^[[1;2A <Up>
nmap ^[[1;2B <Down>
imap ^[[1;2B <Down>

But, I found that the default mappings for Alt-(Arrows) and CTRL-(Arrows) sometimes caused Vim to do strange stuff, and I would occasionally hit those by accident, so I remapped those as well:
" modified arrow keys do bad things by default
" (<S-Up>, <M-Up>, <C-Up>, etc don't seem to work for me in mappings, so I had to type CTRL-V then the key sequence to
"  get the escape codes you see below.  Unfortunately, since the escape codes begin with an ^] (Esc) character, this
"  means that 'timeoutlen' now applies to <Esc>, making <Esc> respond slower)
" Ctrl-(Up, Down, Left, Right)
noremap ^[[1;5A <Nop>
noremap! ^[[1;5A <Nop>
noremap ^[[1;5B <Nop>
noremap! ^[[1;5B <Nop>
noremap ^[[1;5D <Nop>
noremap! ^[[1;5D <Nop>
noremap ^[[1;5C <Nop>
noremap! ^[[1;5C <Nop>
" Alt-(Up, Down, Left, Right)
noremap ^[[1;3A <Nop>
noremap! ^[[1;3A <Nop>
noremap ^[[1;3B <Nop>
noremap! ^[[1;3B <Nop>
noremap ^[[1;3D <Nop>
noremap! ^[[1;3D <Nop>
noremap ^[[1;3C <Nop>
noremap! ^[[1;3C <Nop>

VimTip 1171: Introduce variable
http://vim.sourceforge.net/tip_view.php?tip_id=

The following is from my .vimrc, and works as a simple "introduce variable". It is sufficient for Python, but for typed languages (e.g. C++, Java) you will need to add a type (int, String, ....) to the start of the new line.

"
" map \v to put x = y on the line above cursor, where
"	x is the last text inserted
"	y is the last text deleted
"
map <leader>v 0wh:put .<CR>a = <Esc>pa<CR><Esc>

Example, given (Python) source code like:
    if x > 3 * y + 4 * z:

You could position the cursor on the 3, then delete the RHS formula, and insert a name for it. You can do the "delete and insert" separately or in one go, e.g. go to the 3 and press "c/:<Cr>formula<Esc>". Or separately as "d/:<Cr>", followed by "iformula<Esc>". In either case you should now see:
    if x > formula:

Then pressing "\v" gives
    formula = 3 * y + 4 * z
    if x > formula:

What it does:
1. Go to start of line
2. Go to before next word
3. Add the last inserted text
4. Add " = "
5. Add the last deleted text
6. Add a <Cr> to separate the new line from the old line (and vim preserves the indentation)

HTH
--
Alan
http://aivipi.blogspot.com

VimTip 1172: Vim FAQ & misc documentation
http://vim.sourceforge.net/tip_view.php?tip_id=

For those of you who do not realize this already, Vimdoc contains some of the most useful information on Vim found on the Internet:

  http://vimdoc.sourceforge.net/

Especially useful is the FAQ at:

  http://www.geocities.com/yegappan/vim_faq.txt
  http://vimdoc.sourceforge.net/htmldoc/vimfaq.html

that answers a lot of basic (and advanced) questions about how to perform tasks in Vim. If you ever had any questions regarding Vim, make sure you do a search through the FAQ first before looking at any other resource.

To make the FAQ part of Vim help, copy the file at:

  http://www.geocities.com/yegappan/vim_faq_help.txt

to the "doc" directory - for example, in Unix/Linux systems:

  $ cp vim_faq_help.txt ~/.vim/doc

Then in Vim, do:

  :helptags ~/.vim/doc

After that, to access the FAQ, do:

  :help FAQ

Also, a must-read is Bram Moolenaar's "Seven Habits of Effective Text Editing" at:

  http://www.moolenaar.net/habits.html

VimTip 1173: Spelling suggestions anywhere, even in console mode
http://vim.sourceforge.net/tip_view.php?tip_id=

A little while ago, I tried out all the spelling plug-ins for vim because
I was doing a bit of a project and needed to make sure it was all
beautifully spelled.  One function that I found really lacking in the
various spelling plug-ins was the ability to make suggestions on the
current word.  Some of them allowed this facility but there were
restrictions, such as only being able to use it in graphical mode and only being
able to use it on certain types of files.  I wanted something that would
work anywhere, whether in some code, in a text doc and that would work
in console mode.  I also wanted to see how easily I could in-line some
perl into a vim script to perform some function on it.  The answer to
that was that it's not impossible, but it's a bit ugly!

Anyway, here's the function I created.  I use it all the time now so I
hope you get some use out of it too.

----------------------------------------------------------------------------------
" F7 Will give some spelling suggestions for the current word in any mode
nmap <F7> \ss
vmap <F7> <C-C> \ss
omap <F7> \ss
map! <F7> <C-C> \ss
noremap <silent> \ss :call SuggestWord()<return>

"Make some spelling suggestions for the current word, and allow you to change it for the word you prefer
"Requires ispell and perl
"By Ben Staniford: http://www.staniford.net
function! SuggestWord ()
	let rw = tempname()
	let oldspelling = expand("<cword>")

	"Run ispell on the word under the cursor and prompt us for a choice, then save it to a temp file
	exe '!echo -n '.oldspelling.' | ispell -a -S | perl -e '."\x27".'print "\n\n\n";'.
		\ 'while(<>) {if(/.*:\s(.*$)/){$m=1;@a=split ", ",$1;print "Suggestions: [CTL-C to abort]\n";'.
		\ 'for (@a) {print ++$i.")$_  "} print "\n>"; open (I, "/dev/tty"); $b=<I>; open(RW,">'.rw.'");'.
		\ 'print RW "$a[$b-1]";}}if($m\!=1){print "No Suggestions\n"}'."\x27"

	"If the user selected a word and it was saved, read it now
	if filereadable(rw)
		exe 'read ! cat '.rw
		exe "normal \"adw"
		exe "normal ddk"
		exe "normal /".oldspelling."\<CR>"
		exe "normal cw"
		"Print the word slightly differently if we're at the beginning of a line
		if (wincol() == 1)
			exe "normal \"aP"
		else
			exe "normal \"ap"
		endif
	endif

endfunction "SuggestWord()

----------------------------------------------------------------------------------

VimTip 1174: Syntax highlighting for LJ and html-enabled web forums
http://vim.sourceforge.net/tip_view.php?tip_id=

Vim is known to be able to generate html code for syntax highlighting of source currently edited. Though, not all is Ok with this code. A pity, but standard command TOhtml places color of background and default foreground into tag <body>, so after posting this code into livejournal,(or any other html-enabled web forum) these colors simply disappear.
I propose a little function solves problem described

fun! MyToHtml(line1, line2)
	exec a:line1.','.a:line2.'TOhtml'
	%g/<body/normal k$dgg
	%s/<body\s*\(bgcolor="\#[a-f0-9]\{6\}"\)\s*text=\("\#[a-f0-9]\{6\}"\)\s*>/<table><tr><td \1><font color=\2>/
	%s#</body>\(.\|\n\)*</html>#</font></td></tr></table>#i
endf

command -range=% MyToHtml :call MyToHtml(<line1>,<line2>)

Now you can select any range of lines, type :MyToHtml and use result to post your code to livejournal or html-enabled web forum

VimTip 1177: manually indent block without dealing with deselection problems
http://vim.sourceforge.net/tip_view.php?tip_id=

If you want to manually indent a block selected in visual mode, you
come up against the following problem:  As soon as you select the
block and indent it with >> the block is deselected so you can't
indent it another level.  This forces you to reselect the same block
and start again.

(I admit that you could just prefix the > with a number (eg. 5> ) to
get it to indent 5 levels but this isn't practical if you are not sure
exactly how many indents are required to get the block to line up with
whatever is above it)

To get around this problem, use a rectangular selection, combined with
the 'I' insert mode.  For example:

Hit ESC to enter normal mode, then the zero key to move to the first
column of the line. Hit Ctrl-V and select a rectangular block which
covers the first column of every line in the block you want to indent.
Next, hit the 'I' key to enter special insert mode, then hit the
tab key until you have the desired indent level. Only the first line
of the block will be affected while you are tabbing but once you have
it in the correct position, hit the ESC key and all the rest will line
up.

VimTip 1178: Simple function to add a full link-tag with automatic title
http://vim.sourceforge.net/tip_view.php?tip_id=

If you use vim to edit html-pages or (like me using nanoblogger) your blog-entries you sometimes want to enter links of the form: <a href="somelink" target="sometarget">title of the page</a>

With the following script (which only works under unix if you have the lynx-browser installed) you are interactively asked which url to add, which target to use (with the default "_blank"). The title of the page is automagically parsed from the source of the linked page using lynx.

This is the very first vim-skript I ever wrote. So I fear this isn't the most elegant way to do this task. An mapping is added to call the function using <leader>al (add link). I don't know if map is the correct command to use. Unfortunately I couldn't find documentation about the various map-commands in the vim-help. Hints?

So here's the script

" This small function simplifies the addition of links to an html-Page. The
" title of the linked page automagically is requested and added to the output
" The line is added after the current line.
"
" Author: Gerhard Siegesmund <jerri@jerri.de>

map <leader>al :call AddLinkToText()<CR>

function! AddLinkToText()
  let url = input("URL to add? ", "")
  if strlen(url) == 0
    return
  endif

  " Save b register
  let saveB = @b

  " Get the target
  let target = input("Target for this link? ", "_blank")
  if strlen(target) > ""
    let target = " target=\"" . target . "\""
  endif

  " Get the source of the page
  let code = system("lynx -dump -source " . url)

  " Find the title of the page
  let title = substitute(code, '.*head.*<title[^>]*>\(.*\)<\/title>.*head.*', '\1', '')
  if title == code
    " If nothing changed we couldn't find the regular expression
    let title = "Unknown"
  endif
  " Remove newline-characters (not yet tested!)
  let title = substitute(title, "\n", " ", "g")

  " Output the code
  let @b = "<a href=\"" . url . "\"" . target . ">" . title . "</a>"
  put b

  " Restore b register
  let @b = saveB
endfunction

VimTip 1180: Searching for lines NOT containing pattern
http://vim.sourceforge.net/tip_view.php?tip_id=

When examining a programs very long output, you might
wish to lookup lines NOT containing some word. For
lines not containing "Warning" the pattern is:

/^\(.*Warning\)\@!.*$
  or
\v^(.*Warning)@!.*$

VimTip 1181: Using PuTTY's pscp along with Vim
http://vim.sourceforge.net/tip_view.php?tip_id=

Have you ever wished that you could compare a text file on your Windoze machine with one on your FreeBSD|Redhat box? Now you can!

In addition to Vim (which you'll have anyway) you'll need PSCP (which you can download from http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html ) and diff.exe. If you are using Pageant you will not even have to worry about passwords!

Add to your .vimrc:

"""" 20060318 paj using PSCP on Windows. N.B: Works best with Pageant.
if ($OS =~"Windows")
    let g:netrw_scp_cmd="\"c:\\Program Files\\PuTTY\\pscp.exe\" -q -batch"
endif

C:\>vim -d \path\to\vimfiles\colors\primitive.vim scp://user@my.host/path/to/.vim/colors/primitive.vim

For further information on Vim's scp capabilities, see:

:he scp

--paj

--
Pete Johns                                   <http://johnsy.com/>
Tel/Fax numbers and IM information:  <http://johnsy.com/contact/>
Bebo and co.       <http://johnsy.com/blog/?entry=20060318201737>

VimTip 1182: vim explorer tip using CTRL-6
http://vim.sourceforge.net/tip_view.php?tip_id=

:Explore gives the explorer window in the vim, which helps you explore the contents of the directory.

<ul><b>enter</b> on a filename or the directory name takes you to that particular directory.
<ul>To return back to the explorer window, you can use <u><b>CTRL-6<b></u>

[count]CTRL-6 or CTRL-^ is basically a file editing command which helps in alternating between previously edited file. With explorer you can enter file and exit to explorer again.

More information
:help file-explorer
:help CTRL-6

VimTip 1183: Insert-mode only CAPS Lock
http://vim.sourceforge.net/tip_view.php?tip_id=

This is a hack to provide CAPS Lock functionality only within these situations, so you don't have to turn the CAPS Lock off whenever you return to Normal mode:

- Insert mode
- Command-line mode
- when entering a search pattern
- the argument of the commands that accept a text character, such as "r" and "f"
- for the input() line

First, place the mappings below === into your vimrc. Then, to toggle the CAPS Lock in *Insert mode*, hit Ctrl-6 (i.e., hold down Ctrl and press 6) instead of the _real_ Caps Lock key.

===
lnoremap a A
lnoremap b B
lnoremap c C
lnoremap d D
lnoremap e E
lnoremap f F
lnoremap g G
lnoremap h H
lnoremap i I
lnoremap j J
lnoremap k K
lnoremap l L
lnoremap m M
lnoremap n N
lnoremap o O
lnoremap p P
lnoremap q Q
lnoremap r R
lnoremap s S
lnoremap t T
lnoremap u U
lnoremap v V
lnoremap w W
lnoremap x X
lnoremap y Y
lnoremap z Z

lnoremap A a
lnoremap B b
lnoremap C c
lnoremap D d
lnoremap E e
lnoremap F f
lnoremap G g
lnoremap H h
lnoremap I i
lnoremap J j
lnoremap K k
lnoremap L l
lnoremap M m
lnoremap N n
lnoremap O o
lnoremap P p
lnoremap Q q
lnoremap R r
lnoremap S s
lnoremap T t
lnoremap U u
lnoremap V v
lnoremap W w
lnoremap X x
lnoremap Y y
lnoremap Z z
===

References:
:help language-mapping
:help i_ctrl-^
vimtip#1083

VimTip 1185: change to directory of the opened file
http://vim.sourceforge.net/tip_view.php?tip_id=

The present working directory can be found in the vim by
:pwd
To change to the directory of the currently opened file.
:cd %:h

Related:
:help filename-modifiers
comp.editors at googlegroups - got this tip with the search for my need.

VimTip 1187: Extension of cursor through CaMeL case
http://vim.sourceforge.net/tip_view.php?tip_id=

This is an extension of

  vimtip#1016: Moving through camel case words

Please read it to understand the basis of this following tip.

In the basic case of vimtip#1016, the cursor would move through capital letters and word beginnings. Essentially,

  :let g:camelchar = "A-Z"

would be the regex that defines how Ctrl-Left and Ctrl-Right would move the cursor backwards and forward, respectively.

We could include numbers, for instance, since there are times when numbers are lodged in together with an alphabetical word, or in equations, and we wish to have the cursor stop on the number itself for us to edit:

  :let g:camelchar = "A-Z0-9"

We could then extend this to include "." to denote end-of-sentence or class member, "," to denote list separator, ";" to denote end-of-programming-statement, {[( bracket starts, and "'` quotes to define strings/items, etc.

  :let g:camelchar = "A-Z0-9.,;:{([`'\""

This tip is basically a customized Shift-Left/Right functionality. The cursor will either stop at

1. the beginning of a word
2. the beginning of a run of g:camelchar's
3. a g:camelchar followed by a run of non-g:camelchar's
4. the start of the file
5. the end of the file

===
"place these 4 lines in vimrc
nnoremap <silent><C-Left>  :<C-u>cal search('\<\<Bar>\%(^\<Bar>[^'.g:camelchar.']\@<=\)['.g:camelchar.']\<Bar>['.g:camelchar.']\ze\%([^'.g:camelchar.']\&\>\@!\)\<Bar>\%^','bW')<CR>
nnoremap <silent><C-Right> :<C-u>cal search('\<\<Bar>\%(^\<Bar>[^'.g:camelchar.']\@<=\)['.g:camelchar.']\<Bar>['.g:camelchar.']\ze\%([^'.g:camelchar.']\&\>\@!\)\<Bar>\%$','W')<CR>
inoremap <silent><C-Left>  <C-o>:cal search('\<\<Bar>\%(^\<Bar>[^'.g:camelchar.']\@<=\)['.g:camelchar.']\<Bar>['.g:camelchar.']\ze\%([^'.g:camelchar.']\&\>\@!\)\<Bar>\%^','bW')<CR>
inoremap <silent><C-Right> <C-o>:cal search('\<\<Bar>\%(^\<Bar>[^'.g:camelchar.']\@<=\)['.g:camelchar.']\<Bar>['.g:camelchar.']\ze\%([^'.g:camelchar.']\&\>\@!\)\<Bar>\%$','W')<CR>
===

VimTip 1188: Use ptags.py to generate tags file for python
http://vim.sourceforge.net/tip_view.php?tip_id=

Ctags is a very useful utility to generate a 'tags' file for C source code which can later be used by vim to locate function definitions, declarations and such even outside of the file you are editing. See vimtip #94 for more details or try :help tags inside vim.

For Python there is a similar program in the standard distribution, usually under /usr/lib/python2.3/Tools/scripts/ptags.py if your Python version is 2.3. This little script will generate a 'tags' file for any number of Python source files and allow you to locate class and function definitions easily while editing a whole set of files.

The content of ptags.py is:

# ptags
#
# Create a tags file for Python programs, usable with vi.
# Tagged are:
# - functions (even inside other defs or classes)
# - classes
# - filenames
# Warns about files it cannot open.
# No warnings about duplicate tags.

import sys, re, os

tags = []    # Modified global variable!

def main():
    args = sys.argv[1:]
    for filename in args:
        treat_file(filename)
    if tags:
        fp = open('tags', 'w')
        tags.sort()
        for s in tags: fp.write(s)

expr = '^[ \t]*(def|class)[ \t]+([a-zA-Z0-9_]+)[ \t]*[:\(]'
matcher = re.compile(expr)

def treat_file(filename):
    try:
        fp = open(filename, 'r')
    except:
        sys.stderr.write('Cannot open %s\n' % filename)
        return
    base = os.path.basename(filename)
    if base[-3:] == '.py':
        base = base[:-3]
    s = base + '\t' + filename + '\t' + '1\n'
    tags.append(s)
    while 1:
        line = fp.readline()
        if not line:
            break
        m = matcher.match(line)
        if m:
            content = m.group(0)
            name = m.group(2)
            s = name + '\t' + filename + '\t/^' + content + '/\n'
            tags.append(s)

main()

VimTip 1189: Maintaing multiple versions of GVim in Windows
http://vim.sourceforge.net/tip_view.php?tip_id=

This is useful when you want to upgrade to the latest version of Vim but want the ability to easily switch back to an old version. I create a symbolic link called 'current' in my $VIM directory to whichever is my current install of Vim. You can create symbolic links to directories on NTFS with the linkd utility in the resource kit:

  C:\Program Files\Vim>linkd current vim70c
  C:\Program Files\Vim>dir
30/03/2006  13:09    <JUNCTION>     current
07/02/2006  17:27    <DIR>          vim63
30/03/2006  09:38    <DIR>          vim64
30/03/2006  13:08    <DIR>          vim70c

I make sure that all shortcuts and registry entries reference GVim as C:\Program Files\Vim\current\gvim.exe, and I can then easily move the current link around to switch versions.

VimTip 1190: source searching for programmers
http://vim.sourceforge.net/tip_view.php?tip_id=

Can be userful for programmers who dig in alien code. Sorta like simplier cscope alternative. Put in ~/.bashrc this bash aliases:

#----8<---------------------------------------
function f() {
  local i o m
    set -f
    test "$ffo" || ffo='! -iname tags'
    for i in "$@"; do
      case "$i" in
        c) ffo='-iname *.[chs]' ;;
        h) ffo='-iname *.[h]' ;;
        x) ffo='-iregex .*\.[chs][xp+]?[xp+]?' ;;
        p) ffo='-iname *.php*' ;;
        q) ffo='! -iname tags' ;;
        -*) o="$o $i" ;;
        *) m="$m $i" ;;
      esac
    done
    test "$m" || return
    find . $ffo -type f -print0 \
    | xargs -0 grep --colour=always --binary-file=without-match -n $o "${m# }" \
    | tee ~/.ff~
    set +f
}
function v() {
  local cmd
  test -s ~/.ff~ || return
  if [ "$*" ]; then
    grep "$*" ~/.ff~ > ~/.ff- || return
    cmd="vim +`head -1 ~/.ff- | cut -d: -f2` `head -1 ~/.ff- | cut -d: -f1 | uniq`"
    history -s $cmd
    $cmd
  else
    perl -pe 's/\033[^a-z]*[a-z]//g' ~/.ff~ > ~/.ff
    vim -q ~/.ff -c :cw5
  fi
}
alias vv='cat ~/.ff~'
#----8<---------------------------------------

then when in source directory you do like:

~/vim63/src$ f ui_inchar_undo
./ui.c:73:ui_inchar_undo(s, len)
./proto/ui.pro:3:void ui_inchar_undo __ARGS((char_u *s, int len));
./os_unix.c:3854:                   ui_inchar_undo(ta_buf, ta_len);
~/vim63/src$ v

`v' will open vim with all found matches in quickfix window. Then press `CTRL-W o' if you want to hide file list. Or:

~/vim63/src$ v ARG

Will execute: `vim +3 ./proto/ui.pro' and put this command in bash history.

Any argument of `f' command could be mode of search:
 c - search in C files
 h - search in C headers
 x - search in C++ files
 p - search in PHP files
 q - search in text files (default).
Last used mode is remembered, so the next examples are equivalent `f c' followed by `f ui_get_shellsize', or just `f c ui_get_shellsize', or `f ui_get_shellsize c'.

Tested on GNU find 4.1.7, grep 2.5, bash 2.05a, vim 6.3.
For older grep remove `--colour=always' option from `f' function or upgrade.

VimTip 1192: Delete everything but the first n fields in a CSV
http://vim.sourceforge.net/tip_view.php?tip_id=

:%s/^\(\(\([^,]\+\),\)\{n - 1}[^,]\+\).*$/\1/

NOTE: Change the "n - 1" to the number of fields you would like to keep minus 1.

For instance, if you would like to to keep the first 5 fields:

:%s/^\(\(\([^,]\+\),\)\{4}[^,]\+\).*$/\1/

VimTip 1193: Syntax highlighting for HTML with embedded Javascript
http://vim.sourceforge.net/tip_view.php?tip_id=

Just use the "htmlm4.vim" syntax script.  (I got this from Tip #1041, but it was non-obvious to somebody looking for a quick answer.)

Put simply, while in command mode, just type the following

:set filetype=htmlm4

You can automatically load this syntax for all html files by adding the following line to your vimrc
au BufRead *.html set filetype=htmlm4

VimTip 1194: Make ]z navigate to the next open fold
http://vim.sourceforge.net/tip_view.php?tip_id=

I think it makes more sense for ]z and [z to navigate to the next/previous open fold, so I added the following to my .vimrc file:

function! GoToOpenFold(direction)

    let start = line('.')


    if (a:direction == "next")
        while (foldclosed(start) != -1)
            let start = start + 1
        endwhile
    else
        while (foldclosed(start) != -1)
            let start = start - 1
        endwhile
    endif


    call cursor(start, 0)

endfunction

nmap ]z :cal GoToOpenFold("next")
nmap [z :cal GoToOpenFold("prev")

VimTip 1195: Reload the same file in different encoding
http://vim.sourceforge.net/tip_view.php?tip_id=

I often need to edit files with different encodings, which can't be detected automatically (for expample, how to distinguish cp866 from cp1251?). So when the desired file was loaded with wrong encoding, I used to type
:e ++enc=<what_was_really_needed> %:p
The following function lightened my work, I guess it'd be useful for the community:
\begin{code}
function! ChangeFileencoding()
    let encodings = ['cp1251', 'koi8-u', 'cp866']
    let prompt_encs = []
    let index = 0
    while index < len(encodings)
       call add(prompt_encs, index.'. '.encodings[index])
       let index = index + 1
    endwhile
    let choice = inputlist(prompt_encs)
    if choice >= 0 && choice < len(encodings)
        execute 'e ++enc='.encodings[choice].' %:p'
    endif
endf
nmap <f8> :call ChangeFileencoding()<cr>
\end{code}
Further, it can be improved by populating the list of encodings from &fileencodings.

VimTip 1196: Replace text to register content with visual selection help
http://vim.sourceforge.net/tip_view.php?tip_id=

After you have copied/yanked a text into register, you can paste it replacing previous text using visual selection.

For example, you can copy one line with 'yy', than point cursor to another line and replace it with previously copied line with 'Vp'

Or if you want cut one word and replace with them another word: cut the word using 'daw', move cursor onto another word and replace with 'vawp'

VimTip 1197: mapping to streamline entering  :ex  commands
http://vim.sourceforge.net/tip_view.php?tip_id=

I've decided to swap ; and : keys since I use the : key so much more often.

I also made a mapping so that ;; puts you directly into the command line edit window.  My fingers always get into a knot when entering a lot of  :ex  commands and editing them often ( :^F  and q:  are nasty combinations because your little finger is always in the wrong place)

" nothing but '<C-V><C-F>' worked, including combinations of "\<C-F"
"cnoremap ; <C-R>= getcmdpos() == 1 ? '<C-V><C-F>A' : ';' <CR>
cnoremap <expr> ; getcmdpos() == 1 ? '<C-F>A' : ';'

silent! nunmap ;
silent! nunmap :
nnoremap <unique> ; :
nnoremap <unique> : ;

VimTip 1198: Automatic Scrolling of text in the vim
http://vim.sourceforge.net/tip_view.php?tip_id=

Many a times you would be happy with the text scrolling automatically at a convenient speed. This helps in places where the text for reading only ( like an ebook), where our only interaction will be scrolling the text. I believe, this might help in speed-reading habits also. ( Any takers?)

To facilitate Automation scrolling vim, do:

map <F8>  <C-E>:sleep 500m<CR><C-E>:redraw<CR><F8>

At the press of <F8> the Auto scrolling starts. Enjoy!  Adjust the speed in the sleep argument.
More information:

:help CTRL-E
:help sleep
:help redraw

Okay, btw, as I said this helps in reading ebooks, The following idea struck me, take a project Guntenbergs books available in .txt format [1] , open it directly using netrw.vim [2], set auto-scrolling on and read easily.

[1]: http://www.gutenberg.org/dirs/etext05/magi10.txt
[2]: http://vim.sourceforge.net/scripts/script.php?script_id=1075

VimTip 1199: Unconditional linewise or characterwise paste
http://vim.sourceforge.net/tip_view.php?tip_id=

If you're like me, you occassionally do a linewise yank, and then want to insert that yanked text in the middle of some other line, (or vice versa).  This function and mapping will allow you to do a linewise or characterwise paste no matter how you yanked the text.

function! Paste(regname, pasteType, pastecmd)
   let reg_type = getregtype(a:regname)
   call setreg(a:regname, getreg(a:regname), a:pasteType)
   exe 'normal "'.a:regname . a:pastecmd
   call setreg(a:regname, getreg(a:regname), reg_type)
endfunction

nmap <leader>lP :call Paste(v:register, "l", "P")<CR>
nmap <leader>lp :call Paste(v:register, "l", "p")<CR>
nmap <leader>cP :call Paste(v:register, "v", "P")<CR>
nmap <leader>cp :call Paste(v:register, "v", "p")<CR>

VimTip 1200: PHP / Mac Hint
http://vim.sourceforge.net/tip_view.php?tip_id=

Open php.net's documentation with the word underneath the cursor

noremap gd ! open http://php.net/<cword><CR>

this is really basic, I don't have a linux/unix box here at the moment to work out how to open a url from the command line but im sure you could just subsitute open for mozilla or firefox or what ever.

VimTip 1202: Go away and come back
http://vim.sourceforge.net/tip_view.php?tip_id=

Like 3 years ago I used to work in program KDevelop and alike. One nice feature that I liked was that I had usually opened more files of one project and when I quit kdevelop and then went back all the files were loaded back again. Using Vim script this can be done in Vim too.

The following script will save plenty of settings (see :h mksession) on vim exit and loads these settings when you enter vim again.
The settings are associated (by this script) to the directory from where you've started vim. That is, for example you start vim from directory
/home/mynick/project/foo, edit multiple buffers and then exit without closing these buffers, later when you want to continue this work, you go to the same
directory, run vim and all the buffers, mappings and other settings will be loaded back as when you've left.

To run it, just paste following script to ~/.vimrc file:

######################################################

function! MakeSession()
    let b:sessiondir = $HOME . "/.vim/sessions" . getcwd()
    if (filewritable(b:sessiondir) != 2)
        exe 'silent !mkdir -p ' b:sessiondir
        redraw!
    endif
    let b:filename = b:sessiondir . '/session.vim'
    exe "mksession! " . b:filename
endfunction

function! LoadSession()
    let b:sessiondir  = $HOME . "/.vim/sessions" . getcwd()
    let b:sessionfile = b:sessiondir . "/session.vim"
    if (filereadable(b:sessionfile))
        exe 'source ' b:sessionfile
    else
        echo "No session loaded."
    endif
endfunction

au VimEnter * :call LoadSession()
au VimLeave * :call MakeSession()

######################################################

Without corrections this script will work only on UN*X like systems.

VimTip 1203: mapping to set up vtreeexplorer and taglist in left side of window
http://vim.sourceforge.net/tip_view.php?tip_id=

A simple mapping to quickly set up a couple of VTreeExplorer (http://www.vim.org/scripts/script.php?script_id=184) and TagList (http://www.vim.org/scripts/script.php?script_id=273) in the left side of your VIM window. Add the following to your vimrc:

map <F12> <ESC>:Tlist<CR>^Wh^Ws:VTreeExplore<CR>:set nonu<CR>^Wl

Be sure to enter the ^W\'s as CTRL-V CTRL-W.

The mapping does the following:
* Opens the TagList (opens left by default).
* Switches to the TagList window and splits it.
* Opens VTreeExplorer in the split window.
* Turns of line numbering in the VTreeExplorer.
* Switches back to the window where you started.

I find this very useful, maybe you will too :)

VimTip 1204: Send To Printer Fast ( ha! ha! ha! )
http://vim.sourceforge.net/tip_view.php?tip_id=

Sometimes after viewing something, you want to see a hardcopy of it. VIM provides a command for this:

:hardcopy

On MS-Windows a typical printers dialog box is displayed. Once you OK that box,  VIM sends the document off to the printer. I thought that was great! But how could i do that faster?

Shortly after learning that command I quickly learned the comnmad

:ha

and that would do the exact same thing. Was there an even FASTER way to do that? The answer to that question is: YES. You can type

:ha!

and that will send it right off to the default printer wtihout a dialog box stopping you!
When I first learned of ":ha!" I smiled all day!  It was slick!

PS - For systems other than MS-Windows, these commands will work slightly differently. See the Docs for details.

PPS - Everytime I type ":ha!" I hear Nelson Muntz saying "ha ha!"  LOL

VimTip 1206: Grab (and remove) up to the nth slash
http://vim.sourceforge.net/tip_view.php?tip_id=

Lets say you find a list of files:

:r !find / -name blahblah -ls

and get the following:

3139934    4 -rw-r--r--   1 dude    dude         600 Feb  3 13:25 /var/www/lawwebdev.blahblah.com/cgi-bin/Archives/ESS.2005050
3010144    4 -rw-r--r--   1 mang     mang         1848 Mar 31 09:35 /var/www/lawwebdev.blahblah.com/cgi-bin/blahblah.pl
1964295    4 -rw-r--r--   1 apache   apache        597 Mar  8 11:48 /var/www/lawweb.blahblah.com/cgi-bin/blahblah.pl
2339286    4 -rw-r--r--   1 mang     mang         1851 Mar 31 09:29 /var/www/lawweb.blahblah.com/cgi-bin/blahblah.pl
3010157    4 -rw-r--r--   1 mang     mang         1940 Mar 31 10:44 /var/www/lawwebtest.blahblah.com/cgi-bin/blahblah.pl
294691    4 -rw-r--r--   1 mang     mang         1848 Apr 10 16:02 /tmp/PMT/blahblah.pl
1880561    4 -rw-r--r--   1 mang     mang         2432 Feb 22 13:49 /usr/local/scripts/prod/blahblah.pl
1880565    4 -rw-r--r--   1 mang     mang         1700 Mar 30 14:44 /usr/local/scripts/dev/blahblah.pl
899894    4 -rw-r--r--   1 mang     mang         1848 Mar 31 09:48 /usr/local/scripts/dev/Gold/base/blahblah.pl
1880626    4 -rw-r--r--   1 mang     mang         1699 Mar 30 14:46 /usr/local/scripts/test/blahblah.pl

Now, you'd like to just have a list of files without the rest of the info...

Issue the global replace as follows:

:%s/^.\{-}\ze\///

That leaves you with a nice list:

/var/www/lawwebdev.blahblah.com/cgi-bin/Archives/ESS.20050506/Archives/blahblah.pl
/var/www/lawwebdev.blahblah.com/cgi-bin/blahblah.pl
/var/www/lawweb.blahblah.com/cgi-bin/blahblah.pl
/var/www/lawweb.blahblah.com/cgi-bin/blahblah.pl
/var/www/lawwebtest.blahblah.com/cgi-bin/blahblah.pl
/tmp/PMT/blahblah.pl
/usr/local/scripts/prod/blahblah.pl
/usr/local/scripts/dev/blahblah.pl
/usr/local/scripts/dev/Gold/base/blahblah.pl
/usr/local/scripts/test/blahblah.pl

If you want two levels deep you can wrap the atom being grabbed in escaped parens and quantify it with braces:

:%s/^\(.\{-}\ze\/\)\{3}//

Note, if you want two levels deep, you need to grab three atom's worth of stuff, all the junk to the left of the first slash, then the first two levels of dirs.

Many thanks to Gary Johnson in comp.editors (http://groups.google.com/group/comp.editors/browse_thread/thread/fe1227b74430444a).

VimTip 1212: Open Filenames containing Spaces with gf
http://vim.sourceforge.net/tip_view.php?tip_id=

One great feature of vim I personally use a lot, is using gf for navigating within vim and opening other files. Unfortunatelly vim cannot out of the box handle file or path names that contain white space. If you want to be able to open filenames names that contain whitespace you need to adjust the isfname option.
This option specifies which characters are valid for filenames. If you want a blank to be considered as a valid character for filenames, simply add the ASCII Char 32 to the option like this:
:set isfname+=32
This adds the ASCII char decimal 32 which represents a space to the allowed characters.

For more information see :h 'isfname'

VimTip 1213: better indent support for php with html
http://vim.sourceforge.net/tip_view.php?tip_id=

1) Append the indent/html.vim to indent/php.vim
(from if exists('g:html_indent_tags'), and everything below)

2) Create a function in php.vim

function! GetPhpHtmlIndent(lnum)
    let html_ind = HtmlIndentGet(a:lnum)
    let php_ind = GetPhpIndent()
   " priority one for php indent script
    if php_ind > -1
	return php_ind
    endif
    if html_ind > -1
	return html_ind
    endif
    return -1

endfunction

3) set setlocal indentexpr=GetPhpHtmlIndent(v:lnum) in php.vim

4) Search for ' [-- special handling for <pre>: no indenting --]' in php.vim and append the following:

    " [-- special handling for <pre>: no indenting --]
    if getline(a:num) =~ "^<?" && (0< searchpair('<?', '', '?>', 'nWb')
		\ || 0 < searchpair('<?', '', '?>', 'nW'))
	" we're in a line with </pre> or inside <pre> ... </pre>
	return -1
    endif

5) some more improvement: add: ',>' to the indentkeys in php.vim

Probably some bugs, but MUCH better than before! Please improve.

VimTip 1214: Recursive vimgrep
http://vim.sourceforge.net/tip_view.php?tip_id=

It doesn't suggest this in the help for "vimgrep" directly, but

:vimgrep **

will search recursively.

VimTip 1215: Resize splits more quickly
http://vim.sourceforge.net/tip_view.php?tip_id=

You know that you can use "<c-w> +" and "<c-w> -" to resize a split window, but did you know you can repeat the resize commands (ie: "10<c-w>+" will increase the window size by 10).

While this is a basic tip, I sometimes need to split windows in terminals and ended up killing my fingers while resizing them until I realized that the command could be repeated.

Other resizing tips are: http://www.vim.org/tips/tip.php?tip_id=427

--Robert

VimTip 1216: Set window title
http://vim.sourceforge.net/tip_view.php?tip_id=

Sometimes I end up editing meny files in different terminals (under X). Also, I like to use Alt-Tab to switch between them.
The problem is that usually all these windows have the same title e.g. "Shell - Konsole <5>" (Well ok, the number 5 is different) and sometimes
it takes me a while to select the one I want. The script below sets the title to: "VIM : <working-directory> : <file-beeing-edited>" every time you
enter a buffer (on file open, buffer switch,...).

To use it, write the script to ~/.vimrc file and then
replace <char-1> with '^[' which is written as '<C-v>[' and
replace <char-2> with '^G' which is written as '<C-g>'

"---------------------------------------------------------------------

function! SetTitle()
    let l:text = "VIM - " . getcwd()

    if expand("%") != ''
        let l:text = l:text . " : " . expand("%:t")
    endif

    "-----------------------------------------------
    let l:escaped_text = '<char-1>]0;' . l:text . '<char-2>G'
    exe "silent ! /bin/echo \"". l:escaped_text ."\""
    "-----------------------------------------------

    redraw!
endfunction

au BufEnter * :call SetTitle()

"---------------------------------------------------------------------

I have no idea if this would work on non UN*X system, also if someone knew how to write '^[' and '^G' more nicelly, please let me know.

VimTip 1217: Get a shell command for changing to the current directory
http://vim.sourceforge.net/tip_view.php?tip_id=

This tip is supposed to help provide an easy way to synchronize the current directory
between a Vim session and a shell.  The most naive approach is to simply build a
command for changing to the current directory in Vim, and then paste and execute that
command within your shell.  This is the approach we take here.  The following command
line places a string of the form `cd "<current directory"` in the paste register (@+):

  let @+="cd \"" . escape(getcwd(), "\"") . "\""

Here, we escape any double-quote characters in the path name because quotes are used
in the string itself as argument delimiters.  You could then map this to a key sequence or
use it in other ways.  I've chosen to make it the definition for a command, as follows:

  com Scd let @+="cd \"" . escape(getcwd(), "\"") . "\""

(Where "Scd" could stand for "Save current directory" or "Shell cd".  Of course, you could
use a different name entirely.)  If you wanted to generate a `cd` command for the directory
of the current file, instead of the current working directory, you could use `expand("%:p:h")`
instead of `getcwd()` in the above expressions, as mentioned in vimtip #64.  I like to keep
the two actions separate, so I have another command for quickly changing to the directory
of the current file:

  com Fcd cd %:p:h

(Where "Fcd" could stand for "File current directory".)

VimTip 1218: Quick peak at files
http://vim.sourceforge.net/tip_view.php?tip_id=

  In an operating system's command-line terminal, one can get a
  quick peak at a file using commands such as more, cat, head etc.
  In vim, one way to peak at a file would be to open it in a new
  buffer -- but there is a way to peak at a file from vim without
  having to open it in a buffer, browse it and close the buffer --
  one can just view it in vim's command line!  This mode of viewing
  is facilitated in vim version 7 by version 7's support for
  scrolling (see :help scroll-back).

  So to peak at a file, we just echo its contents (:help echo; info
  on other commands mentioned here can be found likewise via :help).

  Simple implementation:
  ---------------------
  One way to implement the idea would be:

      :new|r <file_name>|1d|exec 'normal "ayG'|q!|echo @a

  One could also do :echo system('cat foo.bat'), but we are trying
  to avoid explicit system calls.  In version 7, vim supports
  readfile().  But the results of readfile() is an array of lines --
  and these lines would need to be joined to enable viewing; so we
  have:

      :echo join(readfile('foo.bat'), "\n")

  Applications:
  ------------
  Here are two applications that build on the idea presented here.

  A) Yasuhiro Matsumoto's calendar utility (vimscript #52) is
     written to display the calendar in a buffer. For a quick peak
     at the calendar, one can modify the plugin to support echoing
     the calendar in vim's command line, and make a simple map (such
     as of a RightMouse click) to trigger the display on the command
     line!

  B) I have the following in my vimfiles\after\ftplugin\index.vim
     to speed up previewing emails using my mail user agent utility
     (vimscript #1052)

     if(v:version < 700)


         nnoremap <buffer> <space> :exec "let @a='r '.expand('%:p:h').'/'.substitute(
                                      \getline('.'),
                                      \'\\(^.*\|\\s*\\)\\\|\\(\\s\\s*$\\)',
                                      \'',
                                      \'g')
                                      \\\|new\\|@a\\|1d\\|
                                      \silent exec 'normal\ d}\"ayG'\\|q!\\|echo\ @a"<cr>
     else


         nnoremap <buffer> <space> :exec "let alist=readfile(expand('%:p:h').'/'.
                                      \substitute(getline('.'),
                                                 \'\\(^.*\|\\s*\\)\\\|\\(\\s\\s*$\\)',
                                                 \'',
                                                 \'g')
                                      \)\\|
                                      \while(remove(alist, 0) != '')
                                      \\\|endwhile
                                      \\\|echo\
                                      \substitute(getline('.'),
                                                 \'\\(^.*\|\\s*\\)\\\|\\(\\s\\s*$\\)',
                                                 \'',
                                                 \'g').\"\n\n\"
                                      \\\|echo join(alist,\"\n\")"<cr>


     endif

  Acknowledgment:
  --------------
  While the idea presented here is mine, people on the vim@vim.org
  mailing list suggested alternate ways of implementing it and
  helped with some implementation details (such as escaping |).

  Happy vimming!


  --Suresh

